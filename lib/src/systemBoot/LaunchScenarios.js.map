{"version":3,"sources":["../../../src/systemBoot/LaunchScenarios.es6"],"names":["instance","LaunchScenarios","lastLaunch","name","CONSTANT","ELIOT_LAUNCHING_MODE","MASTER","func","master","SLAVE","slave","options","launchMasterSlaveConfigurationFile","method","RoleAndTask","getInstance","spreadStateToListener","readLaunchMasterSlaveConfigurationFile","launchConfFileContent","changeEliotState","DEFAULT_STATES","READY_PROCESS","id","roleHandler","getRoleHandler","optCreatSlave","parseEqualsArrayOptions","ELIOT_LAUNCHING_PARAMETERS","MODE_OPTIONS","parsedOptions","SLAVE_START_ARGS","map","x","forEach","startRole","DEFAULT_ROLE","SLAVE_ROLE","filename","Utils","readFile","parseHjsonContent","Array","Error","tmp","ret","some","split","length"],"mappings":"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","file":"LaunchScenarios.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport CONSTANT from '../Utils/CONSTANT/CONSTANT.js';\nimport Utils from '../Utils/Utils.js';\nimport applyConfigurationMasterSlaveLaunch from './applyConfigurationMasterSlaveLaunch.js';\nimport RoleAndTask from '../RoleAndTask.js';\n\nlet instance = null;\n\n/**\n * This class implement the different launch scenarios of ELIOT\n */\nexport default class LaunchScenarios {\n  constructor() {\n    if (instance) return instance;\n\n    this.lastLaunch = false;\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * SINGLETON implementation\n   */\n  static getInstance() {\n    return instance || new LaunchScenarios();\n  }\n\n  /**\n   * Get the map of launching modes\n   */\n  getMapLaunchingModes() {\n    return [{\n      name: CONSTANT.ELIOT_LAUNCHING_MODE.MASTER,\n      func: this.master,\n    }, {\n      name: CONSTANT.ELIOT_LAUNCHING_MODE.SLAVE,\n      func: this.slave,\n    }];\n  }\n\n  /**\n   * Read the Master Slave launch configuration file\n   */\n  static async readLaunchMasterSlaveConfigurationFile(filename) {\n    return Utils.parseHjsonContent(await Utils.readFile(filename));\n  }\n\n  /**\n   * Start ELIOT in master mode\n   */\n  async master(options, launchMasterSlaveConfigurationFile) {\n    this.lastLaunch = {\n      method: this.master,\n      options,\n    };\n\n    // Say to people in which state we are at launch -> LAUNCHING\n    await RoleAndTask.getInstance()\n      .spreadStateToListener();\n\n    // LaunchScenarios the display of the eliot state (launching)\n    // Load the configuration file configuration\n    const launchConfFileContent = await LaunchScenarios.readLaunchMasterSlaveConfigurationFile(launchMasterSlaveConfigurationFile);\n\n    await applyConfigurationMasterSlaveLaunch(launchConfFileContent);\n\n    // Here we can put the system as ready\n    await RoleAndTask.getInstance()\n      .changeEliotState(CONSTANT.DEFAULT_STATES.READY_PROCESS.id);\n\n    /*\n\n      // Here all tasks got launched we pass to the next step of initialization which is checking part\n      // Do we perform a check at launch?\n      if (CONSTANT.AUTO_CHECKING) {\n        await RoleAndTask.initiateEntirePlateformCheckProcessus();\n      }\n\n      // Display the actual data on node that's running eliot right now\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: JSON.stringify(process.versions, null, 2),\n        });\n\n      // Handle the reset of the database if this is in the configuration file\n      if (CONSTANT.RESET_DATABASE_AT_STARTUP) {\n        await RoleAndTask.getInstance()\n          .executeCommandOnExecuteLocalCommandsTaskAndGetTheResult({\n            commandName: 'initDatabase',\n\n            data: {\n              request: {\n                initializationTypeName: [\n                  'all',\n                ],\n\n                resetMainDatabase: true,\n              },\n            },\n\n            specialUser: RoleAndTask.SpecialUser.LOCALHOST_ROOT,\n          });\n      }\n\n      // Do we launch in prod mode\n      if (CONSTANT.PROD_LAUNCH) {\n        await RoleAndTask.getInstance()\n          .changeEliotState(CONSTANT.ELIOT_STATE.IN_PRODUCTION.id);\n      }\n\n    */\n\n    return true;\n  }\n\n  /**\n   * Takes option-key = ['optA=12', 'optB=78', ...]\n   * and return [\n   *   optA: '12',\n   *   optB: '78',\n   * ]\n   *\n   * @param {Object} options\n   * @param {String} name\n   */\n  static async parseEqualsArrayOptions(options, name) {\n    // If there is none informations\n    if (!options || !options[name]) return {};\n\n    if (!(options[name] instanceof Array)) throw new Error(`INVALID_LAUNCHING_PARAMETER : Parameter: ${name}`);\n\n    let tmp;\n\n    const parsedOptions = {};\n    const ret = options[name].some((x) => {\n      tmp = x.split('=');\n\n      // If the pattern optA=value isn't respected return an error\n      if (tmp.length !== 2) return true;\n\n      parsedOptions[tmp[0]] = tmp[1];\n\n      return false;\n    });\n\n    if (ret) throw new Error(`INVALID_LAUNCHING_PARAMETER : Parameter: ${name}`);\n\n    return parsedOptions;\n  }\n\n  /**\n   * Start ELIOT in slave mode\n   */\n  async slave(options) {\n    const roleHandler = RoleAndTask.getInstance()\n      .getRoleHandler();\n\n    const optCreatSlave = {};\n\n    this.lastLaunch = {\n      method: this.slave,\n      options,\n    };\n\n    // We have something like mode-options = ['optA=12', 'optB=78', ...]\n    const parsedOptions = await LaunchScenarios.parseEqualsArrayOptions(options, CONSTANT.ELIOT_LAUNCHING_PARAMETERS.MODE_OPTIONS.name);\n\n    // Create dynamically the options to create a new slave depending on what the CLI gave to us\n    // Add as enter parameter all parameters that can be taken as Slave start\n    Object.keys(CONSTANT.SLAVE_START_ARGS)\n      .map(x => CONSTANT.SLAVE_START_ARGS[x])\n      .forEach((x) => {\n        if (parsedOptions[x]) optCreatSlave[x] = parsedOptions[x];\n      });\n\n    await roleHandler.startRole(CONSTANT.DEFAULT_ROLE.SLAVE_ROLE.id, optCreatSlave);\n\n    return true;\n  }\n}\n"]}