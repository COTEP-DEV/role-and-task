{"version":3,"sources":["../../../src/systemBoot/LaunchScenarios.es6"],"names":["instance","LaunchScenarios","lastLaunch","name","CONSTANT","PROGRAM_LAUNCHING_MODE","MASTER","func","master","SLAVE","slave","RoleAndTask","getInstance","customLaunchingMode","options","launchMasterSlaveConfigurationFile","PromiseCommandPattern","method","spreadStateToListener","readLaunchMasterSlaveConfigurationFile","launchConfFileContent","changeProgramState","DEFAULT_STATES","READY_PROCESS","id","roleHandler","getRoleHandler","optCreatSlave","parseEqualsArrayOptions","PROGRAM_LAUNCHING_PARAMETERS","MODE_OPTIONS","parsedOptions","SLAVE_START_ARGS","map","x","forEach","startRole","DEFAULT_ROLES","SLAVE_ROLE","filename","Utils","readFile","parseHjsonContent","Array","Errors","tmp","ret","some","split","length"],"mappings":"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","file":"LaunchScenarios.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport CONSTANT from '../Utils/CONSTANT/CONSTANT.js';\nimport Utils from '../Utils/Utils.js';\nimport Errors from '../Utils/Errors.js';\nimport applyConfigurationMasterSlaveLaunch from './applyConfigurationMasterSlaveLaunch.js';\nimport RoleAndTask from '../RoleAndTask.js';\nimport PromiseCommandPattern from '../Utils/PromiseCommandPattern.js';\n\nlet instance = null;\n\n/**\n * This class implement the different launch scenarios of PROGRAM\n */\nexport default class LaunchScenarios {\n  constructor() {\n    if (instance) return instance;\n\n    this.lastLaunch = false;\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * SINGLETON implementation\n   */\n  static getInstance() {\n    return instance || new LaunchScenarios();\n  }\n\n  /**\n   * Get the map of launching modes\n   */\n  getMapLaunchingModes() {\n    return [{\n        name: CONSTANT.PROGRAM_LAUNCHING_MODE.MASTER,\n        func: this.master,\n      }, {\n        name: CONSTANT.PROGRAM_LAUNCHING_MODE.SLAVE,\n        func: this.slave,\n      },\n\n      // Add the custom launching mode in the map so they are taken in count\n      ...RoleAndTask.getInstance()\n      .customLaunchingMode,\n    ];\n  }\n\n  /**\n   * Read the Master Slave launch configuration file\n   */\n  static readLaunchMasterSlaveConfigurationFile(filename) {\n    return new PromiseCommandPattern({\n      func: async () => Utils.parseHjsonContent(await Utils.readFile(filename)),\n    });\n  }\n\n  /**\n   * Start PROGRAM in master mode\n   */\n  master(options, launchMasterSlaveConfigurationFile) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        this.lastLaunch = {\n          method: this.master,\n          options,\n        };\n\n        // Say to people in which state we are at launch -> LAUNCHING\n        await RoleAndTask.getInstance()\n          .spreadStateToListener();\n\n        // LaunchScenarios the display of the program state (launching)\n        // Load the configuration file configuration\n        const launchConfFileContent = await LaunchScenarios.readLaunchMasterSlaveConfigurationFile(launchMasterSlaveConfigurationFile);\n\n        await applyConfigurationMasterSlaveLaunch(launchConfFileContent);\n\n        // Here we can put the system as ready\n        await RoleAndTask.getInstance()\n          .changeProgramState(CONSTANT.DEFAULT_STATES.READY_PROCESS.id);\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Takes option-key = ['optA=12', 'optB=78', ...]\n   * and return [\n   *   optA: '12',\n   *   optB: '78',\n   * ]\n   *\n   * @param {Object} options\n   * @param {String} name\n   */\n  static parseEqualsArrayOptions(options, name) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // If there is none informations\n        if (!options || !options[name]) return {};\n\n        if (!(options[name] instanceof Array)) throw new Errors('INVALID_LAUNCHING_PARAMETER', `Parameter: ${name}`);\n\n        let tmp;\n\n        const parsedOptions = {};\n        const ret = options[name].some((x) => {\n          tmp = x.split('=');\n\n          // If the pattern optA=value isn't respected return an error\n          if (tmp.length !== 2) return true;\n\n          parsedOptions[tmp[0]] = tmp[1];\n\n          return false;\n        });\n\n        if (ret) throw new Errors('INVALID_LAUNCHING_PARAMETER', `Parameter: ${name}`);\n\n        return parsedOptions;\n      },\n    });\n  }\n\n  /**\n   * Start PROGRAM in slave mode\n   */\n  slave(options) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const roleHandler = RoleAndTask.getInstance()\n          .getRoleHandler();\n\n        const optCreatSlave = {};\n\n        this.lastLaunch = {\n          method: this.slave,\n          options,\n        };\n\n        // We have something like mode-options = ['optA=12', 'optB=78', ...]\n        const parsedOptions = await LaunchScenarios.parseEqualsArrayOptions(options, CONSTANT.PROGRAM_LAUNCHING_PARAMETERS.MODE_OPTIONS.name);\n\n        // Create dynamically the options to create a new slave depending on what the CLI gave to us\n        // Add as enter parameter all parameters that can be taken as Slave start\n        Object.keys(CONSTANT.SLAVE_START_ARGS)\n          .map(x => CONSTANT.SLAVE_START_ARGS[x])\n          .forEach((x) => {\n            if (parsedOptions[x]) optCreatSlave[x] = parsedOptions[x];\n          });\n\n        await roleHandler.startRole(CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.id, optCreatSlave);\n\n        return true;\n      },\n    });\n  }\n}\n"]}