{"version":3,"sources":["../../../../../src/RoleSystem/Role/RoleMaster/Master1_0.es6"],"names":["instance","Master1_0","name","CONSTANT","DEFAULT_ROLE","MASTER_ROLE","id","pathToEntryFile","tasks","RoleAndTask","getInstance","getRoleTasks","setTaskHandler","TaskHandler","initProperties","communicationSystem","slaves","notConfirmedSlaves","consoleChildObjectPtr","newConnectionListeningFunction","newDisconnectionListeningFunction","cpuUsageAndMemory","tasksInfos","func","filter","x","context","push","clientIdentityByte","clientIdentityString","body","regularSlaves","getSlavesOnlyThatAreRegularSlaves","limitToTaskList","forEach","some","y","isActive","includes","sendMessageToSlaveHeadBodyPattern","eliotIdentifier","PROTOCOL_MASTER_SLAVE","MESSAGES","GENERIC_CHANNEL_DATA","spreadDataToEveryLocalTask","data","sendDataToEveryELIOTTaskWhereverItIsLowLevel","err","slave","find","error","somethingChangedAboutSlavesOrI","Error","Utils","displayMessage","str","String","stack","out","process","stderr","changeEliotState","DEFAULT_STATES","ERROR","tellHandleEliotTaskAboutSlaveError","getMakesErrorFatal","exitEliotUnproperDueToError","ASK_DB_INIT","askForDatabaseInitialization","serialize","DB_INIT_DONE","databaseIntializationDone","ASK_DATABASE_CONNECTION_CHANGE","askForDatabaseConnectionChange","newLogsToApply","all","map","sendMessageAndWaitForTheResponse","identifierSlave","isHeadBodyPattern","messageHeaderToSend","CHANGE_DATABASE_CONNECTION","messageBodyToSend","messageHeaderToGet","rets","changeDatabaseConnection","PROTOCOL_KEYWORDS","HEAD","BODY","SLAVE_CONFIRMATION_INFORMATIONS","OUTPUT_TEXT","INFOS_ABOUT_SLAVES","ERROR_HAPPENED","getCommunicationSystem","listenClientConnectionEvent","split","clientPID","cyan","closeConnectionToClient","sendMessageToClient","listenClientDisconnectionEvent","red","fireUp","confirmSlave","dataJSON","index","findIndex","role","splice","listenToIncomingMessage","dataString","convertStringToJSON","checkFunc","applyFunc","infosAboutSlaveIncomming","errorHappenedIntoSlave","protocolHandleDatabaseInitializationAsk","protocolHandleDatabaseInitializationDone","protocolHandleDatabaseConnectionChangeAsk","notConfirmedSlave","ptr","moreInfos","resolve","pid","idTaskToConnectTo","idTaskToConnect","args","monoline","blue","getTaskHandler","getTask","task","connection","connectToTask","green","CONNECT_TASK_TO_TASK","idTask","ret","identifier","status","xi","yi","START_TASK","modifyTaskStatusToSlaveLocalArray","master","getSlave","LIST_TASKS","getSlaveByEliotIdentifier","eliotState","oldEliotState","applyNewEliotState","tellAllSlaveThatEliotStateChanged","SLAVE_ROLE","tellASlaveThatEliotStateChanged","slaveIdentifier","STATE_CHANGE","timeoutToGetMessage","MASTER_MESSAGE_WAITING_TIMEOUT_STATE_CHANGE","identifiersSlaves","promiseQueue","functionToCall","sendMessageToSlave","CLOSE","kill","SIGNAL_UNPROPER","SIGUSR1","STOP_TASK","MASTER_MESSAGE_WAITING_TIMEOUT_STOP_TASK","param","displayTask","getDisplayLog","slaveOpts","specificOpts","connectionTimeout","reject","uniqueSlaveId","generateUniqueEliotID","eliotOpts","opts","ELIOT_LAUNCHING_PARAMETERS","MODE","ELIOT_LAUNCHING_MODE","SLAVE","MODE_OPTIONS","SLAVE_START_ARGS","IDENTIFIER","forkOpts","pathToExec","child","childProcess","fork","timeoutConnection","setTimeout","SIGNAL_TO_KILL_SLAVE_COMMAND","on","code","connectEvent","slaveInfos","clearTimeout","unlistenSlaveConnectionEvent","listenSlaveConnectionEvent","dynamicallyRefreshDataIntoList","confirmedSlaves","getTaskListStatus","communication","ips","givesLocalIps","cpuAndMemory","notifyAboutArchitectureChange","tellOneTaskAboutArchitectureChange","SLAVE_CREATION_CONNECTION_TIMEOUT","startNewSlaveInProcessMode","headString","bodyString","message","timeout","MASTER_MESSAGE_WAITING_TIMEOUT","timeoutFunction","msgListener","unlistenToIncomingMessage","intervalFdCpuAndMemory","DISPLAY_CPU_MEMORY_CHANGE_TIME","setInterval","getCpuAndMemoryLoad","active","clearInterval","errorHappened","intervalFdTasksInfos","taskHandler","getInfosFromAllActiveTasks","infos","SLAVES_INFOS_CHANGE_TIME","ipServer","ZERO_MQ","DEFAULT_SERVER_IP_ADDRESS","portServer","DEFAULT_SERVER_IP_PORT","ZeroMQServerRouter","start","transport","TRANSPORT","IPC","protocolMasterSlave","infiniteGetCpuAndMemory","infiniteGetTasksInfos","tasksMaster","computeListClosure","sortArray","closureHierarchy","idTaskToRemove","isMasterTask","isSlaveTask","hierarchyLevel","foundHighestInHierarchy","hierarchyY","getHierarchyLevelByIdTask","length","hierarchyX","chooseWhichTaskToStop","stopTask","stopAllTaskOnEverySlaveAndMaster","removeTaskFromSlave","removeExistingSlave","stop","sendMessageGoodFunc","errAlreadyReturned","getMessageFromSlave","then","catch","call","toRet","arr","i","tmp","AMaster"],"mappings":"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","file":"Master1_0.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport childProcess from 'child_process';\nimport AMaster from './AMaster.js';\nimport CONSTANT from '../../../Utils/CONSTANT/CONSTANT.js';\nimport TaskHandler from '../../Handlers/TaskHandler.js';\nimport ZeroMQServerRouter from '../../../CommunicationSystem/SocketCommunicationSystem/ZeroMQ/Server/Implementations/ZeroMQServerRouter.js';\nimport Utils from '../../../Utils/Utils.js';\nimport RoleAndTask from '../../../RoleAndTask.js';\n\nlet instance = null;\n\n/**\n * Define the Role of Master which have a job of manager.\n *\n * Manage Slaves.\n */\nexport default class Master1_0 extends AMaster {\n  constructor() {\n    super();\n\n    if (instance) return instance;\n\n    this.name = CONSTANT.DEFAULT_ROLE.MASTER_ROLE.name;\n    this.id = CONSTANT.DEFAULT_ROLE.MASTER_ROLE.id;\n\n    this.pathToEntryFile = false;\n\n    // Get the tasks related to the master role\n    const tasks = RoleAndTask.getInstance()\n      .getRoleTasks(CONSTANT.DEFAULT_ROLE.MASTER_ROLE.id);\n\n    // Define all tasks handled by this role\n    this.setTaskHandler(new TaskHandler(tasks));\n\n    this.initProperties();\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * Init the properties\n   */\n  initProperties() {\n    // Define none communicationSystem for now\n    this.communicationSystem = false;\n\n    // Array of current approved slaves\n    this.slaves = [];\n\n    // Array of slaves that are in the confirmation process\n    this.notConfirmedSlaves = [];\n\n    // Array that contains the relation between console process ptr and eliotIdentifier\n    // We use it too when there is no console launch, because it work with both soluce\n    this.consoleChildObjectPtr = [];\n\n    // Functions called when something happend to a slave connection\n    this.newConnectionListeningFunction = [];\n    this.newDisconnectionListeningFunction = [];\n\n    // Data we keep as attribute to give to handleEliotTask later\n    this.cpuUsageAndMemory = false;\n    this.tasksInfos = false;\n  }\n\n  /**\n   * Get the communicationSystem\n   */\n  getCommunicationSystem() {\n    return this.communicationSystem;\n  }\n\n  /**\n   * SINGLETON implementation\n   * @override\n   */\n  static getInstance() {\n    return instance || new Master1_0();\n  }\n\n  /**\n   * Pull a function that get fired when a slave get connected\n   */\n  unlistenSlaveConnectionEvent(func) {\n    this.newConnectionListeningFunction = this.newConnectionListeningFunction.filter(x => x.func !== func);\n  }\n\n  /**\n   * Pull a function that get fired when a slave get disconnected\n   */\n  unlistenSlaveDisconnectionEvent(func) {\n    this.newDisconnectionListeningFunction = this.newDisconnectionListeningFunction.filter(x => x.func !== func);\n  }\n\n  /**\n   * Push a function that get fired when a slave get connected\n   */\n  listenSlaveConnectionEvent(func, context) {\n    this.newConnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Push a function that get fired when a slave get disconnected\n   */\n  listenSlaveDisconnectionEvent(func) {\n    this.newDisconnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Return the array that contains non-confirmed slaves\n   */\n  getNonConfirmedSlaves() {\n    return this.notConfirmedSlaves;\n  }\n\n  /**\n   *  Get an array that contains confirmed slaves\n   */\n  getSlaves() {\n    return this.slaves;\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks and our tasks\n   *\n   * WARNING - DO NOT SEND IT TO NON-REGULAR SLAVES (CRON_EXECUTOR_ROLE FOR EXAMPLE)\n   *\n   * @param {[Byte]} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {Object} data\n   */\n  sendDataToEveryELIOTTaskWhereverItIsLowLevel(clientIdentityByte, clientIdentityString, body) {\n    const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n    // Open the body to get the list of tasks we limit the spread on\n    const {\n      limitToTaskList,\n    } = body;\n\n\n    // For each slave\n    regularSlaves.forEach((x) => {\n      // Only send the data to the slaves that holds a tasks that need to know about the message\n      if (!limitToTaskList || x.tasks.some(y => y.isActive && limitToTaskList.includes(y.id))) {\n        // Send a message to every running slaves\n        this.sendMessageToSlaveHeadBodyPattern(x.eliotIdentifier, CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.GENERIC_CHANNEL_DATA, body);\n      }\n    });\n\n    // For itself tasks\n    RoleAndTask.getInstance()\n      .spreadDataToEveryLocalTask(body);\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks and our tasks\n   */\n  sendDataToEveryELIOTTaskWhereverItIs(data) {\n    this.sendDataToEveryELIOTTaskWhereverItIsLowLevel(false, false, data);\n  }\n\n  /**\n   * Tell the handleEliotTask about something happend in slaves\n   */\n  tellHandleEliotTaskAboutSlaveError(clientIdentityString, err) {\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    if (!slave) return;\n\n    slave.error = err;\n    this.somethingChangedAboutSlavesOrI();\n  }\n\n  /**\n   * An error happended into a slave, what do we do?\n   * @param {Array} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {String} body\n   */\n  async errorHappenedIntoSlave(clientIdentityByte, clientIdentityString) {\n    // const err = Errors.deserialize(body);\n    const err = new Error('Deserialized');\n\n    // Display the error\n    Utils.displayMessage({\n      str: String((err && err.stack) || err),\n      out: process.stderr,\n    });\n\n    try {\n      // Get the client that got the problem\n      // We try to change the eliot state to error\n      await RoleAndTask.getInstance()\n        .changeEliotState(CONSTANT.DEFAULT_STATES.ERROR.id);\n\n      // We goodly changed the eliot state\n      // Add informations on error\n\n      Utils.displayMessage({\n        str: String((err && err.stack) || err),\n        out: process.stderr,\n      });\n\n      // Tell the task handleEliot that there had been an error for the slave\n      this.tellHandleEliotTaskAboutSlaveError(clientIdentityString, err);\n\n      // If the errors are supposed to be fatal, exit!\n      if (RoleAndTask.getInstance()\n        .getMakesErrorFatal()) {\n        RoleAndTask.exitEliotUnproperDueToError();\n      }\n      // We leave the process because something get broken\n    } catch (errNested) {\n      Utils.displayMessage({\n        str: 'Exit eliot unproper ERROR HAPPENED IN SLAVE',\n        out: process.stderr,\n      });\n\n      Utils.displayMessage({\n        str: String((errNested && errNested.stack) || errNested),\n        out: process.stderr,\n      });\n\n      RoleAndTask.exitEliotUnproperDueToError();\n    }\n  }\n\n  /**\n   * Handle a slave that ask for database initialization\n   * @param {Array} clientIdentityByte\n   * @param {String} clientIdentityString\n   */\n  async protocolHandleDatabaseInitializationAsk(clientIdentityByte, clientIdentityString) {\n    const {\n      ASK_DB_INIT,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    try {\n      await RoleAndTask.getInstance()\n        .askForDatabaseInitialization();\n\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, ASK_DB_INIT, JSON.stringify({\n        error: false,\n      }));\n    } catch (err) {\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, ASK_DB_INIT, JSON.stringify({\n        error: err.serialize(),\n      }));\n    }\n  }\n\n  /**\n   * Handle a slave that say the database initialization is done\n   * @param {Array} clientIdentityByte\n   * @param {String} clientIdentityString\n   */\n  async protocolHandleDatabaseInitializationDone(clientIdentityByte, clientIdentityString) {\n    const {\n      DB_INIT_DONE,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    if (!slave) {\n      return this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, DB_INIT_DONE, JSON.stringify({\n        error: String(new Error('SLAVE_ERROR')),\n      }));\n    }\n\n    try {\n      await RoleAndTask.getInstance()\n        .databaseIntializationDone();\n\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, DB_INIT_DONE, JSON.stringify({\n        error: false,\n      }));\n    } catch (err) {\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, DB_INIT_DONE, JSON.stringify({\n        error: err.serialize(),\n      }));\n    }\n\n    return false;\n  }\n\n  /**\n   * Handle a slave that ask for database connection change\n   * @param {Array} clientIdentityByte\n   * @param {String} clientIdentityString\n   */\n  async protocolHandleDatabaseConnectionChangeAsk(clientIdentityByte, clientIdentityString, body) {\n    const {\n      ASK_DATABASE_CONNECTION_CHANGE,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    try {\n      await RoleAndTask.getInstance()\n        .askForDatabaseConnectionChange(body);\n\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, ASK_DATABASE_CONNECTION_CHANGE, JSON.stringify({\n        error: false,\n      }));\n    } catch (err) {\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, ASK_DATABASE_CONNECTION_CHANGE, JSON.stringify({\n        error: err.serialize(),\n      }));\n    }\n  }\n\n  /**\n   * Ask every slave to perform a connection data change and do it yourself\n   */\n  async askForDatabaseConnectionChange(newLogsToApply) {\n    const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n    // For each slave\n    // Send a message to every running slaves\n    const rets = await Promise.all(regularSlaves.map(x => this.sendMessageAndWaitForTheResponse({\n      identifierSlave: x.eliotIdentifier,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CHANGE_DATABASE_CONNECTION,\n      messageBodyToSend: newLogsToApply,\n      messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CHANGE_DATABASE_CONNECTION,\n    })));\n\n    // We get either an errors object or an error\n    if (rets.some(x => x !== '')) {\n      // We got an error\n      return rets.find(x => x !== '');\n    }\n\n    // We change our own database connection\n    await RoleAndTask.getInstance()\n      .changeDatabaseConnection(newLogsToApply);\n\n    return false;\n  }\n\n  /**\n   * Define the master/slave basic protocol\n   * (Authentification)\n   */\n  protocolMasterSlave() {\n    // Shortcuts\n    const {\n      HEAD,\n      BODY,\n    } = CONSTANT.PROTOCOL_KEYWORDS;\n\n    const {\n      SLAVE_CONFIRMATION_INFORMATIONS,\n      GENERIC_CHANNEL_DATA,\n      OUTPUT_TEXT,\n      INFOS_ABOUT_SLAVES,\n      ERROR_HAPPENED,\n      ASK_DB_INIT,\n      DB_INIT_DONE,\n      ASK_DATABASE_CONNECTION_CHANGE,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    // Listen at new Socket connection\n    //\n    // 1/ Check if the new slave have a correct identifier\n    // 2/ Ask the slave for running tasks\n    // 3/ Get the slave answer\n    // 4/ Add the slave into handled slave\n    //\n    this.getCommunicationSystem()\n      .listenClientConnectionEvent((clientIdentityByte, clientIdentityString) => {\n        const [\n          eliotIdentifier,\n          clientPID,\n        ] = clientIdentityString.split('_');\n\n        // Look at the identity of the slave (and if we have duplicate)\n        if (this.slaves.find(x => x.eliotIdentifier === eliotIdentifier) ||\n          this.notConfirmedSlaves.find(x => x.eliotIdentifier === eliotIdentifier)) {\n          // Identity already in use by an other slave\n          // Close the connection\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `[${this.name}] Refuse slave cause of identity`.cyan,\n            });\n\n          return this.getCommunicationSystem()\n            .closeConnectionToClient(clientIdentityByte, clientIdentityString);\n        }\n\n        // So here the client do not exist already and the identifier is free\n\n        // Add the slave into the declared not confirmed array\n        this.notConfirmedSlaves.push({\n          clientIdentityString,\n          clientIdentityByte,\n          eliotIdentifier,\n          clientPID,\n          tasks: [],\n          error: false,\n        });\n\n        // Ask the slaves about its tasks\n        return this.getCommunicationSystem()\n          .sendMessageToClient(clientIdentityByte, clientIdentityString, SLAVE_CONFIRMATION_INFORMATIONS);\n      });\n\n    // Listen to slaves disconnection\n    this.getCommunicationSystem()\n      .listenClientDisconnectionEvent((clientIdentityString) => {\n        this.slaves = this.slaves.filter((x) => {\n          if (x.clientIdentityString === clientIdentityString) {\n            RoleAndTask.getInstance()\n              .displayMessage({\n                str: `[${this.name}] Slave get removed (connection)`.red,\n              });\n\n            // Fire when a slave get disconnected\n            Utils.fireUp(this.newDisconnectionListeningFunction, [x]);\n\n            return false;\n          }\n\n          return true;\n        });\n\n        this.notConfirmedSlaves = this.notConfirmedSlaves.filter((x) => {\n          if (x.clientIdentityString === clientIdentityString) {\n            RoleAndTask.getInstance()\n              .displayMessage({\n                str: `[${this.name}] Non-confirmed slave get removed (connection)`.red,\n              });\n\n            // Fire when a slave get disconnected\n            Utils.fireUp(this.newDisconnectionListeningFunction, [x]);\n\n            return false;\n          }\n\n          return true;\n        });\n      });\n\n    // Confirm a slave that wasn't\n    const confirmSlave = (clientIdentityByte, clientIdentityString, dataJSON) => {\n      const index = this.notConfirmedSlaves.findIndex(x => x.clientIdentityString === clientIdentityString);\n\n      if (index === -1) return;\n\n      // Confirm the slave\n      const slave = this.notConfirmedSlaves[index];\n\n      slave.tasks = dataJSON[BODY].tasks;\n      slave.role = dataJSON[BODY].role;\n\n      this.slaves.push(slave);\n\n      this.notConfirmedSlaves.splice(index, 1);\n\n      // Fire when a slave get connected\n      Utils.fireUp(this.newConnectionListeningFunction, [slave]);\n    };\n\n    // We listen to incoming messages\n    this.getCommunicationSystem()\n      .listenToIncomingMessage((clientIdentityByte, clientIdentityString, dataString) => {\n        const dataJSON = Utils.convertStringToJSON(dataString);\n\n        // Here we got all messages that comes from clients (so slaves)\n        // Check if the message answer particular message\n        // If it does apply the particular job\n        [{\n          //\n          // Check about the slave infos\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === SLAVE_CONFIRMATION_INFORMATIONS),\n          // It means we get the tasks list\n          applyFunc: () => confirmSlave(clientIdentityByte, clientIdentityString, dataJSON),\n        }, {\n          //\n          // Check about generic news\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === GENERIC_CHANNEL_DATA),\n          applyFunc: () => this.sendDataToEveryELIOTTaskWhereverItIsLowLevel(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about messages to display\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === OUTPUT_TEXT),\n          applyFunc: () => this.displayMessage(dataJSON[BODY]),\n        }, {\n          //\n          // Check about infos about slaves\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === INFOS_ABOUT_SLAVES),\n          applyFunc: () => this.infosAboutSlaveIncomming(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about error happened into slave\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === ERROR_HAPPENED),\n          applyFunc: () => this.errorHappenedIntoSlave(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about slave asking for DB initialization\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === ASK_DB_INIT),\n          applyFunc: () => this.protocolHandleDatabaseInitializationAsk(clientIdentityByte, clientIdentityString),\n        }, {\n          //\n          // Check about slave asking for DB initialization\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === DB_INIT_DONE),\n          applyFunc: () => this.protocolHandleDatabaseInitializationDone(clientIdentityByte, clientIdentityString),\n        }, {\n          //\n          // Check about slave asking for DB update startup\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === ASK_DATABASE_CONNECTION_CHANGE),\n          applyFunc: () => this.protocolHandleDatabaseConnectionChangeAsk(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }].forEach((x) => {\n          if (x.checkFunc()) x.applyFunc();\n        });\n      });\n  }\n\n  /**\n   * We got news about a slave -> infos\n   * Store it and call HandleEliotTask if it's up\n   * @param {Object} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {Object} data\n   */\n  infosAboutSlaveIncomming(clientIdentityByte, clientIdentityString, data) {\n    // Get the right slave\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n    const notConfirmedSlave = this.notConfirmedSlaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    const ptr = slave || notConfirmedSlave;\n\n    if (!ptr) return;\n\n    if (!ptr.moreInfos) ptr.moreInfos = {};\n\n    // Apply values to moreInfos\n    [\n      'cpuAndMemory',\n      'ips',\n      'tasksInfos',\n    ]\n    .forEach((x) => {\n      // To get the 0 value\n      if (data[x] !== void 0) ptr.moreInfos[x] = data[x];\n    });\n\n    // Tell something changed in the conf\n    this.somethingChangedAboutSlavesOrI();\n  }\n\n  /**\n   * Returns in an array the whole system pids (Master + Slaves processes)\n   */\n  getFullSystemPids() {\n    return new Promise((resolve) => {\n      resolve([\n        String(process.pid),\n        ...this.slaves.map(x => String(x.clientPID)),\n      ]);\n    });\n  }\n\n  /**\n   * Connect the second Task to the first one\n   * @param {String} idTaskToConnectTo\n   * @param {String} idTaskToConnect\n   * @param {Object} args\n   */\n  async connectMasterToTask(idTaskToConnectTo, idTaskToConnect, args) {\n    try {\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: Utils.monoline([\n              `[${this.name}] Ask Master to connect the Task N°${idTaskToConnect}`,\n              ` to the Task N°${idTaskToConnectTo}`,\n            ])\n            .blue,\n        });\n\n      const task = await this.getTaskHandler()\n        .getTask(idTaskToConnectTo);\n\n      // We get the task\n      // Error if the task is not active\n      if (!task.isActive()) {\n        throw new Error(`E7009 : idTask: ${idTaskToConnectTo}`);\n      }\n\n      // Ask the connection to be made\n      const connection = task.connectToTask(idTaskToConnect, args);\n\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: Utils.monoline([\n              `[${this.name}] Task N°${idTaskToConnect} correctly connected to Task `,\n              `N°${idTaskToConnectTo} in Master`,\n            ])\n            .green,\n        });\n\n      return connection;\n    } catch (err) {\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: Utils.monoline([\n              `[${this.name}] Task N°${idTaskToConnect} failed to be connected`,\n              ` to Task N°${idTaskToConnectTo} in Master`,\n            ])\n            .red,\n        });\n\n      throw err;\n    }\n  }\n\n  /**\n   * Connect the second Task to the first one\n   * @param {String} identifierSlave - Identifier of the slave that host the idTaskToConnectTo\n   * @param {String} idTaskToConnectTo\n   * @param {String} idTaskToConnect\n   * @param {Object} args\n   */\n  async connectTaskToTask(identifierSlave, idTaskToConnectTo, idTaskToConnect, args) {\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      identifierSlave,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CONNECT_TASK_TO_TASK,\n\n      messageBodyToSend: {\n        idTask: idTaskToConnectTo,\n        idTaskToConnect,\n        args,\n      },\n\n      messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CONNECT_TASK_TO_TASK,\n    });\n\n    // We get either an errors object or an error\n    if (ret === '') return ret;\n\n    throw ret;\n  }\n\n  /**\n   * Modify the status of the task attached to the given identifier\n   * (local data, have no impact in the real slave)\n   * @param {String} identifier\n   * @param {String} idTask\n   * @param {Boolean} status\n   */\n  modifyTaskStatusToSlaveLocalArray(identifier, idTask, status) {\n    this.slaves.some((x, xi) => {\n      if (x.eliotIdentifier === identifier) {\n        return x.tasks.some((y, yi) => {\n          if (y.id === idTask) {\n            this.slaves[xi].tasks[yi].isActive = status;\n\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * When called: Add a task to a slave\n   * @param {String} identifier\n   * @param {String} idTask\n   */\n  async startTaskToSlave(identifier, idTask, args = {}) {\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      identifierSlave: identifier,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.START_TASK,\n\n      messageBodyToSend: {\n        idTask,\n        args,\n      },\n\n      messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.START_TASK,\n    });\n\n    // We get either an errors object or an error\n    if (ret === '') {\n      // Modify the task status for the given slave\n      this.modifyTaskStatusToSlaveLocalArray(identifier, idTask, true);\n\n      // Say something changed\n      this.somethingChangedAboutSlavesOrI();\n\n      return ret;\n    }\n\n    // throw Errors.deserialize(ret);\n    throw new Error('deserialize');\n  }\n\n  /**\n   * List the existing slaves\n   */\n  async listSlaves() {\n    return this.master.getSlave;\n  }\n\n  /**\n   * List a slave tasks using its identifier (Ask the slave to it)\n   * @param {String} identifier\n   */\n  async distantListSlaveTask(identifier) {\n    return this.sendMessageAndWaitForTheResponse({\n      identifierSlave: identifier,\n      isHeadBodyPattern: false,\n      messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS,\n      messageBodyToSend: {},\n      messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS,\n    });\n  }\n\n  /**\n   * List a slave tasks using its identifier (Use local data to it)\n   * @param {String} identifier\n   */\n  async listSlaveTask(identifier) {\n    // Look for the slave in confirmSlave\n    const slave = this.getSlaveByEliotIdentifier(identifier);\n\n    return slave.tasks;\n  }\n\n  /**\n   * Handle the fact the eliot state change\n   * We spread the data on our tasks and to our slaves\n   * @param {Number} eliotState\n   * @param {Number} oldEliotState\n   */\n  async handleEliotStateChange(eliotState, oldEliotState) {\n    return Promise.all([\n      // Spread to our tasks\n      this.getTaskHandler()\n      .applyNewEliotState(eliotState, oldEliotState),\n\n      // Spread to slaves\n      this.tellAllSlaveThatEliotStateChanged(eliotState, oldEliotState),\n\n      // The spread n slaves went well\n    ]);\n  }\n\n  /**\n   * Return only the slaves that are regular slaves (not CRON_EXECUTOR_ROLE for example)\n   */\n  getSlavesOnlyThatAreRegularSlaves() {\n    return this.slaves.filter(x => x.role.id === CONSTANT.DEFAULT_ROLE.SLAVE_ROLE.id);\n  }\n\n  /**\n   * Tell all slave that the eliot state did change\n   *\n   * WARNING - DO NOT INCLUDE CRON_EXECUTOR_ROLE SLAVES INTO THE PIPE\n   *\n   * @param {Number} eliotState\n   * @param {Number} oldEliotState\n   */\n  async tellAllSlaveThatEliotStateChanged(eliotState, oldEliotState) {\n    const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n    return Promise.all(regularSlaves.map(x => this.tellASlaveThatEliotStateChanged(x.eliotIdentifier, eliotState, oldEliotState)));\n  }\n\n  /**\n   * Tell a slave that eliot state did change\n   * @param {String} slaveIdentifier\n   * @param {Number} eliotState\n   * @param {Number} oldEliotState\n   */\n  async tellASlaveThatEliotStateChanged(slaveIdentifier, eliotState, oldEliotState) {\n    const {\n      STATE_CHANGE,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      identifierSlave: slaveIdentifier,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: STATE_CHANGE,\n\n      messageBodyToSend: {\n        eliotState,\n        oldEliotState,\n      },\n\n      messageHeaderToGet: STATE_CHANGE,\n      timeoutToGetMessage: CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT_STATE_CHANGE,\n    });\n\n    // We get either an errors object or an error\n    if (ret === '') return ret;\n\n    RoleAndTask.getInstance()\n      .displayMessage({\n        str: `[${this.name}] eliot state get not spread in Slave N°${slaveIdentifier}`.red,\n      });\n\n    throw new Error('deserialize');\n\n    // throw Errors.deserialize(ret);\n  }\n\n  /**\n   * When called: Remove an existing slave(s)\n   * @param {Array} identifiersSlaves\n   * @param {?Number} _i\n   */\n  async removeExistingSlave(identifiersSlaves) {\n    return Utils.promiseQueue([\n      // Close all slaves\n      ...identifiersSlaves.map(x => ({\n        functionToCall: this.sendMessageToSlave,\n\n        context: this,\n\n        args: [\n          x,\n          CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CLOSE,\n        ],\n      })),\n\n      // Say that something changed\n      {\n        functionToCall: this.somethingChangedAboutSlavesOrI,\n        context: this,\n      },\n    ]);\n  }\n\n  /**\n   * Kill a slave using its identifier\n   * @param {String} eliotIdentifier\n   */\n  killSlave(eliotIdentifier) {\n    // Look for the given identifier\n    this.consoleChildObjectPtr.filter((x) => {\n      if (x.eliotIdentifier === eliotIdentifier) {\n        try {\n          // Kill the process\n          process.kill(x.pid, CONSTANT.SIGNAL_UNPROPER.SIGUSR1);\n\n          // Remove the slave from the slave list\n          this.slaves = this.slaves.filter(y => !(y.eliotIdentifier === eliotIdentifier));\n        } catch (err) {\n          // Ignore the error, because the slave is dead anyway to us\n        }\n\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * When called: remove a task from slave\n   *\n   * THIS FUNCTION HAVE SPECIAL TIMEOUT FOR SLAVE ANSWER\n   *\n   * @param {String} identifier\n   * @param {String} idTask\n   * @param {Object} args\n   */\n  async removeTaskFromSlave(identifier, idTask, args = {}) {\n    const {\n      STOP_TASK,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    RoleAndTask.getInstance()\n      .displayMessage({\n        str: `[${this.name}] Ask Slave N°${identifier} to stop the Task N°${idTask}`.blue,\n      });\n\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      identifierSlave: identifier,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: STOP_TASK,\n\n      messageBodyToSend: {\n        idTask,\n        args,\n      },\n\n      messageHeaderToGet: STOP_TASK,\n      timeoutToGetMessage: CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT_STOP_TASK,\n    });\n\n    // We get either an errors object or an error\n    if (ret === '') {\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: `[${this.name}] Task N°${idTask} correctly stopped in Slave N°${identifier}`.green,\n        });\n\n      // Modify the task status for the given slave\n      this.modifyTaskStatusToSlaveLocalArray(identifier, idTask, false);\n\n      return ret;\n    }\n\n    RoleAndTask.getInstance()\n      .displayMessage({\n        str: `[${this.name}] Task N°${idTask} failed to be stopped to Slave N°${identifier}`.red,\n      });\n\n    throw ret;\n  }\n\n  /**\n   * Display a message directly\n   * @param {Object} param\n   */\n  async displayMessage(param) {\n    try {\n      // If we have the display task active, we give the message to it\n      if (this.displayTask) {\n        const task = await this.getTaskHandler()\n          .getTask(this.displayTask);\n\n        // If we disallow log display, stop it here\n        if (!RoleAndTask.getInstance()\n          .getDisplayLog()) {\n          return false;\n        }\n\n        if (task.isActive()) {\n          return task.displayMessage(param);\n        }\n      }\n\n      // If not we display\n      Utils.displayMessage(param);\n    } catch (err) {\n      // Ignore error - We can't display the data - it do not require further error treatment\n      // Store the message into file tho\n      Utils.displayMessage({\n        str: String(err.stack || err),\n        out: process.stderr,\n      });\n    }\n\n    return false;\n  }\n\n  /**\n   * Start a new slave not in a console but in a regular process\n   * @param {{opts: String, uniqueSlaveId: String}} slaveOpts\n   * @param {Object} specificOpts - (Spawn options)\n   * @param {String} connectionTimeout\n   */\n  startNewSlaveInProcessMode(slaveOpts, specificOpts, connectionTimeout) {\n    return new Promise((resolve, reject) => {\n      // We create a unique Id that will referenciate the slave at the connexion\n      const uniqueSlaveId = (slaveOpts && slaveOpts.uniqueSlaveId) || Utils.generateUniqueEliotID();\n\n      // Options to send to the new created slave\n      const eliotOpts = (slaveOpts && slaveOpts.opts) || [\n        `--${CONSTANT.ELIOT_LAUNCHING_PARAMETERS.MODE.name}`,\n        `${CONSTANT.ELIOT_LAUNCHING_MODE.SLAVE}`,\n        `--${CONSTANT.ELIOT_LAUNCHING_PARAMETERS.MODE_OPTIONS.name}`,\n        `${CONSTANT.SLAVE_START_ARGS.IDENTIFIER}=${uniqueSlaveId}`,\n      ];\n\n      // Options to give to fork(...)\n      const forkOpts = {};\n\n      // If there is no path to the entry file to execute\n      if (!this.pathToEntryFile) {\n        throw new Error('Cannot start the slave : No pathToEntryFile configured');\n      }\n\n      // Path that lead to the exe of ELIOT\n      const pathToExec = this.pathToEntryFile;\n\n      // LaunchScenarios eliot in slave mode in a different process\n      const child = childProcess.fork(pathToExec, eliotOpts, forkOpts);\n\n      // LaunchScenarios a timeout of connection\n      const timeoutConnection = setTimeout(() => {\n        // Kill the process we did created\n        child.kill(CONSTANT.SIGNAL_TO_KILL_SLAVE_COMMAND);\n\n        return reject(new Error(`E7003 : Timeout ${connectionTimeout} ms passed`));\n      }, connectionTimeout);\n\n      // Look at error event (If it get fired it means the program failed to get launched)\n      // Handle the fact a child can result an error later on after first connection\n      // Error detected\n      child.on('error', err => reject(new Error(`E7003 : Exit Code: ${err}`)));\n\n      // Handle the fact a child get closed\n      // The close can be wanted, or not\n      child.on('close', (code) => {\n        // No error\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `Slave Close: ${code}`.red,\n          });\n      });\n\n      // Handle the fact a child exit\n      // The exit can be wanted or not\n      child.on('exit', (code) => {\n        // No error\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `Slave Exit: ${code}`.red,\n          });\n      });\n\n      // Now we need to look at communicationSystem of the master to know if the new slave connect to ELIOT\n      // If we pass a connection timeout time, we kill the process we just created and return an error\n      const connectEvent = (slaveInfos) => {\n        // Wait for a new client with the identifier like -> uniqueSlaveId_processId\n        if (slaveInfos && slaveInfos.eliotIdentifier === uniqueSlaveId) {\n          // We got our slave working well\n          clearTimeout(timeoutConnection);\n          this.unlistenSlaveConnectionEvent(connectEvent);\n\n          // Store the child data\n          this.consoleChildObjectPtr.push({\n            eliotIdentifier: uniqueSlaveId,\n            pid: slaveInfos.clientPID,\n          });\n\n          return resolve({\n            ...slaveInfos,\n            pid: slaveInfos.clientPID,\n          });\n        }\n\n        // This is not our slave\n\n        return false;\n      };\n\n      this.listenSlaveConnectionEvent(connectEvent);\n    });\n  }\n\n  /**\n   * Tell one task about what changed in the architecture\n   */\n  async tellOneTaskAboutArchitectureChange(idTask) {\n    try {\n      const task = await this.getTaskHandler()\n        .getTask(idTask);\n\n      // No HandleEliotTask so -> don't tell a new archiecture is here\n      if (!task) return;\n\n      if (task.isActive()) {\n        // Tell HandleEliotTask about new conf\n        task.dynamicallyRefreshDataIntoList({\n          notConfirmedSlaves: this.notConfirmedSlaves,\n          confirmedSlaves: this.slaves,\n\n          master: {\n            tasks: this.getTaskHandler()\n              .getTaskListStatus(),\n            communication: this.getCommunicationSystem(),\n            ips: Utils.givesLocalIps(),\n            cpuAndMemory: this.cpuUsageAndMemory,\n            tasksInfos: this.tasksInfos,\n          },\n        });\n      }\n    } catch (e) {\n      // Don't od anything because it's not an error\n    }\n  }\n\n  /**\n   * Do something when an information changed about ELIOT architecture\n   */\n  async somethingChangedAboutSlavesOrI() {\n    // Look at all tasks\n    await Promise.all(RoleAndTask.getInstance()\n      .tasks.filter(x => x.notifyAboutArchitectureChange)\n      .map(x => this.tellOneTaskAboutArchitectureChange(x.id)));\n  }\n\n  /**\n   * When called : start a new slave\n   * Take options in parameters or start a regular slave\n   *\n   * @param {{opts: String, uniqueSlaveId: String}} slaveOpts\n   * @param {Object} specificOpts - (Spawn options)\n   * @param {String} connectionTimeout\n   */\n  async startNewSlave(slaveOpts, specificOpts, connectionTimeout = CONSTANT.SLAVE_CREATION_CONNECTION_TIMEOUT) {\n    const ret = await this.startNewSlaveInProcessMode(slaveOpts, specificOpts, connectionTimeout);\n\n    // Say something changed\n    this.somethingChangedAboutSlavesOrI();\n\n    return ret;\n  }\n\n  /**\n   * Send a message that match head/body pattern\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * @param {String} eliotIdentifier\n   * @param {String} headString\n   * @param {String} bodyString\n   */\n  async sendMessageToSlaveHeadBodyPattern(eliotIdentifier, headString, bodyString) {\n    // Build up the message\n    const message = {\n      [CONSTANT.PROTOCOL_KEYWORDS.HEAD]: headString,\n      [CONSTANT.PROTOCOL_KEYWORDS.BODY]: bodyString,\n    };\n\n    // Send the message\n    return this.sendMessageToSlave(eliotIdentifier, JSON.stringify(message));\n  }\n\n  /**\n   * Send a message to a slave using an eliotIdentifier\n   * @param {String} eliotIdentifier\n   * @param {String} message\n   */\n  async sendMessageToSlave(eliotIdentifier, message) {\n    // Look for the slave in confirmSlave\n    const slave = this.getSlaveByEliotIdentifier(eliotIdentifier);\n\n    // Send the message\n    this.getCommunicationSystem()\n      .sendMessageToClient(slave.clientIdentityByte, slave.clientIdentityString, message);\n\n    return true;\n  }\n\n  /**\n   * Get a slave using its eliot id\n   * @param {String} eliotIdentifier\n   */\n  getSlaveByEliotIdentifier(eliotIdentifier) {\n    // Look for the slave in confirmSlave\n    const slave = this.slaves.find(x => x.eliotIdentifier === eliotIdentifier);\n\n    return slave || new Error(`E7004 : Identifier: ${eliotIdentifier}`);\n  }\n\n  /**\n   * Using the eliotIdentifier, wait a specific incoming message from a specific slave\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * If there is no answer before the timeout, stop waiting and send an error\n   * @param {String} headString\n   * @param {String} eliotIdentifier\n   * @param {Number} timeout - in ms\n   */\n  getMessageFromSlave(headString, eliotIdentifier, timeout = CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT) {\n    return new Promise((resolve, reject) => {\n      let timeoutFunction = false;\n\n      // Look for the slave in confirmSlave\n      const slave = this.getSlaveByEliotIdentifier(eliotIdentifier);\n\n      // Function that will receive messages from slaves\n      const msgListener = (clientIdentityByte, clientIdentityString, dataString) => {\n        // Check the identifier to be the one we are waiting a message for\n\n        if (clientIdentityString === slave.clientIdentityString) {\n          const dataJSON = Utils.convertStringToJSON(dataString);\n\n          // Here we got all messages that comes from clients (so slaves)\n          // Check if the message answer particular message\n          if (dataJSON && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] &&\n            dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] === headString) {\n            // Stop the timeout\n            clearTimeout(timeoutFunction);\n\n            // Stop the listening\n            this.getCommunicationSystem()\n              .unlistenToIncomingMessage(msgListener);\n\n            // We get our message\n            return resolve(dataJSON[CONSTANT.PROTOCOL_KEYWORDS.BODY]);\n          }\n        }\n\n        return false;\n      };\n\n      // If the function get triggered, we reject an error\n      timeoutFunction = setTimeout(() => {\n        // Stop the listening\n        this.getCommunicationSystem()\n          .unlistenToIncomingMessage(msgListener);\n\n        // Return an error\n        return reject(new Error('E7005'));\n      }, timeout);\n\n      // Listen to incoming messages\n      return this.getCommunicationSystem()\n        .listenToIncomingMessage(msgListener);\n    });\n  }\n\n  /**\n   * Send the cpu load to the server periodically\n   */\n  infiniteGetCpuAndMemory() {\n    if (this.intervalFdCpuAndMemory) return;\n\n    if (CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME) {\n      // When we connect, we send our infos to the master\n      this.intervalFdCpuAndMemory = setInterval(async () => {\n        try {\n          const cpuAndMemory = await Utils.getCpuAndMemoryLoad();\n\n          this.cpuUsageAndMemory = cpuAndMemory;\n\n          // Say something change\n          this.somethingChangedAboutSlavesOrI();\n\n          if (!this.active && this.intervalFdCpuAndMemory) {\n            clearInterval(this.intervalFdCpuAndMemory);\n\n            this.intervalFdCpuAndMemory = false;\n          }\n        } catch (err) {\n          RoleAndTask.getInstance()\n            .errorHappened(err);\n        }\n      }, CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME);\n    }\n  }\n\n  /**\n   * Get periodically the infos about tasks running in master\n   */\n  async infiniteGetTasksInfos() {\n    if (this.intervalFdTasksInfos) return;\n\n    this.intervalFdTasksInfos = setInterval(async () => {\n      try {\n        const infos = await this.taskHandler.getInfosFromAllActiveTasks();\n\n        this.tasksInfos = infos;\n\n        this.somethingChangedAboutSlavesOrI();\n\n        // If the role is still active we call it back\n        if (!this.active && this.intervalFdTasksInfos) {\n          clearInterval(this.intervalFdTasksInfos);\n\n          this.intervalFdTasksInfos = false;\n        }\n      } catch (err) {\n        RoleAndTask.getInstance()\n          .errorHappened(err);\n      }\n    }, CONSTANT.SLAVES_INFOS_CHANGE_TIME);\n  }\n\n  /**\n   * ELIOT start to play the role\n   *\n   * A master is defined as:\n   * A master have a Server ZeroMQ open\n   * A master is connected to Slaves\n   *\n   * pathToEntryFile is the path we will use to start new slaves\n   *\n   * @param {Object} args\n   * @override\n   */\n  async start({\n    ipServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_ADDRESS,\n    portServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_PORT,\n  }) {\n    // Reinitialize some properties\n    this.initProperties();\n\n    // Create the OMQ Server\n    this.communicationSystem = new ZeroMQServerRouter();\n\n    // Start the communication system\n    await this.communicationSystem.start({\n      ipServer,\n      portServer,\n      transport: CONSTANT.ZERO_MQ.TRANSPORT.IPC,\n    });\n\n    this.active = true;\n\n    this.protocolMasterSlave();\n\n    // Say something changed\n    this.somethingChangedAboutSlavesOrI();\n\n    // LaunchScenarios an infite get of cpu usage to give to handleEliotTask\n    this.infiniteGetCpuAndMemory();\n\n    // LaunchScenarios an infite get of tasks infos to give to handleEliotTask\n    this.infiniteGetTasksInfos();\n\n    return true;\n  }\n\n  /**\n   * Get the hierarchy level of the given task\n   */\n  static getHierarchyLevelByIdTask(computeListClosure, idTask) {\n    let toRet;\n\n    computeListClosure.some((x) => {\n      if (x.idTask === idTask) {\n        toRet = x.closureHierarchy;\n\n        return true;\n      }\n\n      return false;\n    });\n\n    return toRet;\n  }\n\n  /**\n   * Sort the array ASC by closureHierarchy\n   */\n  static sortArray(ptr) {\n    const arr = ptr;\n\n    for (let i = 0; i < (arr.length - 1); i += 1) {\n      if (arr[i].closureHierarchy > arr[i + 1].closureHierarchy) {\n        const tmp = arr[i + 1];\n\n        arr[i + 1] = arr[i];\n\n        arr[i] = tmp;\n\n        i = -1;\n      }\n    }\n\n    return arr;\n  }\n\n  /**\n   * This methods return the task we need to stop first\n   * There is an hierarchie in tasks closure\n   */\n  chooseWhichTaskToStop() {\n    const tasksMaster = this.getTaskHandler()\n      .getTaskListStatus();\n\n    // Compute a list in order of tasksID to close (following the closure hierarchy)\n    const computeListClosure = Master1_0.sortArray(tasksMaster.map(x => ({\n      idTask: x.id,\n      closureHierarchy: x.closureHierarchy,\n    })));\n\n    // Now look at slaves tasks, then master task, about the task that is the higher in closure hierarchy\n    const ret = {\n      idTaskToRemove: false,\n      isMasterTask: false,\n      isSlaveTask: false,\n      identifierSlave: false,\n      hierarchyLevel: false,\n      args: {},\n    };\n\n    const foundHighestInHierarchy = this.slaves.some(x => x.tasks.some((y) => {\n      // Look at the hierarchy level of the given task\n      const hierarchyY = Master1_0.getHierarchyLevelByIdTask(computeListClosure, y.id);\n\n      if (!y.isActive) return false;\n\n      // Look if this hierarchy is higher than the save one\n      if (ret.hierarchyLevel === false || (ret.hierarchyLevel > hierarchyY)) {\n        // Save the task to be the one that get to be removed (for now!)\n        ret.hierarchyLevel = hierarchyY;\n        ret.idTaskToRemove = y.id;\n        ret.isSlaveTask = true;\n        ret.isMasterTask = false;\n        ret.identifierSlave = x.eliotIdentifier;\n\n        // If the task we have is the highest in hierarchy, no need to look furthers\n        if (computeListClosure.length && hierarchyY === computeListClosure[0].closureHierarchy) return true;\n      }\n\n      return false;\n    }));\n\n    if (foundHighestInHierarchy) return ret;\n\n    // We didn't found the higest task in the hierarchy so look at master tasks, its maybe there\n    tasksMaster.some((x) => {\n      const hierarchyX = Master1_0.getHierarchyLevelByIdTask(computeListClosure, x.id);\n\n      if (!x.isActive) return false;\n\n      // Look if this hierarchy is higher than the save one\n      if (ret.hierarchyLevel === false || (ret.hierarchyLevel > hierarchyX)) {\n        // Save the task to be the one that get to be removed (for now!)\n        ret.hierarchyLevel = hierarchyX;\n        ret.idTaskToRemove = x.id;\n        ret.isSlaveTask = false;\n        ret.isMasterTask = true;\n        ret.identifierSlave = false;\n\n        // If the task we have is the highest in hierarchy, no need to look furthers\n        if (computeListClosure.length && hierarchyX === computeListClosure[0].closureHierarchy) return true;\n      }\n      return false;\n    });\n\n    return ret;\n  }\n\n  /**\n   * Stop all tasks on every slave and master following a specific closure order\n   * (Some tasks must be closed before/after some others)\n   *\n   * WARNING RECURSIVE CALL\n   */\n  async stopAllTaskOnEverySlaveAndMaster() {\n    // close one of the task\n    // master or slave task\n    const {\n      idTaskToRemove,\n      isMasterTask,\n      isSlaveTask,\n      identifierSlave,\n      args,\n    } = this.chooseWhichTaskToStop();\n\n    // No more task to stop\n    if (idTaskToRemove === false) {\n      // Say something changed\n      this.somethingChangedAboutSlavesOrI();\n\n      return true;\n    }\n\n    if (isMasterTask) {\n      await this.getTaskHandler()\n        .stopTask(idTaskToRemove, args);\n\n      // Call next\n      return this.stopAllTaskOnEverySlaveAndMaster();\n    }\n\n    if (isSlaveTask) {\n      await this.removeTaskFromSlave(identifierSlave, idTaskToRemove, args);\n\n      // Call next\n      return this.stopAllTaskOnEverySlaveAndMaster();\n    }\n\n    return true;\n  }\n\n  /**\n   * ELIOT stop to play the role\n   * @param {Object} args\n   * @override\n   */\n  async stop() {\n    // Say bye to every slaves\n    await this.stopAllTaskOnEverySlaveAndMaster();\n\n    await this.removeExistingSlave(this.slaves.map(x => x.eliotIdentifier));\n\n    // Stop the infinite loops\n    if (this.intervalFdCpuAndMemory) clearInterval(this.intervalFdCpuAndMemory);\n\n    if (this.intervalFdTasksInfos) clearInterval(this.intervalFdTasksInfos);\n\n    // Stop the communication system\n    await this.communicationSystem.stop();\n\n    this.active = false;\n\n    return true;\n  }\n\n  /**\n   * Send the given message and wait for the response\n   *\n   * HERE WE CREATE TWO EXECUTIONS LIFES\n   *\n   * Put isHeadBodyPattern = true if you want to use the headBodyPattern\n   *\n   * @param {Object} args\n   */\n  sendMessageAndWaitForTheResponse({\n    identifierSlave,\n    messageHeaderToSend,\n    messageBodyToSend,\n    messageHeaderToGet,\n    isHeadBodyPattern,\n\n    // Can be equals to undefined -> default timeout\n    timeoutToGetMessage,\n  }) {\n    return new Promise((resolve, reject) => {\n      // We switch to the appropriated func\n      const sendMessageGoodFunc = () => {\n        if (isHeadBodyPattern) return this.sendMessageToSlaveHeadBodyPattern;\n\n        return this.sendMessageToSlave;\n      };\n\n      let errAlreadyReturned = false;\n\n      // Be ready to get the message from the slave before to send it the command\n      this.getMessageFromSlave(messageHeaderToGet, identifierSlave, timeoutToGetMessage)\n        // Job done\n        .then(resolve)\n        .catch((err) => {\n          if (!errAlreadyReturned) {\n            errAlreadyReturned = true;\n\n            return reject(err);\n          }\n\n          return false;\n        });\n\n      // Send the command to the slave\n      sendMessageGoodFunc()\n        .call(this, identifierSlave, messageHeaderToSend, messageBodyToSend)\n        .then(() => {\n          // It went well, no wait getMessageFromSlave to get the message\n          // If the message is not coming, getMessageFromSlave will timeout and result of an error\n\n          //\n          // Nothing to do here anymore Mate!\n          //\n        })\n        .catch((err) => {\n          // The getMessageFromSlave will automatically timeout\n          if (!errAlreadyReturned) {\n            errAlreadyReturned = true;\n\n            return reject(err);\n          }\n\n          return false;\n        });\n    });\n  }\n}\n"]}