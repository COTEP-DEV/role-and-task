{"version":3,"sources":["../../../../../src/RoleSystem/Role/RoleMaster/Master1_0.ts"],"names":["instance","Master1_0","name","CONSTANT","DEFAULT_ROLES","MASTER_ROLE","id","pathToEntryFile","tasks","RoleAndTask","getInstance","getRoleTasks","setTaskHandler","TaskHandler","initProperties","communicationSystem","slaves","notConfirmedSlaves","consoleChildObjectPtr","newConnectionListeningFunction","newDisconnectionListeningFunction","cpuUsageAndMemory","tasksInfos","mutexes","func","filter","x","context","push","clientIdentityByte","clientIdentityString","body","regularSlaves","getSlavesOnlyThatAreRegularSlaves","limitToTaskList","forEach","some","y","isActive","includes","sendMessageToSlaveHeadBodyPattern","programIdentifier","PROTOCOL_MASTER_SLAVE","MESSAGES","GENERIC_CHANNEL_DATA","spreadDataToEveryLocalTask","data","sendDataToEveryProgramTaskWhereverItIsLowLevel","err","slave","find","error","somethingChangedAboutSlavesOrI","PromiseCommandPattern","Errors","deserialize","Utils","displayMessage","str","staticIsAnError","getErrorString","String","stack","out","process","stderr","changeProgramState","DEFAULT_STATES","ERROR","tellMasterAboutSlaveError","makesErrorFatal","exitProgramUnproperDueToError","customFunctions","getMasterMutexFunctions","funcTake","funcRelease","TAKE_MUTEX","JSON","stringify","serialize","RELEASE_MUTEX","PROTOCOL_KEYWORDS","HEAD","BODY","SLAVE_CONFIRMATION_INFORMATIONS","OUTPUT_TEXT","INFOS_ABOUT_SLAVES","ERROR_HAPPENED","getCommunicationSystem","listenClientConnectionEvent","split","clientPID","cyan","closeConnectionToClient","sendMessageToClient","listenClientDisconnectionEvent","red","fireUp","confirmSlave","dataJSON","index","findIndex","role","splice","listenToIncomingMessage","dataString","convertStringToJSON","checkFunc","applyFunc","infosAboutSlaveIncomming","errorHappenedIntoSlave","protocolTakeMutex","protocolReleaseMutex","notConfirmedSlave","ptr","moreInfos","Promise","resolve","pid","map","idTaskToConnectTo","idTaskToConnect","args","monoline","blue","getTaskHandler","getTask","task","connection","connectToTask","green","identifierSlave","sendMessageAndWaitForTheResponse","isHeadBodyPattern","messageHeaderToSend","CONNECT_TASK_TO_TASK","messageBodyToSend","idTask","messageHeaderToGet","ret","identifier","status","xi","yi","START_TASK","modifyTaskStatusToSlaveLocalArray","master","getSlave","LIST_TASKS","getSlaveByProgramIdentifier","programState","oldProgramState","all","applyNewProgramState","tellAllSlaveThatProgramStateChanged","SLAVE_ROLE","tellASlaveThatProgramStateChanged","slaveIdentifier","STATE_CHANGE","timeoutToGetMessage","masterMessageWaitingTimeoutStateChange","identifiersSlaves","promiseQueue","functionToCall","sendMessageToSlave","CLOSE","kill","SIGNAL_UNPROPER","SIGUSR1","STOP_TASK","masterMessageWaitingTimeoutStopChange","param","displayTask","displayLog","slaveOpts","specificOpts","connectionTimeout","reject","uniqueSlaveId","generateUniqueProgramID","programOpts","opts","PROGRAM_LAUNCHING_PARAMETERS","MODE","PROGRAM_LAUNCHING_MODE","SLAVE","MODE_OPTIONS","SLAVE_START_ARGS","IDENTIFIER","forkOpts","pathToExec","child","childProcess","fork","timeoutConnection","setTimeout","SIGNAL_TO_KILL_SLAVE_COMMAND","on","code","connectEvent","slaveInfos","clearTimeout","unlistenSlaveConnectionEvent","listenSlaveConnectionEvent","dynamicallyRefreshDataIntoList","confirmedSlaves","getTaskListStatus","communication","ips","givesLocalIps","cpuAndMemory","notifyAboutArchitectureChange","tellOneTaskAboutArchitectureChange","SLAVE_CREATION_CONNECTION_TIMEOUT","startNewSlaveInProcessMode","headString","bodyString","message","timeout","masterMessageWaitingTimeout","timeoutFunction","msgListener","unlistenToIncomingMessage","intervalFdCpuAndMemory","DISPLAY_CPU_MEMORY_CHANGE_TIME","setInterval","getCpuAndMemoryLoad","active","clearInterval","errorHappened","intervalFdTasksInfos","taskHandler","getInfosFromAllActiveTasks","infos","SLAVES_INFOS_CHANGE_TIME","ipServer","ZERO_MQ","DEFAULT_SERVER_IP_ADDRESS","portServer","DEFAULT_SERVER_IP_PORT","ZeroMQServerRouter","start","transport","TRANSPORT","IPC","protocolMasterSlave","infiniteGetCpuAndMemory","infiniteGetTasksInfos","tasksMaster","computeListClosure","sortArray","closureHierarchy","idTaskToRemove","isMasterTask","isSlaveTask","hierarchyLevel","foundHighestInHierarchy","hierarchyY","getHierarchyLevelByIdTask","length","hierarchyX","chooseWhichTaskToStop","stopTask","stopAllTaskOnEverySlaveAndMaster","removeTaskFromSlave","removeExistingSlave","stop","sendMessageGoodFunc","errAlreadyReturned","getMessageFromSlave","then","call","toRet","arr","i","tmp","AMaster"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEA,IAAIA,QAAQ,GAAG,IAAf;AAEA;;;;;;IAKqBC,S;;;;;AACnB,uBAAc;AAAA;;AAAA;AACZ;AAEA,QAAID,QAAJ,EAAc,0DAAOA,QAAP;AAEd,UAAKE,IAAL,GAAYC,qBAASC,aAAT,CAAuBC,WAAvB,CAAmCH,IAA/C;AACA,UAAKI,EAAL,GAAUH,qBAASC,aAAT,CAAuBC,WAAvB,CAAmCC,EAA7C;AAEA,UAAKC,eAAL,GAAuB,KAAvB,CARY,CAUZ;;AACA,QAAMC,KAAK,GAAGC,wBAAYC,WAAZ,GACXC,YADW,CACER,qBAASC,aAAT,CAAuBC,WAAvB,CAAmCC,EADrC,CAAd,CAXY,CAcZ;;;AACA,UAAKM,cAAL,CAAoB,IAAIC,uBAAJ,CAAgBL,KAAhB,CAApB;;AAEA,UAAKM,cAAL;;AAEAd,IAAAA,QAAQ,iDAAR;AAEA,8DAAOA,QAAP;AACD;AAED;;;;;;;qCAGiB;AACf;AACA,WAAKe,mBAAL,GAA2B,KAA3B,CAFe,CAIf;;AACA,WAAKC,MAAL,GAAc,EAAd,CALe,CAOf;;AACA,WAAKC,kBAAL,GAA0B,EAA1B,CARe,CAUf;AACA;;AACA,WAAKC,qBAAL,GAA6B,EAA7B,CAZe,CAcf;;AACA,WAAKC,8BAAL,GAAsC,EAAtC;AACA,WAAKC,iCAAL,GAAyC,EAAzC,CAhBe,CAkBf;;AACA,WAAKC,iBAAL,GAAyB,KAAzB;AACA,WAAKC,UAAL,GAAkB,KAAlB,CApBe,CAsBf;;AACA,WAAKC,OAAL,GAAe,EAAf;AACD;AAED;;;;;;6CAGyB;AACvB,aAAO,KAAKR,mBAAZ;AACD;AAED;;;;;;;;AAQA;;;iDAG6BS,I,EAAM;AACjC,WAAKL,8BAAL,GAAsC,KAAKA,8BAAL,CAAoCM,MAApC,CAA2C,UAAAC,CAAC;AAAA,eAAIA,CAAC,CAACF,IAAF,KAAWA,IAAf;AAAA,OAA5C,CAAtC;AACD;AAED;;;;;;oDAGgCA,I,EAAM;AACpC,WAAKJ,iCAAL,GAAyC,KAAKA,iCAAL,CAAuCK,MAAvC,CAA8C,UAAAC,CAAC;AAAA,eAAIA,CAAC,CAACF,IAAF,KAAWA,IAAf;AAAA,OAA/C,CAAzC;AACD;AAED;;;;;;+CAG2BA,I,EAAMG,O,EAAS;AACxC,WAAKR,8BAAL,CAAoCS,IAApC,CAAyC;AACvCJ,QAAAA,IAAI,EAAJA,IADuC;AAEvCG,QAAAA,OAAO,EAAPA;AAFuC,OAAzC;AAID;AAED;;;;;;kDAG8BH,I,EAAM;AAClC,WAAKJ,iCAAL,CAAuCQ,IAAvC,CAA4C;AAC1CJ,QAAAA,IAAI,EAAJA,IAD0C;AAE1CG,QAAAA,OAAO,EAAPA;AAF0C,OAA5C;AAID;AAED;;;;;;4CAGwB;AACtB,aAAO,KAAKV,kBAAZ;AACD;AAED;;;;;;gCAGY;AACV,aAAO,KAAKD,MAAZ;AACD;AAED;;;;;;;;;;;;mEAS+Ca,kB,EAAoBC,oB,EAAsBC,I,EAAM;AAAA;;AAC7F,UAAMC,aAAa,GAAG,KAAKC,iCAAL,EAAtB,CAD6F,CAG7F;;AAH6F,UAK3FC,eAL2F,GAMzFH,IANyF,CAK3FG,eAL2F,EAS7F;;AACAF,MAAAA,aAAa,CAACG,OAAd,CAAsB,UAACT,CAAD,EAAO;AAC3B;AACA,YAAI,CAACQ,eAAD,IAAoBR,CAAC,CAAClB,KAAF,CAAQ4B,IAAR,CAAa,UAAAC,CAAC;AAAA,iBAAIA,CAAC,CAACC,QAAF,IAAcJ,eAAe,CAACK,QAAhB,CAAyBF,CAAC,CAAC/B,EAA3B,CAAlB;AAAA,SAAd,CAAxB,EAAyF;AACvF;AACA,UAAA,MAAI,CAACkC,iCAAL,CAAuCd,CAAC,CAACe,iBAAzC,EAA4DtC,qBAASuC,qBAAT,CAA+BC,QAA/B,CAAwCC,oBAApG,EAA0Hb,IAA1H;AACD;AACF,OAND,EAV6F,CAkB7F;;AACAtB,8BAAYC,WAAZ,GACGmC,0BADH,CAC8Bd,IAD9B;AAED;AAED;;;;;;2DAGuCe,I,EAAM;AAC3C,WAAKC,8CAAL,CAAoD,KAApD,EAA2D,KAA3D,EAAkED,IAAlE;AACD;AAED;;;;;;8CAG0BhB,oB,EAAsBkB,G,EAAK;AACnD,UAAMC,KAAK,GAAG,KAAKjC,MAAL,CAAYkC,IAAZ,CAAiB,UAAAxB,CAAC;AAAA,eAAIA,CAAC,CAACI,oBAAF,KAA2BA,oBAA/B;AAAA,OAAlB,CAAd;AAEA,UAAI,CAACmB,KAAL,EAAY;AAEZA,MAAAA,KAAK,CAACE,KAAN,GAAcH,GAAd;AACA,WAAKI,8BAAL;AACD;AAED;;;;;;;;;2CAMuBvB,kB,EAAoBC,oB,EAAsBC,I,EAAM;AAAA;;AACrE,aAAO,IAAIsB,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AACEwB,oBAAAA,GADF,GACQM,mBAAOC,WAAP,CAAmBxB,IAAnB,CADR,EAGJ;;AACAyB,sCAAMC,cAAN,CAAqB;AACnBC,sBAAAA,GAAG,EAAEJ,mBAAOK,eAAP,CAAuBX,GAAvB,IAA8BA,GAAG,CAACY,cAAJ,EAA9B,GAAqDC,MAAM,CAACb,GAAG,CAACc,KAAJ,IAAad,GAAd,CAD7C;AAEnBe,sBAAAA,GAAG,EAAEC,OAAO,CAACC;AAFM,qBAArB;;AAJI;AAAA;AAAA,2BAYIxD,wBAAYC,WAAZ,GACHwD,kBADG,CACgB/D,qBAASgE,cAAT,CAAwBC,KAAxB,CAA8B9D,EAD9C,CAZJ;;AAAA;AAeF;AACA;AAEAkD,sCAAMC,cAAN,CAAqB;AACnBC,sBAAAA,GAAG,EAAEJ,mBAAOK,eAAP,CAAuBX,GAAvB,IAA8BA,GAAG,CAACY,cAAJ,EAA9B,GAAqDC,MAAM,CAACb,GAAG,CAACc,KAAJ,IAAad,GAAd,CAD7C;AAEnBe,sBAAAA,GAAG,EAAEC,OAAO,CAACC;AAFM,qBAArB,EAlBE,CAuBF;;;AACA,oBAAA,MAAI,CAACI,yBAAL,CAA+BvC,oBAA/B,EAAqDkB,GAArD,EAxBE,CA0BF;;;AACA,wBAAIvC,wBAAYC,WAAZ,GACD4D,eADH,EACoB;AAClB7D,8CAAY8D,6BAAZ;AACD,qBA9BC,CA+BF;;;AA/BE;AAAA;;AAAA;AAAA;AAAA;;AAiCFf,sCAAMC,cAAN,CAAqB;AACnBC,sBAAAA,GAAG,EAAE,+CADc;AAEnBK,sBAAAA,GAAG,EAAEC,OAAO,CAACC;AAFM,qBAArB;;AAKAT,sCAAMC,cAAN,CAAqB;AACnBC,sBAAAA,GAAG,EAAEG,MAAM,CAAE,eAAa,YAAUC,KAAxB,eAAD,CADQ;AAEnBC,sBAAAA,GAAG,EAAEC,OAAO,CAACC;AAFM,qBAArB;;AAKAxD,4CAAY8D,6BAAZ;;AA3CE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAgDD;AAED;;;;;;8BAGUjE,E,EAAI;AAAA;;AACZ,aAAO,IAAI+C,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAEA,MAAI,CAACD,OAAL,CAAajB,EAAb,CAFA;AAAA;AAAA;AAAA;;AAAA,0BAGI,IAAIgD,kBAAJ,CAAW,OAAX,CAHJ;;AAAA;AAMJ;AACA;AACMkB,oBAAAA,eARF,GAQoB/D,wBAAYC,WAAZ,GACrB+D,uBADqB,GAErBvB,IAFqB,CAEhB,UAAAxB,CAAC;AAAA,6BAAIA,CAAC,CAACpB,EAAF,KAASA,EAAb;AAAA,qBAFe,CARpB;;AAAA,0BAYAkE,eAAe,IAAIA,eAAe,CAACE,QAZnC;AAAA;AAAA;AAAA;;AAAA;AAAA,2BAaIF,eAAe,CAACE,QAAhB,EAbJ;;AAAA;AAgBJ,oBAAA,MAAI,CAACnD,OAAL,CAAajB,EAAb,IAAmB,IAAnB;;AAhBI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAoBD;AAED;;;;;;iCAGaA,E,EAAI;AAAA;;AACf,aAAO,IAAI+C,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AACJ;AACA;AACMgD,oBAAAA,eAHF,GAGoB/D,wBAAYC,WAAZ,GACrB+D,uBADqB,GAErBvB,IAFqB,CAEhB,UAAAxB,CAAC;AAAA,6BAAIA,CAAC,CAACpB,EAAF,KAASA,EAAb;AAAA,qBAFe,CAHpB;;AAAA,0BAOAkE,eAAe,IAAIA,eAAe,CAACG,WAPnC;AAAA;AAAA;AAAA;;AAAA;AAAA,2BAQIH,eAAe,CAACG,WAAhB,EARJ;;AAAA;AAWJ,oBAAA,MAAI,CAACpD,OAAL,CAAajB,EAAb,IAAmB,KAAnB;;AAXI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAeD;AAED;;;;;;sCAGkBuB,kB,EAAoBC,oB,EAAsBC,I,EAAM;AAAA;;AAChE,aAAO,IAAIsB,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAEFoD,oBAAAA,UAFE,GAGAzE,qBAASuC,qBAAT,CAA+BC,QAH/B,CAEFiC,UAFE,EAKJ;;AACM3B,oBAAAA,KANF,GAMU,MAAI,CAACjC,MAAL,CAAYkC,IAAZ,CAAiB,UAAAxB,CAAC;AAAA,6BAAIA,CAAC,CAACI,oBAAF,KAA2BA,oBAA/B;AAAA,qBAAlB,CANV;AAAA;;AAAA,yBAUE,MAAI,CAACP,OAAL,CAAaQ,IAAI,CAACzB,EAAlB,CAVF;AAAA;AAAA;AAAA;;AAAA,0BAWM,IAAIgD,kBAAJ,CAAW,OAAX,CAXN;;AAAA;AAcF;AACA;AACMkB,oBAAAA,eAhBJ,GAgBsB/D,wBAAYC,WAAZ,GACrB+D,uBADqB,GAErBvB,IAFqB,CAEhB,UAAAxB,CAAC;AAAA,6BAAIA,CAAC,CAACpB,EAAF,KAASyB,IAAI,CAACzB,EAAlB;AAAA,qBAFe,CAhBtB;;AAAA,0BAoBEkE,eAAe,IAAIA,eAAe,CAACE,QApBrC;AAAA;AAAA;AAAA;;AAAA;AAAA,2BAqBMF,eAAe,CAACE,QAAhB,EArBN;;AAAA;AAwBF,oBAAA,MAAI,CAACnD,OAAL,CAAaQ,IAAI,CAACzB,EAAlB,IAAwB,IAAxB;;AAEA,oBAAA,MAAI,CAACkC,iCAAL,CAAuCS,KAAK,CAACR,iBAA7C,EAAgEmC,UAAhE,EAA4EC,IAAI,CAACC,SAAL,CAAe;AACzF3B,sBAAAA,KAAK,EAAE;AADkF,qBAAf,CAA5E;;AA1BE;AAAA;;AAAA;AAAA;AAAA;;AA8BF,oBAAA,MAAI,CAACX,iCAAL,CAAuCS,KAAK,CAACR,iBAA7C,EAAgEmC,UAAhE,EAA4EC,IAAI,CAACC,SAAL,CAAe;AACzF3B,sBAAAA,KAAK,EAAE,aAAI4B,SAAJ;AADkF,qBAAf,CAA5E;;AA9BE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAqCD;AAED;;;;;;yCAGqBlD,kB,EAAoBC,oB,EAAsBC,I,EAAM;AAAA;;AACnE,aAAO,IAAIsB,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAEFwD,oBAAAA,aAFE,GAGA7E,qBAASuC,qBAAT,CAA+BC,QAH/B,CAEFqC,aAFE,EAKJ;;AACM/B,oBAAAA,KANF,GAMU,MAAI,CAACjC,MAAL,CAAYkC,IAAZ,CAAiB,UAAAxB,CAAC;AAAA,6BAAIA,CAAC,CAACI,oBAAF,KAA2BA,oBAA/B;AAAA,qBAAlB,CANV;AAAA;AASF;AACA;AACM0C,oBAAAA,eAXJ,GAWsB/D,wBAAYC,WAAZ,GACrB+D,uBADqB,GAErBvB,IAFqB,CAEhB,UAAAxB,CAAC;AAAA,6BAAIA,CAAC,CAACpB,EAAF,KAASyB,IAAI,CAACzB,EAAlB;AAAA,qBAFe,CAXtB;;AAAA,0BAeEkE,eAAe,IAAIA,eAAe,CAACG,WAfrC;AAAA;AAAA;AAAA;;AAAA;AAAA,2BAgBMH,eAAe,CAACG,WAAhB,EAhBN;;AAAA;AAmBF,oBAAA,MAAI,CAACpD,OAAL,CAAaQ,IAAI,CAACzB,EAAlB,IAAwB,KAAxB;;AAEA,oBAAA,MAAI,CAACkC,iCAAL,CAAuCS,KAAK,CAACR,iBAA7C,EAAgEuC,aAAhE,EAA+EH,IAAI,CAACC,SAAL,CAAe;AAC5F3B,sBAAAA,KAAK,EAAE;AADqF,qBAAf,CAA/E;;AArBE;AAAA;;AAAA;AAAA;AAAA;;AAyBF,oBAAA,MAAI,CAACX,iCAAL,CAAuCS,KAAK,CAACR,iBAA7C,EAAgEuC,aAAhE,EAA+EH,IAAI,CAACC,SAAL,CAAe;AAC5F3B,sBAAAA,KAAK,EAAE,aAAI4B,SAAJ;AADqF,qBAAf,CAA/E;;AAzBE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAgCD;AAED;;;;;;;0CAIsB;AAAA;;AACpB;AADoB,kCAKhB5E,qBAAS8E,iBALO;AAAA,UAGlBC,IAHkB,yBAGlBA,IAHkB;AAAA,UAIlBC,IAJkB,yBAIlBA,IAJkB;AAAA,kCAehBhF,qBAASuC,qBAAT,CAA+BC,QAff;AAAA,UAQlByC,+BARkB,yBAQlBA,+BARkB;AAAA,UASlBxC,oBATkB,yBASlBA,oBATkB;AAAA,UAUlByC,WAVkB,yBAUlBA,WAVkB;AAAA,UAWlBC,kBAXkB,yBAWlBA,kBAXkB;AAAA,UAYlBC,cAZkB,yBAYlBA,cAZkB;AAAA,UAalBX,UAbkB,yBAalBA,UAbkB;AAAA,UAclBI,aAdkB,yBAclBA,aAdkB,EAiBpB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAKQ,sBAAL,GACGC,2BADH,CAC+B,UAAC5D,kBAAD,EAAqBC,oBAArB,EAA8C;AAAA,oCAIrEA,oBAAoB,CAAC4D,KAArB,CAA2B,GAA3B,CAJqE;AAAA;AAAA,YAEvEjD,iBAFuE;AAAA,YAGvEkD,SAHuE,8BAMzE;;;AACA,YAAI,MAAI,CAAC3E,MAAL,CAAYkC,IAAZ,CAAiB,UAAAxB,CAAC;AAAA,iBAAIA,CAAC,CAACe,iBAAF,KAAwBA,iBAA5B;AAAA,SAAlB,KACF,MAAI,CAACxB,kBAAL,CAAwBiC,IAAxB,CAA6B,UAAAxB,CAAC;AAAA,iBAAIA,CAAC,CAACe,iBAAF,KAAwBA,iBAA5B;AAAA,SAA9B,CADF,EACgF;AAC9E;AACA;AACAhC,kCAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,YAAAA,GAAG,EAAE,WAAI,MAAI,CAACxD,IAAT,sCAAgD0F;AADvC,WADlB;;AAKA,iBAAO,MAAI,CAACJ,sBAAL,GACJK,uBADI,CACoBhE,kBADpB,EACwCC,oBADxC,CAAP;AAED,SAlBwE,CAoBzE;AAEA;;;AACA,QAAA,MAAI,CAACb,kBAAL,CAAwBW,IAAxB,CAA6B;AAC3BE,UAAAA,oBAAoB,EAApBA,oBAD2B;AAE3BD,UAAAA,kBAAkB,EAAlBA,kBAF2B;AAG3BY,UAAAA,iBAAiB,EAAjBA,iBAH2B;AAI3BkD,UAAAA,SAAS,EAATA,SAJ2B;AAK3BnF,UAAAA,KAAK,EAAE,EALoB;AAM3B2C,UAAAA,KAAK,EAAE;AANoB,SAA7B,EAvByE,CAgCzE;;;AACA,eAAO,MAAI,CAACqC,sBAAL,GACJM,mBADI,CACgBjE,kBADhB,EACoCC,oBADpC,EAC0DsD,+BAD1D,CAAP;AAED,OApCH,EAxBoB,CA8DpB;;AACA,WAAKI,sBAAL,GACGO,8BADH,CACkC,UAACjE,oBAAD,EAA0B;AACxD,QAAA,MAAI,CAACd,MAAL,GAAc,MAAI,CAACA,MAAL,CAAYS,MAAZ,CAAmB,UAACC,CAAD,EAAO;AACtC,cAAIA,CAAC,CAACI,oBAAF,KAA2BA,oBAA/B,EAAqD;AACnDrB,oCAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,cAAAA,GAAG,EAAE,WAAI,MAAI,CAACxD,IAAT,sCAAgD8F;AADvC,aADlB,EADmD,CAMnD;;;AACAxC,8BAAMyC,MAAN,CAAa,MAAI,CAAC7E,iCAAlB,EAAqD,CAACM,CAAD,CAArD;;AAEA,mBAAO,KAAP;AACD;;AAED,iBAAO,IAAP;AACD,SAda,CAAd;AAgBA,QAAA,MAAI,CAACT,kBAAL,GAA0B,MAAI,CAACA,kBAAL,CAAwBQ,MAAxB,CAA+B,UAACC,CAAD,EAAO;AAC9D,cAAIA,CAAC,CAACI,oBAAF,KAA2BA,oBAA/B,EAAqD;AACnDrB,oCAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,cAAAA,GAAG,EAAE,WAAI,MAAI,CAACxD,IAAT,oDAA8D8F;AADrD,aADlB,EADmD,CAMnD;;;AACAxC,8BAAMyC,MAAN,CAAa,MAAI,CAAC7E,iCAAlB,EAAqD,CAACM,CAAD,CAArD;;AAEA,mBAAO,KAAP;AACD;;AAED,iBAAO,IAAP;AACD,SAdyB,CAA1B;AAeD,OAjCH,EA/DoB,CAkGpB;;AACA,UAAMwE,YAAY,GAAG,SAAfA,YAAe,CAACrE,kBAAD,EAAqBC,oBAArB,EAA2CqE,QAA3C,EAAwD;AAC3E,YAAMC,KAAK,GAAG,MAAI,CAACnF,kBAAL,CAAwBoF,SAAxB,CAAkC,UAAA3E,CAAC;AAAA,iBAAIA,CAAC,CAACI,oBAAF,KAA2BA,oBAA/B;AAAA,SAAnC,CAAd;;AAEA,YAAIsE,KAAK,KAAK,CAAC,CAAf,EAAkB,OAHyD,CAK3E;;AACA,YAAMnD,KAAK,GAAG,MAAI,CAAChC,kBAAL,CAAwBmF,KAAxB,CAAd;AAEAnD,QAAAA,KAAK,CAACzC,KAAN,GAAc2F,QAAQ,CAAChB,IAAD,CAAR,CAAe3E,KAA7B;AACAyC,QAAAA,KAAK,CAACqD,IAAN,GAAaH,QAAQ,CAAChB,IAAD,CAAR,CAAemB,IAA5B;;AAEA,QAAA,MAAI,CAACtF,MAAL,CAAYY,IAAZ,CAAiBqB,KAAjB;;AAEA,QAAA,MAAI,CAAChC,kBAAL,CAAwBsF,MAAxB,CAA+BH,KAA/B,EAAsC,CAAtC,EAb2E,CAe3E;;;AACA5C,0BAAMyC,MAAN,CAAa,MAAI,CAAC9E,8BAAlB,EAAkD,CAAC8B,KAAD,CAAlD;AACD,OAjBD,CAnGoB,CAsHpB;;;AACA,WAAKuC,sBAAL,GACGgB,uBADH,CAC2B,UAAC3E,kBAAD,EAAqBC,oBAArB,EAA2C2E,UAA3C,EAA0D;AACjF,YAAMN,QAAQ,GAAG3C,kBAAMkD,mBAAN,CAA0BD,UAA1B,CAAjB,CADiF,CAGjF;AACA;AACA;;;AACA,SAAC;AACC;AACA;AACA;AACAE,UAAAA,SAAS,EAAE;AAAA,mBAAOR,QAAQ,IAAIA,QAAQ,CAACjB,IAAD,CAApB,IAA8BiB,QAAQ,CAACjB,IAAD,CAAR,KAAmBE,+BAAxD;AAAA,WAJZ;AAKC;AACAwB,UAAAA,SAAS,EAAE;AAAA,mBAAMV,YAAY,CAACrE,kBAAD,EAAqBC,oBAArB,EAA2CqE,QAA3C,CAAlB;AAAA;AANZ,SAAD,EAOG;AACD;AACA;AACA;AACAQ,UAAAA,SAAS,EAAE;AAAA,mBAAOR,QAAQ,IAAIA,QAAQ,CAACjB,IAAD,CAApB,IAA8BiB,QAAQ,CAACjB,IAAD,CAAR,KAAmBtC,oBAAxD;AAAA,WAJV;AAKDgE,UAAAA,SAAS,EAAE;AAAA,mBAAM,MAAI,CAAC7D,8CAAL,CAAoDlB,kBAApD,EAAwEC,oBAAxE,EAA8FqE,QAAQ,CAAChB,IAAD,CAAtG,CAAN;AAAA;AALV,SAPH,EAaG;AACD;AACA;AACA;AACAwB,UAAAA,SAAS,EAAE;AAAA,mBAAOR,QAAQ,IAAIA,QAAQ,CAACjB,IAAD,CAApB,IAA8BiB,QAAQ,CAACjB,IAAD,CAAR,KAAmBG,WAAxD;AAAA,WAJV;AAKDuB,UAAAA,SAAS,EAAE;AAAA,mBAAM,MAAI,CAACnD,cAAL,CAAoB0C,QAAQ,CAAChB,IAAD,CAA5B,CAAN;AAAA;AALV,SAbH,EAmBG;AACD;AACA;AACA;AACAwB,UAAAA,SAAS,EAAE;AAAA,mBAAOR,QAAQ,IAAIA,QAAQ,CAACjB,IAAD,CAApB,IAA8BiB,QAAQ,CAACjB,IAAD,CAAR,KAAmBI,kBAAxD;AAAA,WAJV;AAKDsB,UAAAA,SAAS,EAAE;AAAA,mBAAM,MAAI,CAACC,wBAAL,CAA8BhF,kBAA9B,EAAkDC,oBAAlD,EAAwEqE,QAAQ,CAAChB,IAAD,CAAhF,CAAN;AAAA;AALV,SAnBH,EAyBG;AACD;AACA;AACA;AACAwB,UAAAA,SAAS,EAAE;AAAA,mBAAOR,QAAQ,IAAIA,QAAQ,CAACjB,IAAD,CAApB,IAA8BiB,QAAQ,CAACjB,IAAD,CAAR,KAAmBK,cAAxD;AAAA,WAJV;AAKDqB,UAAAA,SAAS,EAAE;AAAA,mBAAM,MAAI,CAACE,sBAAL,CAA4BjF,kBAA5B,EAAgDC,oBAAhD,EAAsEqE,QAAQ,CAAChB,IAAD,CAA9E,CAAN;AAAA;AALV,SAzBH,EA+BG;AACD;AACA;AACA;AACAwB,UAAAA,SAAS,EAAE;AAAA,mBAAOR,QAAQ,IAAIA,QAAQ,CAACjB,IAAD,CAApB,IAA8BiB,QAAQ,CAACjB,IAAD,CAAR,KAAmBN,UAAxD;AAAA,WAJV;AAKDgC,UAAAA,SAAS,EAAE;AAAA,mBAAM,MAAI,CAACG,iBAAL,CAAuBlF,kBAAvB,EAA2CC,oBAA3C,EAAiEqE,QAAQ,CAAChB,IAAD,CAAzE,CAAN;AAAA;AALV,SA/BH,EAqCG;AACD;AACA;AACA;AACAwB,UAAAA,SAAS,EAAE;AAAA,mBAAOR,QAAQ,IAAIA,QAAQ,CAACjB,IAAD,CAApB,IAA8BiB,QAAQ,CAACjB,IAAD,CAAR,KAAmBF,aAAxD;AAAA,WAJV;AAKD4B,UAAAA,SAAS,EAAE;AAAA,mBAAM,MAAI,CAACI,oBAAL,CAA0BnF,kBAA1B,EAA8CC,oBAA9C,EAAoEqE,QAAQ,CAAChB,IAAD,CAA5E,CAAN;AAAA;AALV,SArCH,EA2CGhD,OA3CH,CA2CW,UAACT,CAAD,EAAO;AAChB,cAAIA,CAAC,CAACiF,SAAF,EAAJ,EAAmBjF,CAAC,CAACkF,SAAF;AACpB,SA7CD;AA8CD,OArDH;AAsDD;AAED;;;;;;;;;;6CAOyB/E,kB,EAAoBC,oB,EAAsBgB,I,EAAM;AACvE;AACA,UAAMG,KAAK,GAAG,KAAKjC,MAAL,CAAYkC,IAAZ,CAAiB,UAAAxB,CAAC;AAAA,eAAIA,CAAC,CAACI,oBAAF,KAA2BA,oBAA/B;AAAA,OAAlB,CAAd;AACA,UAAMmF,iBAAiB,GAAG,KAAKhG,kBAAL,CAAwBiC,IAAxB,CAA6B,UAAAxB,CAAC;AAAA,eAAIA,CAAC,CAACI,oBAAF,KAA2BA,oBAA/B;AAAA,OAA9B,CAA1B;AAEA,UAAMoF,GAAG,GAAGjE,KAAK,IAAIgE,iBAArB;AAEA,UAAI,CAACC,GAAL,EAAU;AAEV,UAAI,CAACA,GAAG,CAACC,SAAT,EAAoBD,GAAG,CAACC,SAAJ,GAAgB,EAAhB,CATmD,CAWvE;;AACA,OACE,cADF,EAEE,KAFF,EAGE,YAHF,EAKChF,OALD,CAKS,UAACT,CAAD,EAAO;AACd;AACA,YAAIoB,IAAI,CAACpB,CAAD,CAAJ,KAAY,KAAK,CAArB,EAAwBwF,GAAG,CAACC,SAAJ,CAAczF,CAAd,IAAmBoB,IAAI,CAACpB,CAAD,CAAvB;AACzB,OARD,EAZuE,CAsBvE;;AACA,WAAK0B,8BAAL;AACD;AAED;;;;;;wCAGoB;AAAA;;AAClB,aAAO,IAAIC,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI,EAAE;AAAA,iBAAM,IAAI4F,OAAJ,CAAY,UAACC,OAAD,EAAa;AACnCA,YAAAA,OAAO,EACLxD,MAAM,CAACG,OAAO,CAACsD,GAAT,CADD,6CAEF,MAAI,CAACtG,MAAL,CAAYuG,GAAZ,CAAgB,UAAA7F,CAAC;AAAA,qBAAImC,MAAM,CAACnC,CAAC,CAACiE,SAAH,CAAV;AAAA,aAAjB,CAFE,GAAP;AAID,WALW,CAAN;AAAA;AADyB,OAA1B,CAAP;AAQD;AAED;;;;;;;;;wCAMoB6B,iB,EAAmBC,e,EAAiBC,I,EAAM;AAAA;;AAC5D,aAAO,IAAIrE,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEFf,4CAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,sBAAAA,GAAG,EAAEF,kBAAMmE,QAAN,CAAe,YACZ,OAAI,CAACzH,IADO,mDACmCuH,eADnC,+BAEED,iBAFF,EAAf,EAIFI;AALW,qBADlB;;AAFE;AAAA,2BAWiB,OAAI,CAACC,cAAL,GAChBC,OADgB,CACRN,iBADQ,CAXjB;;AAAA;AAWIO,oBAAAA,IAXJ;;AAAA,wBAgBGA,IAAI,CAACzF,QAAL,EAhBH;AAAA;AAAA;AAAA;;AAAA,0BAiBM,IAAIgB,kBAAJ,CAAW,OAAX,oBAA+BkE,iBAA/B,EAjBN;;AAAA;AAoBF;AACMQ,oBAAAA,UArBJ,GAqBiBD,IAAI,CAACE,aAAL,CAAmBR,eAAnB,EAAoCC,IAApC,CArBjB;;AAuBFjH,4CAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,sBAAAA,GAAG,EAAEF,kBAAMmE,QAAN,CAAe,YACZ,OAAI,CAACzH,IADO,yBACSuH,eADT,mDAEXD,iBAFW,gBAAf,EAIFU;AALW,qBADlB;;AAvBE,sDAgCKF,UAhCL;;AAAA;AAAA;AAAA;;AAkCFvH,4CAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,sBAAAA,GAAG,EAAEF,kBAAMmE,QAAN,CAAe,YACZ,OAAI,CAACzH,IADO,yBACSuH,eADT,sDAEFD,iBAFE,gBAAf,EAIFxB;AALW,qBADlB;;AAlCE;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAgDD;AAED;;;;;;;;;;sCAOkBmC,e,EAAiBX,iB,EAAmBC,e,EAAiBC,I,EAAM;AAAA;;AAC3E,aAAO,IAAIrE,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BACc,OAAI,CAAC4G,gCAAL,CAAsC;AACtDD,sBAAAA,eAAe,EAAfA,eADsD;AAEtDE,sBAAAA,iBAAiB,EAAE,IAFmC;AAGtDC,sBAAAA,mBAAmB,EAAEnI,qBAASuC,qBAAT,CAA+BC,QAA/B,CAAwC4F,oBAHP;AAKtDC,sBAAAA,iBAAiB,EAAE;AACjBC,wBAAAA,MAAM,EAAEjB,iBADS;AAEjBC,wBAAAA,eAAe,EAAfA,eAFiB;AAGjBC,wBAAAA,IAAI,EAAJA;AAHiB,uBALmC;AAWtDgB,sBAAAA,kBAAkB,EAAEvI,qBAASuC,qBAAT,CAA+BC,QAA/B,CAAwC4F;AAXN,qBAAtC,CADd;;AAAA;AACEI,oBAAAA,GADF;;AAAA,0BAgBAA,GAAG,KAAK,EAhBR;AAAA;AAAA;AAAA;;AAAA,sDAgBmBA,GAhBnB;;AAAA;AAAA,0BAkBEA,GAlBF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAsBD;AAED;;;;;;;;;;sDAOkCC,U,EAAYH,M,EAAQI,M,EAAQ;AAAA;;AAC5D,WAAK7H,MAAL,CAAYoB,IAAZ,CAAiB,UAACV,CAAD,EAAIoH,EAAJ,EAAW;AAC1B,YAAIpH,CAAC,CAACe,iBAAF,KAAwBmG,UAA5B,EAAwC;AACtC,iBAAOlH,CAAC,CAAClB,KAAF,CAAQ4B,IAAR,CAAa,UAACC,CAAD,EAAI0G,EAAJ,EAAW;AAC7B,gBAAI1G,CAAC,CAAC/B,EAAF,KAASmI,MAAb,EAAqB;AACnB,cAAA,OAAI,CAACzH,MAAL,CAAY8H,EAAZ,EAAgBtI,KAAhB,CAAsBuI,EAAtB,EAA0BzG,QAA1B,GAAqCuG,MAArC;AAEA,qBAAO,IAAP;AACD;;AAED,mBAAO,KAAP;AACD,WARM,CAAP;AASD;;AAED,eAAO,KAAP;AACD,OAdD;AAeD;AAED;;;;;;;;qCAKiBD,U,EAAYH,M,EAAmB;AAAA;;AAAA,UAAXf,IAAW,uEAAJ,EAAI;AAC9C,aAAO,IAAIrE,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BACc,OAAI,CAAC4G,gCAAL,CAAsC;AACtDD,sBAAAA,eAAe,EAAES,UADqC;AAEtDP,sBAAAA,iBAAiB,EAAE,IAFmC;AAGtDC,sBAAAA,mBAAmB,EAAEnI,qBAASuC,qBAAT,CAA+BC,QAA/B,CAAwCqG,UAHP;AAKtDR,sBAAAA,iBAAiB,EAAE;AACjBC,wBAAAA,MAAM,EAANA,MADiB;AAEjBf,wBAAAA,IAAI,EAAJA;AAFiB,uBALmC;AAUtDgB,sBAAAA,kBAAkB,EAAEvI,qBAASuC,qBAAT,CAA+BC,QAA/B,CAAwCqG;AAVN,qBAAtC,CADd;;AAAA;AACEL,oBAAAA,GADF;;AAAA,0BAeAA,GAAG,KAAK,EAfR;AAAA;AAAA;AAAA;;AAgBF;AACA,oBAAA,OAAI,CAACM,iCAAL,CAAuCL,UAAvC,EAAmDH,MAAnD,EAA2D,IAA3D,EAjBE,CAmBF;;;AACA,oBAAA,OAAI,CAACrF,8BAAL;;AApBE,sDAsBKuF,GAtBL;;AAAA;AAAA,0BAyBErF,mBAAOC,WAAP,CAAmBoF,GAAnB,CAzBF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AA6BD;AAED;;;;;;iCAGa;AAAA;;AACX,aAAO,IAAItF,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI,EAAE;AAAA,iBAAM,OAAI,CAAC0H,MAAL,CAAYC,QAAZ,EAAN;AAAA;AADyB,OAA1B,CAAP;AAGD;AAED;;;;;;;yCAIqBP,U,EAAY;AAAA;;AAC/B,aAAO,IAAIvF,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI,EAAE;AAAA,iBAAM,OAAI,CAAC4G,gCAAL,CAAsC;AAChDD,YAAAA,eAAe,EAAES,UAD+B;AAEhDP,YAAAA,iBAAiB,EAAE,KAF6B;AAGhDC,YAAAA,mBAAmB,EAAEnI,qBAASuC,qBAAT,CAA+BC,QAA/B,CAAwCyG,UAHb;AAIhDZ,YAAAA,iBAAiB,EAAE,EAJ6B;AAKhDE,YAAAA,kBAAkB,EAAEvI,qBAASuC,qBAAT,CAA+BC,QAA/B,CAAwCyG;AALZ,WAAtC,CAAN;AAAA;AADyB,OAA1B,CAAP;AASD;AAED;;;;;;;kCAIcR,U,EAAY;AAAA;;AACxB,aAAO,IAAIvF,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AACJ;AACMyB,oBAAAA,KAFF,GAEU,OAAI,CAACoG,2BAAL,CAAiCT,UAAjC,CAFV;AAAA,sDAIG3F,KAAK,CAACzC,KAJT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAQD;AAED;;;;;;;;;6CAMyB8I,Y,EAAcC,e,EAAiB;AAAA;;AACtD,aAAO,IAAIlG,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI,EAAE;AAAA,iBAAM4F,OAAO,CAACoC,GAAR,CAAY,CACtB;AACA,UAAA,OAAI,CAAC3B,cAAL,GACC4B,oBADD,CACsBH,YADtB,EACoCC,eADpC,CAFsB,EAKtB;AACA,UAAA,OAAI,CAACG,mCAAL,CAAyCJ,YAAzC,EAAuDC,eAAvD,CANsB,CAQtB;AARsB,WAAZ,CAAN;AAAA;AADyB,OAA1B,CAAP;AAYD;AAED;;;;;;wDAGoC;AAClC,aAAO,KAAKvI,MAAL,CAAYS,MAAZ,CAAmB,UAAAC,CAAC;AAAA,eAAIA,CAAC,CAAC4E,IAAF,CAAOhG,EAAP,KAAcH,qBAASC,aAAT,CAAuBuJ,UAAvB,CAAkCrJ,EAApD;AAAA,OAApB,CAAP;AACD;AAED;;;;;;;;;;;wDAQoCgJ,Y,EAAcC,e,EAAiB;AAAA;;AACjE,aAAO,IAAIlG,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AACEQ,oBAAAA,aADF,GACkB,OAAI,CAACC,iCAAL,EADlB;AAAA,uDAGGmF,OAAO,CAACoC,GAAR,CAAYxH,aAAa,CAACuF,GAAd,CAAkB,UAAA7F,CAAC;AAAA,6BAAI,OAAI,CAACkI,iCAAL,CAAuClI,CAAC,CAACe,iBAAzC,EAA4D6G,YAA5D,EAA0EC,eAA1E,CAAJ;AAAA,qBAAnB,CAAZ,CAHH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAOD;AAED;;;;;;;;;sDAMkCM,e,EAAiBP,Y,EAAcC,e,EAAiB;AAAA;;AAChF,aAAO,IAAIlG,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAEFsI,oBAAAA,YAFE,GAGA3J,qBAASuC,qBAAT,CAA+BC,QAH/B,CAEFmH,YAFE;AAAA;AAAA,2BAKc,OAAI,CAAC1B,gCAAL,CAAsC;AACtDD,sBAAAA,eAAe,EAAE0B,eADqC;AAEtDxB,sBAAAA,iBAAiB,EAAE,IAFmC;AAGtDC,sBAAAA,mBAAmB,EAAEwB,YAHiC;AAKtDtB,sBAAAA,iBAAiB,EAAE;AACjBc,wBAAAA,YAAY,EAAZA,YADiB;AAEjBC,wBAAAA,eAAe,EAAfA;AAFiB,uBALmC;AAUtDb,sBAAAA,kBAAkB,EAAEoB,YAVkC;AAWtDC,sBAAAA,mBAAmB,EAAEtJ,wBAAYC,WAAZ,GAClBsJ;AAZmD,qBAAtC,CALd;;AAAA;AAKErB,oBAAAA,GALF;;AAAA,0BAqBAA,GAAG,KAAK,EArBR;AAAA;AAAA;AAAA;;AAAA,uDAqBmBA,GArBnB;;AAAA;AAuBJlI,4CAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,sBAAAA,GAAG,EAAE,WAAI,OAAI,CAACxD,IAAT,0DAA0D2J,eAA1D,EAA4E7D;AADnE,qBADlB;;AAvBI,0BA4BE1C,mBAAOC,WAAP,CAAmBoF,GAAnB,CA5BF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAgCD;AAED;;;;;;;;wCAKoBsB,iB,EAAmB;AAAA;;AACrC,aAAO,IAAI5G,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI,EAAE;AAAA,iBAAMgC,kBAAM0G,YAAN,+CAEPD,iBAAiB,CAAC1C,GAAlB,CAAsB,UAAA7F,CAAC;AAAA,mBAAK;AAC7ByI,cAAAA,cAAc,EAAE,OAAI,CAACC,kBADQ;AAG7BzI,cAAAA,OAAO,EAAE,OAHoB;AAK7B+F,cAAAA,IAAI,EAAE,CACJhG,CADI,EAEJvB,qBAASuC,qBAAT,CAA+BC,QAA/B,CAAwC0H,KAFpC;AALuB,aAAL;AAAA,WAAvB,CAFO,IAaV;AACA;AACEF,YAAAA,cAAc,EAAE,OAAI,CAAC/G,8BADvB;AAEEzB,YAAAA,OAAO,EAAE;AAFX,WAdU,GAAN;AAAA;AADyB,OAA1B,CAAP;AAqBD;AAED;;;;;;;8BAIUc,iB,EAAmB;AAAA;;AAC3B;AACA,WAAKvB,qBAAL,CAA2BO,MAA3B,CAAkC,UAACC,CAAD,EAAO;AACvC,YAAIA,CAAC,CAACe,iBAAF,KAAwBA,iBAA5B,EAA+C;AAC7C,cAAI;AACF;AACAuB,YAAAA,OAAO,CAACsG,IAAR,CAAa5I,CAAC,CAAC4F,GAAf,EAAoBnH,qBAASoK,eAAT,CAAyBC,OAA7C,EAFE,CAIF;;AACA,YAAA,OAAI,CAACxJ,MAAL,GAAc,OAAI,CAACA,MAAL,CAAYS,MAAZ,CAAmB,UAAAY,CAAC;AAAA,qBAAI,EAAEA,CAAC,CAACI,iBAAF,KAAwBA,iBAA1B,CAAJ;AAAA,aAApB,CAAd;AACD,WAND,CAME,OAAOO,GAAP,EAAY,CACZ;AACD;;AAED,iBAAO,KAAP;AACD;;AAED,eAAO,IAAP;AACD,OAhBD;AAiBD;AAED;;;;;;;;;;;;wCASoB4F,U,EAAYH,M,EAAmB;AAAA;;AAAA,UAAXf,IAAW,uEAAJ,EAAI;AACjD,aAAO,IAAIrE,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAEFiJ,oBAAAA,SAFE,GAGAtK,qBAASuC,qBAAT,CAA+BC,QAH/B,CAEF8H,SAFE;;AAKJhK,4CAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,sBAAAA,GAAG,EAAE,WAAI,OAAI,CAACxD,IAAT,8BAA8B0I,UAA9B,oCAA+DH,MAA/D,EAAwEb;AAD/D,qBADlB;;AALI;AAAA,2BAUc,OAAI,CAACQ,gCAAL,CAAsC;AACtDD,sBAAAA,eAAe,EAAES,UADqC;AAEtDP,sBAAAA,iBAAiB,EAAE,IAFmC;AAGtDC,sBAAAA,mBAAmB,EAAEmC,SAHiC;AAKtDjC,sBAAAA,iBAAiB,EAAE;AACjBC,wBAAAA,MAAM,EAANA,MADiB;AAEjBf,wBAAAA,IAAI,EAAJA;AAFiB,uBALmC;AAUtDgB,sBAAAA,kBAAkB,EAAE+B,SAVkC;AAWtDV,sBAAAA,mBAAmB,EAAEtJ,wBAAYC,WAAZ,GAClBgK;AAZmD,qBAAtC,CAVd;;AAAA;AAUE/B,oBAAAA,GAVF;;AAAA,0BA0BAA,GAAG,KAAK,EA1BR;AAAA;AAAA;AAAA;;AA2BFlI,4CAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,sBAAAA,GAAG,EAAE,WAAI,OAAI,CAACxD,IAAT,yBAAyBuI,MAAzB,8CAAgEG,UAAhE,EAA6EV;AADpE,qBADlB,EA3BE,CAgCF;;;AACA,oBAAA,OAAI,CAACe,iCAAL,CAAuCL,UAAvC,EAAmDH,MAAnD,EAA2D,KAA3D;;AAjCE,uDAmCKE,GAnCL;;AAAA;AAsCJlI,4CAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,sBAAAA,GAAG,EAAE,WAAI,OAAI,CAACxD,IAAT,yBAAyBuI,MAAzB,iDAAmEG,UAAnE,EAAgF5C;AADvE,qBADlB;;AAtCI,0BA2CE2C,GA3CF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AA+CD;AAED;;;;;;;mCAIegC,K,EAAO;AAAA;;AACpB,aAAO,IAAItH,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,yBAGEf,wBAAYC,WAAZ,GACDkK,WAJD;AAAA;AAAA;AAAA;;AAAA;AAAA,2BAKmB,OAAI,CAAC/C,cAAL,GAChBC,OADgB,CACRrH,wBAAYC,WAAZ,GACNkK,WAFc,CALnB;;AAAA;AAKM7C,oBAAAA,IALN;;AAAA,wBAUKtH,wBAAYC,WAAZ,GACFmK,UAXH;AAAA;AAAA;AAAA;;AAAA,uDAYS,KAZT;;AAAA;AAAA,yBAeI9C,IAAI,CAACzF,QAAL,EAfJ;AAAA;AAAA;AAAA;;AAAA,uDAgBSyF,IAAI,CAACtE,cAAL,CAAoBkH,KAApB,CAhBT;;AAAA;AAoBF;AACAnH,sCAAMC,cAAN,CAAqBkH,KAArB;;AArBE;AAAA;;AAAA;AAAA;AAAA;;AAuBF;AACA;AACAnH,sCAAMC,cAAN,CAAqB;AACnBC,sBAAAA,GAAG,EAAEJ,mBAAOK,eAAP,kBAA8B,cAAIC,cAAJ,EAA9B,GAAqDC,MAAM,CAAC,cAAIC,KAAJ,iBAAD,CAD7C;AAEnBC,sBAAAA,GAAG,EAAEC,OAAO,CAACC;AAFM,qBAArB;;AAzBE;AAAA,uDA+BG,KA/BH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAmCD;AAED;;;;;;;;;+CAM2B6G,S,EAAWC,Y,EAAcC,iB,EAAmB;AAAA;;AACrE,aAAO,IAAI3H,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI,EAAE;AAAA,iBAAM,IAAI4F,OAAJ,CAAY,UAACC,OAAD,EAAU4D,MAAV,EAAqB;AAC3C;AACA,gBAAMC,aAAa,GAAIJ,SAAS,IAAIA,SAAS,CAACI,aAAxB,IAA0C1H,kBAAM2H,uBAAN,EAAhE,CAF2C,CAI3C;;;AACA,gBAAMC,WAAW,GAAIN,SAAS,IAAIA,SAAS,CAACO,IAAxB,IAAiC,aAC9ClL,qBAASmL,4BAAT,CAAsCC,IAAtC,CAA2CrL,IADG,aAEhDC,qBAASqL,sBAAT,CAAgCC,KAFgB,eAG9CtL,qBAASmL,4BAAT,CAAsCI,YAAtC,CAAmDxL,IAHL,aAIhDC,qBAASwL,gBAAT,CAA0BC,UAJsB,cAIRV,aAJQ,EAArD,CAL2C,CAY3C;;AACA,gBAAMW,QAAQ,GAAG,EAAjB,CAb2C,CAe3C;;AACA,gBAAI,CAAC,OAAI,CAACtL,eAAV,EAA2B;AACzB,oBAAM,IAAI+C,kBAAJ,CAAW,OAAX,EAAoB,wDAApB,CAAN;AACD,aAlB0C,CAoB3C;;;AACA,gBAAMwI,UAAU,GAAG,OAAI,CAACvL,eAAxB,CArB2C,CAuB3C;;AACA,gBAAMwL,KAAK,GAAGC,0BAAaC,IAAb,CAAkBH,UAAlB,EAA8BV,WAA9B,EAA2CS,QAA3C,CAAd,CAxB2C,CA0B3C;;;AACA,gBAAMK,iBAAiB,GAAGC,UAAU,CAAC,YAAM;AACzC;AACAJ,cAAAA,KAAK,CAACzB,IAAN,CAAWnK,qBAASiM,4BAApB;AAEA,qBAAOnB,MAAM,CAAC,IAAI3H,kBAAJ,CAAW,OAAX,oBAA+B0H,iBAA/B,gBAAD,CAAb;AACD,aALmC,EAKjCA,iBALiC,CAApC,CA3B2C,CAkC3C;AACA;AACA;;AACAe,YAAAA,KAAK,CAACM,EAAN,CAAS,OAAT,EAAkB,UAAArJ,GAAG;AAAA,qBAAIiI,MAAM,CAAC,IAAI3H,kBAAJ,CAAW,OAAX,uBAAkCN,GAAlC,EAAD,CAAV;AAAA,aAArB,EArC2C,CAuC3C;AACA;;AACA+I,YAAAA,KAAK,CAACM,EAAN,CAAS,OAAT,EAAkB,UAACC,IAAD,EAAU;AAC1B;AACA7L,sCAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,gBAAAA,GAAG,EAAE,uBAAgB4I,IAAhB,EAAuBtG;AADd,eADlB;AAID,aAND,EAzC2C,CAiD3C;AACA;;AACA+F,YAAAA,KAAK,CAACM,EAAN,CAAS,MAAT,EAAiB,UAACC,IAAD,EAAU;AACzB;AACA7L,sCAAYC,WAAZ,GACG+C,cADH,CACkB;AACdC,gBAAAA,GAAG,EAAE,sBAAe4I,IAAf,EAAsBtG;AADb,eADlB;AAID,aAND,EAnD2C,CA2D3C;AACA;;AACA,gBAAMuG,YAAY,GAAG,SAAfA,YAAe,CAACC,UAAD,EAAgB;AACnC;AACA,kBAAIA,UAAU,IAAIA,UAAU,CAAC/J,iBAAX,KAAiCyI,aAAnD,EAAkE;AAChE;AACAuB,gBAAAA,YAAY,CAACP,iBAAD,CAAZ;;AACA,gBAAA,OAAI,CAACQ,4BAAL,CAAkCH,YAAlC,EAHgE,CAKhE;;;AACA,gBAAA,OAAI,CAACrL,qBAAL,CAA2BU,IAA3B,CAAgC;AAC9Ba,kBAAAA,iBAAiB,EAAEyI,aADW;AAE9B5D,kBAAAA,GAAG,EAAEkF,UAAU,CAAC7G;AAFc,iBAAhC;;AAKA,uBAAO0B,OAAO,mBACTmF,UADS;AAEZlF,kBAAAA,GAAG,EAAEkF,UAAU,CAAC7G;AAFJ,mBAAd;AAID,eAjBkC,CAmBnC;;;AAEA,qBAAO,KAAP;AACD,aAtBD;;AAwBA,YAAA,OAAI,CAACgH,0BAAL,CAAgCJ,YAAhC;AACD,WAtFW,CAAN;AAAA;AADyB,OAA1B,CAAP;AAyFD;AAED;;;;;;uDAGmC9D,M,EAAQ;AAAA;;AACzC,aAAO,IAAIpF,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAEiB,OAAI,CAACqG,cAAL,GAChBC,OADgB,CACRW,MADQ,CAFjB;;AAAA;AAEIV,oBAAAA,IAFJ;;AAAA,wBAMGA,IANH;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAQF,wBAAIA,IAAI,CAACzF,QAAL,EAAJ,EAAqB;AACnB;AACAyF,sBAAAA,IAAI,CAAC6E,8BAAL,CAAoC;AAClC3L,wBAAAA,kBAAkB,EAAE,OAAI,CAACA,kBADS;AAElC4L,wBAAAA,eAAe,EAAE,OAAI,CAAC7L,MAFY;AAIlCkI,wBAAAA,MAAM,EAAE;AACN1I,0BAAAA,KAAK,EAAE,OAAI,CAACqH,cAAL,GACJiF,iBADI,EADD;AAGNC,0BAAAA,aAAa,EAAE,OAAI,CAACvH,sBAAL,EAHT;AAINwH,0BAAAA,GAAG,EAAExJ,kBAAMyJ,aAAN,EAJC;AAKNC,0BAAAA,YAAY,EAAE,OAAI,CAAC7L,iBALb;AAMNC,0BAAAA,UAAU,EAAE,OAAI,CAACA;AANX;AAJ0B,uBAApC;AAaD;;AAvBC;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AA8BD;AAED;;;;;;qDAGiC;AAAA;;AAC/B,aAAO,IAAI+B,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAEE4F,OAAO,CAACoC,GAAR,CAAY/I,wBAAYC,WAAZ,GACfF,KADe,CACTiB,MADS,CACF,UAAAC,CAAC;AAAA,6BAAIA,CAAC,CAACyL,6BAAN;AAAA,qBADC,EAEf5F,GAFe,CAEX,UAAA7F,CAAC;AAAA,6BAAI,OAAI,CAAC0L,kCAAL,CAAwC1L,CAAC,CAACpB,EAA1C,CAAJ;AAAA,qBAFU,CAAZ,CAFF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAQD;AAED;;;;;;;;;;;kCAQcwK,S,EAAWC,Y,EAA8E;AAAA;;AAAA,UAAhEC,iBAAgE,uEAA5C7K,qBAASkN,iCAAmC;AACrG,aAAO,IAAIhK,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BACc,OAAI,CAAC8L,0BAAL,CAAgCxC,SAAhC,EAA2CC,YAA3C,EAAyDC,iBAAzD,CADd;;AAAA;AACErC,oBAAAA,GADF;AAAA;AAAA,2BAIE,OAAI,CAACvF,8BAAL,EAJF;;AAAA;AAAA,uDAMGuF,GANH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAUD;AAED;;;;;;;;;;;;sDASkClG,iB,EAAmB8K,U,EAAYC,U,EAAY;AAAA;;AAC3E,aAAO,IAAInK,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACJ;AACMiM,oBAAAA,OAFF,8DAGDtN,qBAAS8E,iBAAT,CAA2BC,IAH1B,EAGiCqI,UAHjC,8CAIDpN,qBAAS8E,iBAAT,CAA2BE,IAJ1B,EAIiCqI,UAJjC,cAOJ;;AAPI,uDAQG,OAAI,CAACpD,kBAAL,CAAwB3H,iBAAxB,EAA2CoC,IAAI,CAACC,SAAL,CAAe2I,OAAf,CAA3C,CARH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAYD;AAED;;;;;;;;uCAKmBhL,iB,EAAmBgL,O,EAAS;AAAA;;AAC7C,aAAO,IAAIpK,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AACJ;AACMyB,oBAAAA,KAFF,GAEU,OAAI,CAACoG,2BAAL,CAAiC5G,iBAAjC,CAFV,EAIJ;;AACA,oBAAA,OAAI,CAAC+C,sBAAL,GACGM,mBADH,CACuB7C,KAAK,CAACpB,kBAD7B,EACiDoB,KAAK,CAACnB,oBADvD,EAC6E2L,OAD7E;;AALI,uDAQG,IARH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAYD;AAED;;;;;;;gDAI4BhL,iB,EAAmB;AAC7C;AACA,UAAMQ,KAAK,GAAG,KAAKjC,MAAL,CAAYkC,IAAZ,CAAiB,UAAAxB,CAAC;AAAA,eAAIA,CAAC,CAACe,iBAAF,KAAwBA,iBAA5B;AAAA,OAAlB,CAAd;AAEA,aAAOQ,KAAK,IAAI,IAAIK,kBAAJ,CAAW,OAAX,wBAAmCb,iBAAnC,EAAhB;AACD;AAED;;;;;;;;;;;;;wCAUoB8K,U,EAAY9K,iB,EACA;AAAA;;AAAA,UADmBiL,OACnB,uEAD6BjN,wBAAYC,WAAZ,GAC1DiN,2BAA6B;AAC9B,aAAO,IAAItK,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI,EAAE;AAAA,iBAAM,IAAI4F,OAAJ,CAAY,UAACC,OAAD,EAAU4D,MAAV,EAAqB;AAC3C,gBAAI2C,eAAe,GAAG,KAAtB,CAD2C,CAG3C;;AACA,gBAAM3K,KAAK,GAAG,OAAI,CAACoG,2BAAL,CAAiC5G,iBAAjC,CAAd,CAJ2C,CAM3C;;;AACA,gBAAMoL,WAAW,GAAG,SAAdA,WAAc,CAAChM,kBAAD,EAAqBC,oBAArB,EAA2C2E,UAA3C,EAA0D;AAC5E;AAEA,kBAAI3E,oBAAoB,KAAKmB,KAAK,CAACnB,oBAAnC,EAAyD;AACvD,oBAAMqE,QAAQ,GAAG3C,kBAAMkD,mBAAN,CAA0BD,UAA1B,CAAjB,CADuD,CAGvD;AACA;;;AACA,oBAAIN,QAAQ,IAAIA,QAAQ,CAAChG,qBAAS8E,iBAAT,CAA2BC,IAA5B,CAApB,IACFiB,QAAQ,CAAChG,qBAAS8E,iBAAT,CAA2BC,IAA5B,CAAR,KAA8CqI,UADhD,EAC4D;AAC1D;AACAd,kBAAAA,YAAY,CAACmB,eAAD,CAAZ,CAF0D,CAI1D;;AACA,kBAAA,OAAI,CAACpI,sBAAL,GACGsI,yBADH,CAC6BD,WAD7B,EAL0D,CAQ1D;;;AACA,yBAAOxG,OAAO,CAAClB,QAAQ,CAAChG,qBAAS8E,iBAAT,CAA2BE,IAA5B,CAAT,CAAd;AACD;AACF;;AAED,qBAAO,KAAP;AACD,aAvBD,CAP2C,CAgC3C;;;AACAyI,YAAAA,eAAe,GAAGzB,UAAU,CAAC,YAAM;AACjC;AACA,cAAA,OAAI,CAAC3G,sBAAL,GACGsI,yBADH,CAC6BD,WAD7B,EAFiC,CAKjC;;;AACA,qBAAO5C,MAAM,CAAC,IAAI3H,kBAAJ,CAAW,OAAX,CAAD,CAAb;AACD,aAP2B,EAOzBoK,OAPyB,CAA5B,CAjC2C,CA0C3C;;AACA,mBAAO,OAAI,CAAClI,sBAAL,GACJgB,uBADI,CACoBqH,WADpB,CAAP;AAED,WA7CW,CAAN;AAAA;AADyB,OAA1B,CAAP;AAgDD;AAED;;;;;;8CAG0B;AAAA;;AACxB,aAAO,IAAIxK,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA,yBACA,OAAI,CAACuM,sBADL;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAGJ,wBAAI5N,qBAAS6N,8BAAb,EAA6C;AAC3C;AACA,sBAAA,OAAI,CAACD,sBAAL,GAA8BE,WAAW;AAAA;AAAA;AAAA;AAAA,mDAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uCAEXzK,kBAAM0K,mBAAN,EAFW;;AAAA;AAEhChB,gCAAAA,YAFgC;AAItC,gCAAA,OAAI,CAAC7L,iBAAL,GAAyB6L,YAAzB,CAJsC,CAMtC;;AACA,gCAAA,OAAI,CAAC9J,8BAAL;;AAEA,oCAAI,CAAC,OAAI,CAAC+K,MAAN,IAAgB,OAAI,CAACJ,sBAAzB,EAAiD;AAC/CK,kCAAAA,aAAa,CAAC,OAAI,CAACL,sBAAN,CAAb;AAEA,kCAAA,OAAI,CAACA,sBAAL,GAA8B,KAA9B;AACD;;AAbqC;AAAA;;AAAA;AAAA;AAAA;;AAetCtN,wDAAYC,WAAZ,GACG2N,aADH;;AAfsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAD,IAkBtClO,qBAAS6N,8BAlB6B,CAAzC;AAmBD;;AAxBG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AA4BD;AAED;;;;;;4CAGwB;AAAA;;AACtB,UAAI,KAAKM,oBAAT,EAA+B;AAE/B,WAAKA,oBAAL,GAA4BL,WAAW;AAAA;AAAA;AAAA;AAAA,mCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAEhB,OAAI,CAACM,WAAL,CAAiBC,0BAAjB,EAFgB;;AAAA;AAE9BC,gBAAAA,KAF8B;AAIpC,gBAAA,OAAI,CAACnN,UAAL,GAAkBmN,KAAlB;;AAEA,gBAAA,OAAI,CAACrL,8BAAL,GANoC,CAQpC;;;AACA,oBAAI,CAAC,OAAI,CAAC+K,MAAN,IAAgB,OAAI,CAACG,oBAAzB,EAA+C;AAC7CF,kBAAAA,aAAa,CAAC,OAAI,CAACE,oBAAN,CAAb;AAEA,kBAAA,OAAI,CAACA,oBAAL,GAA4B,KAA5B;AACD;;AAbmC;AAAA;;AAAA;AAAA;AAAA;;AAepC7N,wCAAYC,WAAZ,GACG2N,aADH;;AAfoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,IAkBpClO,qBAASuO,wBAlB2B,CAAvC;AAmBD;AAED;;;;;;;;;;;;;;;iCAeG;AAAA;;AAAA,iCAFDC,QAEC;AAAA,UAFDA,QAEC,+BAFUxO,qBAASyO,OAAT,CAAiBC,yBAE3B;AAAA,mCADDC,UACC;AAAA,UADDA,UACC,iCADY3O,qBAASyO,OAAT,CAAiBG,sBAC7B;AACD,aAAO,IAAI1L,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AACJ;AACA,oBAAA,OAAI,CAACV,cAAL,GAFI,CAIJ;;;AACA,oBAAA,OAAI,CAACC,mBAAL,GAA2B,IAAIiO,8BAAJ,EAA3B,CALI,CAOJ;;AAPI;AAAA,2BAQE,OAAI,CAACjO,mBAAL,CAAyBkO,KAAzB,CAA+B;AACnCN,sBAAAA,QAAQ,EAARA,QADmC;AAEnCG,sBAAAA,UAAU,EAAVA,UAFmC;AAGnCI,sBAAAA,SAAS,EAAE/O,qBAASyO,OAAT,CAAiBO,SAAjB,CAA2BC;AAHH,qBAA/B,CARF;;AAAA;AAcJ,oBAAA,OAAI,CAACjB,MAAL,GAAc,IAAd;;AAEA,oBAAA,OAAI,CAACkB,mBAAL,GAhBI,CAkBJ;;;AACA,oBAAA,OAAI,CAACjM,8BAAL,GAnBI,CAqBJ;;;AACA,oBAAA,OAAI,CAACkM,uBAAL,GAtBI,CAwBJ;;;AACA,oBAAA,OAAI,CAACC,qBAAL;;AAzBI,uDA2BG,IA3BH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AA+BD;AAED;;;;;;;AAwCA;;;;4CAIwB;AACtB,UAAMC,WAAW,GAAG,KAAK3H,cAAL,GACjBiF,iBADiB,EAApB,CADsB,CAItB;;AACA,UAAM2C,kBAAkB,GAAGxP,SAAS,CAACyP,SAAV,CAAoBF,WAAW,CAACjI,GAAZ,CAAgB,UAAA7F,CAAC;AAAA,eAAK;AACnE+G,UAAAA,MAAM,EAAE/G,CAAC,CAACpB,EADyD;AAEnEqP,UAAAA,gBAAgB,EAAEjO,CAAC,CAACiO;AAF+C,SAAL;AAAA,OAAjB,CAApB,CAA3B,CALsB,CAUtB;;AACA,UAAMhH,GAAG,GAAG;AACViH,QAAAA,cAAc,EAAE,KADN;AAEVC,QAAAA,YAAY,EAAE,KAFJ;AAGVC,QAAAA,WAAW,EAAE,KAHH;AAIV3H,QAAAA,eAAe,EAAE,KAJP;AAKV4H,QAAAA,cAAc,EAAE,KALN;AAMVrI,QAAAA,IAAI,EAAE;AANI,OAAZ;AASA,UAAMsI,uBAAuB,GAAG,KAAKhP,MAAL,CAAYoB,IAAZ,CAAiB,UAAAV,CAAC;AAAA,eAAIA,CAAC,CAAClB,KAAF,CAAQ4B,IAAR,CAAa,UAACC,CAAD,EAAO;AACxE;AACA,cAAM4N,UAAU,GAAGhQ,SAAS,CAACiQ,yBAAV,CAAoCT,kBAApC,EAAwDpN,CAAC,CAAC/B,EAA1D,CAAnB;AAEA,cAAI,CAAC+B,CAAC,CAACC,QAAP,EAAiB,OAAO,KAAP,CAJuD,CAMxE;;AACA,cAAIqG,GAAG,CAACoH,cAAJ,KAAuB,KAAvB,IAAiCpH,GAAG,CAACoH,cAAJ,GAAqBE,UAA1D,EAAuE;AACrE;AACAtH,YAAAA,GAAG,CAACoH,cAAJ,GAAqBE,UAArB;AACAtH,YAAAA,GAAG,CAACiH,cAAJ,GAAqBvN,CAAC,CAAC/B,EAAvB;AACAqI,YAAAA,GAAG,CAACmH,WAAJ,GAAkB,IAAlB;AACAnH,YAAAA,GAAG,CAACkH,YAAJ,GAAmB,KAAnB;AACAlH,YAAAA,GAAG,CAACR,eAAJ,GAAsBzG,CAAC,CAACe,iBAAxB,CANqE,CAQrE;;AACA,gBAAIgN,kBAAkB,CAACU,MAAnB,IAA6BF,UAAU,KAAKR,kBAAkB,CAAC,CAAD,CAAlB,CAAsBE,gBAAtE,EAAwF,OAAO,IAAP;AACzF;;AAED,iBAAO,KAAP;AACD,SApBqD,CAAJ;AAAA,OAAlB,CAAhC;AAsBA,UAAIK,uBAAJ,EAA6B,OAAOrH,GAAP,CA1CP,CA4CtB;;AACA6G,MAAAA,WAAW,CAACpN,IAAZ,CAAiB,UAACV,CAAD,EAAO;AACtB,YAAM0O,UAAU,GAAGnQ,SAAS,CAACiQ,yBAAV,CAAoCT,kBAApC,EAAwD/N,CAAC,CAACpB,EAA1D,CAAnB;AAEA,YAAI,CAACoB,CAAC,CAACY,QAAP,EAAiB,OAAO,KAAP,CAHK,CAKtB;;AACA,YAAIqG,GAAG,CAACoH,cAAJ,KAAuB,KAAvB,IAAiCpH,GAAG,CAACoH,cAAJ,GAAqBK,UAA1D,EAAuE;AACrE;AACAzH,UAAAA,GAAG,CAACoH,cAAJ,GAAqBK,UAArB;AACAzH,UAAAA,GAAG,CAACiH,cAAJ,GAAqBlO,CAAC,CAACpB,EAAvB;AACAqI,UAAAA,GAAG,CAACmH,WAAJ,GAAkB,KAAlB;AACAnH,UAAAA,GAAG,CAACkH,YAAJ,GAAmB,IAAnB;AACAlH,UAAAA,GAAG,CAACR,eAAJ,GAAsB,KAAtB,CANqE,CAQrE;;AACA,cAAIsH,kBAAkB,CAACU,MAAnB,IAA6BC,UAAU,KAAKX,kBAAkB,CAAC,CAAD,CAAlB,CAAsBE,gBAAtE,EAAwF,OAAO,IAAP;AACzF;;AACD,eAAO,KAAP;AACD,OAlBD;AAoBA,aAAOhH,GAAP;AACD;AAED;;;;;;;;;uDAMmC;AAAA;;AACjC,aAAO,IAAItF,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;;AAAA;AAAA;AAAA;AAAA;AACJ;AACA;AAFI,4CASA,OAAI,CAAC6O,qBAAL,EATA,EAIFT,cAJE,yBAIFA,cAJE,EAKFC,YALE,yBAKFA,YALE,EAMFC,WANE,yBAMFA,WANE,EAOF3H,eAPE,yBAOFA,eAPE,EAQFT,IARE,yBAQFA,IARE,EAWJ;;AAXI,0BAYAkI,cAAc,KAAK,KAZnB;AAAA;AAAA;AAAA;;AAaF;AACA,oBAAA,OAAI,CAACxM,8BAAL;;AAdE,uDAgBK,IAhBL;;AAAA;AAAA,yBAmBAyM,YAnBA;AAAA;AAAA;AAAA;;AAAA;AAAA,2BAoBI,OAAI,CAAChI,cAAL,GACHyI,QADG,CACMV,cADN,EACsBlI,IADtB,CApBJ;;AAAA;AAAA,uDAwBK,OAAI,CAAC6I,gCAAL,EAxBL;;AAAA;AAAA,yBA2BAT,WA3BA;AAAA;AAAA;AAAA;;AAAA;AAAA,2BA4BI,OAAI,CAACU,mBAAL,CAAyBrI,eAAzB,EAA0CyH,cAA1C,EAA0DlI,IAA1D,CA5BJ;;AAAA;AAAA,uDA+BK,OAAI,CAAC6I,gCAAL,EA/BL;;AAAA;AAAA,uDAkCG,IAlCH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAsCD;AAED;;;;;;;;2BAKO;AAAA;;AACL,aAAO,IAAIlN,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAEE,OAAI,CAAC+O,gCAAL,EAFF;;AAAA;AAAA;AAAA,2BAIE,OAAI,CAACE,mBAAL,CAAyB,OAAI,CAACzP,MAAL,CAAYuG,GAAZ,CAAgB,UAAA7F,CAAC;AAAA,6BAAIA,CAAC,CAACe,iBAAN;AAAA,qBAAjB,CAAzB,CAJF;;AAAA;AAMJ;AACA,wBAAI,OAAI,CAACsL,sBAAT,EAAiCK,aAAa,CAAC,OAAI,CAACL,sBAAN,CAAb;AAEjC,wBAAI,OAAI,CAACO,oBAAT,EAA+BF,aAAa,CAAC,OAAI,CAACE,oBAAN,CAAb,CAT3B,CAWJ;;AAXI;AAAA,2BAYE,OAAI,CAACvN,mBAAL,CAAyB2P,IAAzB,EAZF;;AAAA;AAcJ,oBAAA,OAAI,CAACvC,MAAL,GAAc,KAAd;AAdI,uDAgBG,IAhBH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAoBD;AAED;;;;;;;;;;;;4DAkBG;AAAA;;AAAA,UARDhG,eAQC,SARDA,eAQC;AAAA,UAPDG,mBAOC,SAPDA,mBAOC;AAAA,UANDE,iBAMC,SANDA,iBAMC;AAAA,UALDE,kBAKC,SALDA,kBAKC;AAAA,UAJDL,iBAIC,SAJDA,iBAIC;AAAA,UADD0B,mBACC,SADDA,mBACC;AACD,aAAO,IAAI1G,iCAAJ,CAA0B;AAC/B7B,QAAAA,IAAI,EAAE;AAAA,iBAAM,IAAI4F,OAAJ,CAAY,UAACC,OAAD,EAAU4D,MAAV,EAAqB;AAC3C;AACA,gBAAM0F,mBAAmB,GAAG,SAAtBA,mBAAsB,GAAM;AAChC,kBAAItI,iBAAJ,EAAuB,OAAO,OAAI,CAAC7F,iCAAZ;AAEvB,qBAAO,OAAI,CAAC4H,kBAAZ;AACD,aAJD;;AAMA,gBAAIwG,kBAAkB,GAAG,KAAzB,CAR2C,CAU3C;;AACA,YAAA,OAAI,CAACC,mBAAL,CAAyBnI,kBAAzB,EAA6CP,eAA7C,EAA8D4B,mBAA9D,EACE;AADF,aAEG+G,IAFH,CAEQzJ,OAFR,WAGS,UAACrE,GAAD,EAAS;AACd,kBAAI,CAAC4N,kBAAL,EAAyB;AACvBA,gBAAAA,kBAAkB,GAAG,IAArB;AAEA,uBAAO3F,MAAM,CAACjI,GAAD,CAAb;AACD;;AAED,qBAAO,KAAP;AACD,aAXH,EAX2C,CAwB3C;;;AACA2N,YAAAA,mBAAmB,GAChBI,IADH,CACQ,OADR,EACc5I,eADd,EAC+BG,mBAD/B,EACoDE,iBADpD,EAEGsI,IAFH,CAEQ,YAAM,CACV;AACA;AAEA;AACA;AACA;AACD,aATH,WAUS,UAAC9N,GAAD,EAAS;AACd;AACA,kBAAI,CAAC4N,kBAAL,EAAyB;AACvBA,gBAAAA,kBAAkB,GAAG,IAArB;AAEA,uBAAO3F,MAAM,CAACjI,GAAD,CAAb;AACD;;AAED,qBAAO,KAAP;AACD,aAnBH;AAoBD,WA7CW,CAAN;AAAA;AADyB,OAA1B,CAAP;AAgDD;;;kCA7jDoB;AACnB,aAAOhD,QAAQ,IAAI,IAAIC,SAAJ,EAAnB;AACD;;;8CAg0CgCwP,kB,EAAoBhH,M,EAAQ;AAC3D,UAAIuI,KAAJ;AAEAvB,MAAAA,kBAAkB,CAACrN,IAAnB,CAAwB,UAACV,CAAD,EAAO;AAC7B,YAAIA,CAAC,CAAC+G,MAAF,KAAaA,MAAjB,EAAyB;AACvBuI,UAAAA,KAAK,GAAGtP,CAAC,CAACiO,gBAAV;AAEA,iBAAO,IAAP;AACD;;AAED,eAAO,KAAP;AACD,OARD;AAUA,aAAOqB,KAAP;AACD;AAED;;;;;;8BAGiB9J,G,EAAK;AACpB,UAAM+J,GAAG,GAAG/J,GAAZ;;AAEA,WAAK,IAAIgK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAID,GAAG,CAACd,MAAJ,GAAa,CAAlC,EAAsCe,CAAC,IAAI,CAA3C,EAA8C;AAC5C,YAAID,GAAG,CAACC,CAAD,CAAH,CAAOvB,gBAAP,GAA0BsB,GAAG,CAACC,CAAC,GAAG,CAAL,CAAH,CAAWvB,gBAAzC,EAA2D;AACzD,cAAMwB,GAAG,GAAGF,GAAG,CAACC,CAAC,GAAG,CAAL,CAAf;AAEAD,UAAAA,GAAG,CAACC,CAAC,GAAG,CAAL,CAAH,GAAaD,GAAG,CAACC,CAAD,CAAhB;AAEAD,UAAAA,GAAG,CAACC,CAAD,CAAH,GAASC,GAAT;AAEAD,UAAAA,CAAC,GAAG,CAAC,CAAL;AACD;AACF;;AAED,aAAOD,GAAP;AACD;;;EAt6CoCG,oB","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport childProcess from 'child_process';\nimport AMaster from './AMaster.js';\nimport CONSTANT from '../../../Utils/CONSTANT/CONSTANT.js';\nimport TaskHandler from '../../Handlers/TaskHandler.js';\nimport ZeroMQServerRouter from '../../../CommunicationSystem/SocketCommunicationSystem/ZeroMQ/Server/Implementations/ZeroMQServerRouter.js';\nimport Utils from '../../../Utils/Utils.js';\nimport Errors from '../../../Utils/Errors.js';\nimport RoleAndTask from '../../../RoleAndTask.js';\nimport PromiseCommandPattern from '../../../Utils/PromiseCommandPattern.js';\n\nlet instance = null;\n\n/**\n * Define the Role of Master which have a job of manager.\n *\n * Manage Slaves.\n */\nexport default class Master1_0 extends AMaster {\n  constructor() {\n    super();\n\n    if (instance) return instance;\n\n    this.name = CONSTANT.DEFAULT_ROLES.MASTER_ROLE.name;\n    this.id = CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id;\n\n    this.pathToEntryFile = false;\n\n    // Get the tasks related to the master role\n    const tasks = RoleAndTask.getInstance()\n      .getRoleTasks(CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id);\n\n    // Define all tasks handled by this role\n    this.setTaskHandler(new TaskHandler(tasks));\n\n    this.initProperties();\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * Init the properties\n   */\n  initProperties() {\n    // Define none communicationSystem for now\n    this.communicationSystem = false;\n\n    // Array of current approved slaves\n    this.slaves = [];\n\n    // Array of slaves that are in the confirmation process\n    this.notConfirmedSlaves = [];\n\n    // Array that contains the relation between console process ptr and programIdentifier\n    // We use it too when there is no console launch, because it work with both soluce\n    this.consoleChildObjectPtr = [];\n\n    // Functions called when something happend to a slave connection\n    this.newConnectionListeningFunction = [];\n    this.newDisconnectionListeningFunction = [];\n\n    // Data we keep as attribute to give to handleProgramTask later\n    this.cpuUsageAndMemory = false;\n    this.tasksInfos = false;\n\n    // Store the mutexes here, we use to avoid concurrency between slaves on specific actions\n    this.mutexes = {};\n  }\n\n  /**\n   * Get the communicationSystem\n   */\n  getCommunicationSystem() {\n    return this.communicationSystem;\n  }\n\n  /**\n   * SINGLETON implementation\n   * @override\n   */\n  static getInstance() {\n    return instance || new Master1_0();\n  }\n\n  /**\n   * Pull a function that get fired when a slave get connected\n   */\n  unlistenSlaveConnectionEvent(func) {\n    this.newConnectionListeningFunction = this.newConnectionListeningFunction.filter(x => x.func !== func);\n  }\n\n  /**\n   * Pull a function that get fired when a slave get disconnected\n   */\n  unlistenSlaveDisconnectionEvent(func) {\n    this.newDisconnectionListeningFunction = this.newDisconnectionListeningFunction.filter(x => x.func !== func);\n  }\n\n  /**\n   * Push a function that get fired when a slave get connected\n   */\n  listenSlaveConnectionEvent(func, context) {\n    this.newConnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Push a function that get fired when a slave get disconnected\n   */\n  listenSlaveDisconnectionEvent(func) {\n    this.newDisconnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Return the array that contains non-confirmed slaves\n   */\n  getNonConfirmedSlaves() {\n    return this.notConfirmedSlaves;\n  }\n\n  /**\n   *  Get an array that contains confirmed slaves\n   */\n  getSlaves() {\n    return this.slaves;\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks and our tasks\n   *\n   * WARNING - DO NOT SEND IT TO NON-REGULAR SLAVES (CRON_EXECUTOR_ROLE FOR EXAMPLE)\n   *\n   * @param {[Byte]} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {Object} data\n   */\n  sendDataToEveryProgramTaskWhereverItIsLowLevel(clientIdentityByte, clientIdentityString, body) {\n    const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n    // Open the body to get the list of tasks we limit the spread on\n    const {\n      limitToTaskList,\n    } = body;\n\n\n    // For each slave\n    regularSlaves.forEach((x) => {\n      // Only send the data to the slaves that holds a tasks that need to know about the message\n      if (!limitToTaskList || x.tasks.some(y => y.isActive && limitToTaskList.includes(y.id))) {\n        // Send a message to every running slaves\n        this.sendMessageToSlaveHeadBodyPattern(x.programIdentifier, CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.GENERIC_CHANNEL_DATA, body);\n      }\n    });\n\n    // For itself tasks\n    RoleAndTask.getInstance()\n      .spreadDataToEveryLocalTask(body);\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks and our tasks\n   */\n  sendDataToEveryProgramTaskWhereverItIs(data) {\n    this.sendDataToEveryProgramTaskWhereverItIsLowLevel(false, false, data);\n  }\n\n  /**\n   * Tell the Task about something happend in slaves\n   */\n  tellMasterAboutSlaveError(clientIdentityString, err) {\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    if (!slave) return;\n\n    slave.error = err;\n    this.somethingChangedAboutSlavesOrI();\n  }\n\n  /**\n   * An error happended into a slave, what do we do?\n   * @param {Array} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {String} body\n   */\n  errorHappenedIntoSlave(clientIdentityByte, clientIdentityString, body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const err = Errors.deserialize(body);\n\n        // Display the error\n        Utils.displayMessage({\n          str: Errors.staticIsAnError(err) ? err.getErrorString() : String(err.stack || err),\n          out: process.stderr,\n        });\n\n        try {\n          // Get the client that got the problem\n          // We try to change the program state to error\n          await RoleAndTask.getInstance()\n            .changeProgramState(CONSTANT.DEFAULT_STATES.ERROR.id);\n\n          // We goodly changed the program state\n          // Add informations on error\n\n          Utils.displayMessage({\n            str: Errors.staticIsAnError(err) ? err.getErrorString() : String(err.stack || err),\n            out: process.stderr,\n          });\n\n          // Tell the task handleProgram that there had been an error for the slave\n          this.tellMasterAboutSlaveError(clientIdentityString, err);\n\n          // If the errors are supposed to be fatal, exit!\n          if (RoleAndTask.getInstance()\n            .makesErrorFatal) {\n            RoleAndTask.exitProgramUnproperDueToError();\n          }\n          // We leave the process because something get broken\n        } catch (errNested) {\n          Utils.displayMessage({\n            str: 'Exit program unproper ERROR HAPPENED IN SLAVE',\n            out: process.stderr,\n          });\n\n          Utils.displayMessage({\n            str: String((errNested && errNested.stack) || errNested),\n            out: process.stderr,\n          });\n\n          RoleAndTask.exitProgramUnproperDueToError();\n        }\n      },\n    });\n  }\n\n  /**\n   * In master/slave protocol, we ask to get a token. We get directly asked as the master\n   */\n  takeMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // The mutex has already been taken\n        if (this.mutexes[id]) {\n          throw new Errors('E7024');\n        }\n\n        // Custom function to call when taking or releasing the mutex (if one got set by the user)\n        // If the function throw, we do not take the token\n        const customFunctions = RoleAndTask.getInstance()\n          .getMasterMutexFunctions()\n          .find(x => x.id === id);\n\n        if (customFunctions && customFunctions.funcTake) {\n          await customFunctions.funcTake();\n        }\n\n        this.mutexes[id] = true;\n      },\n    });\n  }\n\n  /**\n   * In master/slave protocol, we ask to release the token. We get directly asked as the master.\n   */\n  releaseMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Custom function to call when taking or releasing the mutex (if one got set by the user)\n        // If the function throw, we do not take the token\n        const customFunctions = RoleAndTask.getInstance()\n          .getMasterMutexFunctions()\n          .find(x => x.id === id);\n\n        if (customFunctions && customFunctions.funcRelease) {\n          await customFunctions.funcRelease();\n        }\n\n        this.mutexes[id] = false;\n      },\n    });\n  }\n\n  /**\n   * Take the mutex behind the given ID if it's available\n   */\n  protocolTakeMutex(clientIdentityByte, clientIdentityString, body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          TAKE_MUTEX,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // Det the slave that asked\n        const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n        try {\n          // The mutex has already been taken\n          if (this.mutexes[body.id]) {\n            throw new Errors('E7024');\n          }\n\n          // Custom function to call when taking or releasing the mutex (if one got set by the user)\n          // If the function throw, we do not take the token\n          const customFunctions = RoleAndTask.getInstance()\n            .getMasterMutexFunctions()\n            .find(x => x.id === body.id);\n\n          if (customFunctions && customFunctions.funcTake) {\n            await customFunctions.funcTake();\n          }\n\n          this.mutexes[body.id] = true;\n\n          this.sendMessageToSlaveHeadBodyPattern(slave.programIdentifier, TAKE_MUTEX, JSON.stringify({\n            error: false,\n          }));\n        } catch (err) {\n          this.sendMessageToSlaveHeadBodyPattern(slave.programIdentifier, TAKE_MUTEX, JSON.stringify({\n            error: err.serialize(),\n          }));\n        }\n      },\n    });\n  }\n\n  /**\n   * Release the mutex behind the given ID\n   */\n  protocolReleaseMutex(clientIdentityByte, clientIdentityString, body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          RELEASE_MUTEX,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // Det the slave that asked\n        const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n        try {\n          // Custom function to call when taking or releasing the mutex (if one got set by the user)\n          // If the function throw, we do not take the token\n          const customFunctions = RoleAndTask.getInstance()\n            .getMasterMutexFunctions()\n            .find(x => x.id === body.id);\n\n          if (customFunctions && customFunctions.funcRelease) {\n            await customFunctions.funcRelease();\n          }\n\n          this.mutexes[body.id] = false;\n\n          this.sendMessageToSlaveHeadBodyPattern(slave.programIdentifier, RELEASE_MUTEX, JSON.stringify({\n            error: false,\n          }));\n        } catch (err) {\n          this.sendMessageToSlaveHeadBodyPattern(slave.programIdentifier, RELEASE_MUTEX, JSON.stringify({\n            error: err.serialize(),\n          }));\n        }\n      },\n    });\n  }\n\n  /**\n   * Define the master/slave basic protocol\n   * (Authentification)\n   */\n  protocolMasterSlave() {\n    // Shortcuts\n    const {\n      HEAD,\n      BODY,\n    } = CONSTANT.PROTOCOL_KEYWORDS;\n\n    const {\n      SLAVE_CONFIRMATION_INFORMATIONS,\n      GENERIC_CHANNEL_DATA,\n      OUTPUT_TEXT,\n      INFOS_ABOUT_SLAVES,\n      ERROR_HAPPENED,\n      TAKE_MUTEX,\n      RELEASE_MUTEX,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    // Listen at new Socket connection\n    //\n    // 1/ Check if the new slave have a correct identifier\n    // 2/ Ask the slave for running tasks\n    // 3/ Get the slave answer\n    // 4/ Add the slave into handled slave\n    //\n    this.getCommunicationSystem()\n      .listenClientConnectionEvent((clientIdentityByte, clientIdentityString) => {\n        const [\n          programIdentifier,\n          clientPID,\n        ] = clientIdentityString.split('_');\n\n        // Look at the identity of the slave (and if we have duplicate)\n        if (this.slaves.find(x => x.programIdentifier === programIdentifier) ||\n          this.notConfirmedSlaves.find(x => x.programIdentifier === programIdentifier)) {\n          // Identity already in use by an other slave\n          // Close the connection\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `[${this.name}] Refuse slave cause of identity`.cyan,\n            });\n\n          return this.getCommunicationSystem()\n            .closeConnectionToClient(clientIdentityByte, clientIdentityString);\n        }\n\n        // So here the client do not exist already and the identifier is free\n\n        // Add the slave into the declared not confirmed array\n        this.notConfirmedSlaves.push({\n          clientIdentityString,\n          clientIdentityByte,\n          programIdentifier,\n          clientPID,\n          tasks: [],\n          error: false,\n        });\n\n        // Ask the slaves about its tasks\n        return this.getCommunicationSystem()\n          .sendMessageToClient(clientIdentityByte, clientIdentityString, SLAVE_CONFIRMATION_INFORMATIONS);\n      });\n\n    // Listen to slaves disconnection\n    this.getCommunicationSystem()\n      .listenClientDisconnectionEvent((clientIdentityString) => {\n        this.slaves = this.slaves.filter((x) => {\n          if (x.clientIdentityString === clientIdentityString) {\n            RoleAndTask.getInstance()\n              .displayMessage({\n                str: `[${this.name}] Slave get removed (connection)`.red,\n              });\n\n            // Fire when a slave get disconnected\n            Utils.fireUp(this.newDisconnectionListeningFunction, [x]);\n\n            return false;\n          }\n\n          return true;\n        });\n\n        this.notConfirmedSlaves = this.notConfirmedSlaves.filter((x) => {\n          if (x.clientIdentityString === clientIdentityString) {\n            RoleAndTask.getInstance()\n              .displayMessage({\n                str: `[${this.name}] Non-confirmed slave get removed (connection)`.red,\n              });\n\n            // Fire when a slave get disconnected\n            Utils.fireUp(this.newDisconnectionListeningFunction, [x]);\n\n            return false;\n          }\n\n          return true;\n        });\n      });\n\n    // Confirm a slave that wasn't\n    const confirmSlave = (clientIdentityByte, clientIdentityString, dataJSON) => {\n      const index = this.notConfirmedSlaves.findIndex(x => x.clientIdentityString === clientIdentityString);\n\n      if (index === -1) return;\n\n      // Confirm the slave\n      const slave = this.notConfirmedSlaves[index];\n\n      slave.tasks = dataJSON[BODY].tasks;\n      slave.role = dataJSON[BODY].role;\n\n      this.slaves.push(slave);\n\n      this.notConfirmedSlaves.splice(index, 1);\n\n      // Fire when a slave get connected\n      Utils.fireUp(this.newConnectionListeningFunction, [slave]);\n    };\n\n    // We listen to incoming messages\n    this.getCommunicationSystem()\n      .listenToIncomingMessage((clientIdentityByte, clientIdentityString, dataString) => {\n        const dataJSON = Utils.convertStringToJSON(dataString);\n\n        // Here we got all messages that comes from clients (so slaves)\n        // Check if the message answer particular message\n        // If it does apply the particular job\n        [{\n          //\n          // Check about the slave infos\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === SLAVE_CONFIRMATION_INFORMATIONS),\n          // It means we get the tasks list\n          applyFunc: () => confirmSlave(clientIdentityByte, clientIdentityString, dataJSON),\n        }, {\n          //\n          // Check about generic news\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === GENERIC_CHANNEL_DATA),\n          applyFunc: () => this.sendDataToEveryProgramTaskWhereverItIsLowLevel(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about messages to display\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === OUTPUT_TEXT),\n          applyFunc: () => this.displayMessage(dataJSON[BODY]),\n        }, {\n          //\n          // Check about infos about slaves\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === INFOS_ABOUT_SLAVES),\n          applyFunc: () => this.infosAboutSlaveIncomming(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about error happened into slave\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === ERROR_HAPPENED),\n          applyFunc: () => this.errorHappenedIntoSlave(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about slave asking for taking a mutex\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === TAKE_MUTEX),\n          applyFunc: () => this.protocolTakeMutex(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about slave asking for releasing a mutex\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === RELEASE_MUTEX),\n          applyFunc: () => this.protocolReleaseMutex(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }].forEach((x) => {\n          if (x.checkFunc()) x.applyFunc();\n        });\n      });\n  }\n\n  /**\n   * We got news about a slave -> infos\n   * Store it and call HandleProgramTask if it's up\n   * @param {Object} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {Object} data\n   */\n  infosAboutSlaveIncomming(clientIdentityByte, clientIdentityString, data) {\n    // Get the right slave\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n    const notConfirmedSlave = this.notConfirmedSlaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    const ptr = slave || notConfirmedSlave;\n\n    if (!ptr) return;\n\n    if (!ptr.moreInfos) ptr.moreInfos = {};\n\n    // Apply values to moreInfos\n    [\n      'cpuAndMemory',\n      'ips',\n      'tasksInfos',\n    ]\n    .forEach((x) => {\n      // To get the 0 value\n      if (data[x] !== void 0) ptr.moreInfos[x] = data[x];\n    });\n\n    // Tell something changed in the conf\n    this.somethingChangedAboutSlavesOrI();\n  }\n\n  /**\n   * Returns in an array the whole system pids (Master + Slaves processes)\n   */\n  getFullSystemPids() {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve) => {\n        resolve([\n          String(process.pid),\n          ...this.slaves.map(x => String(x.clientPID)),\n        ]);\n      }),\n    });\n  }\n\n  /**\n   * Connect the second Task to the first one\n   * @param {String} idTaskToConnectTo\n   * @param {String} idTaskToConnect\n   * @param {Object} args\n   */\n  connectMasterToTask(idTaskToConnectTo, idTaskToConnect, args) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: Utils.monoline([\n                  `[${this.name}] Ask Master to connect the Task N°${idTaskToConnect}`,\n                  ` to the Task N°${idTaskToConnectTo}`,\n                ])\n                .blue,\n            });\n\n          const task = await this.getTaskHandler()\n            .getTask(idTaskToConnectTo);\n\n          // We get the task\n          // Error if the task is not active\n          if (!task.isActive()) {\n            throw new Errors('E7009', `idTask: ${idTaskToConnectTo}`);\n          }\n\n          // Ask the connection to be made\n          const connection = task.connectToTask(idTaskToConnect, args);\n\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: Utils.monoline([\n                  `[${this.name}] Task N°${idTaskToConnect} correctly connected to Task `,\n                  `N°${idTaskToConnectTo} in Master`,\n                ])\n                .green,\n            });\n\n          return connection;\n        } catch (err) {\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: Utils.monoline([\n                  `[${this.name}] Task N°${idTaskToConnect} failed to be connected`,\n                  ` to Task N°${idTaskToConnectTo} in Master`,\n                ])\n                .red,\n            });\n\n          throw err;\n        }\n      },\n    });\n  }\n\n  /**\n   * Connect the second Task to the first one\n   * @param {String} identifierSlave - Identifier of the slave that host the idTaskToConnectTo\n   * @param {String} idTaskToConnectTo\n   * @param {String} idTaskToConnect\n   * @param {Object} args\n   */\n  connectTaskToTask(identifierSlave, idTaskToConnectTo, idTaskToConnect, args) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          identifierSlave,\n          isHeadBodyPattern: true,\n          messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CONNECT_TASK_TO_TASK,\n\n          messageBodyToSend: {\n            idTask: idTaskToConnectTo,\n            idTaskToConnect,\n            args,\n          },\n\n          messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CONNECT_TASK_TO_TASK,\n        });\n\n        // We get either an errors object or an error\n        if (ret === '') return ret;\n\n        throw ret;\n      },\n    });\n  }\n\n  /**\n   * Modify the status of the task attached to the given identifier\n   * (local data, have no impact in the real slave)\n   * @param {String} identifier\n   * @param {String} idTask\n   * @param {Boolean} status\n   */\n  modifyTaskStatusToSlaveLocalArray(identifier, idTask, status) {\n    this.slaves.some((x, xi) => {\n      if (x.programIdentifier === identifier) {\n        return x.tasks.some((y, yi) => {\n          if (y.id === idTask) {\n            this.slaves[xi].tasks[yi].isActive = status;\n\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * When called: Add a task to a slave\n   * @param {String} identifier\n   * @param {String} idTask\n   */\n  startTaskToSlave(identifier, idTask, args = {}) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          identifierSlave: identifier,\n          isHeadBodyPattern: true,\n          messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.START_TASK,\n\n          messageBodyToSend: {\n            idTask,\n            args,\n          },\n\n          messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.START_TASK,\n        });\n\n        // We get either an errors object or an error\n        if (ret === '') {\n          // Modify the task status for the given slave\n          this.modifyTaskStatusToSlaveLocalArray(identifier, idTask, true);\n\n          // Say something changed\n          this.somethingChangedAboutSlavesOrI();\n\n          return ret;\n        }\n\n        throw Errors.deserialize(ret);\n      },\n    });\n  }\n\n  /**\n   * List the existing slaves\n   */\n  listSlaves() {\n    return new PromiseCommandPattern({\n      func: () => this.master.getSlave(),\n    });\n  }\n\n  /**\n   * List a slave tasks using its identifier (Ask the slave to it)\n   * @param {String} identifier\n   */\n  distantListSlaveTask(identifier) {\n    return new PromiseCommandPattern({\n      func: () => this.sendMessageAndWaitForTheResponse({\n        identifierSlave: identifier,\n        isHeadBodyPattern: false,\n        messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS,\n        messageBodyToSend: {},\n        messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS,\n      }),\n    });\n  }\n\n  /**\n   * List a slave tasks using its identifier (Use local data to it)\n   * @param {String} identifier\n   */\n  listSlaveTask(identifier) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Look for the slave in confirmSlave\n        const slave = this.getSlaveByProgramIdentifier(identifier);\n\n        return slave.tasks;\n      },\n    });\n  }\n\n  /**\n   * Handle the fact the program state change\n   * We spread the data on our tasks and to our slaves\n   * @param {Number} programState\n   * @param {Number} oldProgramState\n   */\n  handleProgramStateChange(programState, oldProgramState) {\n    return new PromiseCommandPattern({\n      func: () => Promise.all([\n        // Spread to our tasks\n        this.getTaskHandler()\n        .applyNewProgramState(programState, oldProgramState),\n\n        // Spread to slaves\n        this.tellAllSlaveThatProgramStateChanged(programState, oldProgramState),\n\n        // The spread n slaves went well\n      ]),\n    });\n  }\n\n  /**\n   * Return only the slaves that are regular slaves (not CRON_EXECUTOR_ROLE for example)\n   */\n  getSlavesOnlyThatAreRegularSlaves() {\n    return this.slaves.filter(x => x.role.id === CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.id);\n  }\n\n  /**\n   * Tell all slave that the program state did change\n   *\n   * WARNING - DO NOT INCLUDE CRON_EXECUTOR_ROLE SLAVES INTO THE PIPE\n   *\n   * @param {Number} programState\n   * @param {Number} oldProgramState\n   */\n  tellAllSlaveThatProgramStateChanged(programState, oldProgramState) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n        return Promise.all(regularSlaves.map(x => this.tellASlaveThatProgramStateChanged(x.programIdentifier, programState, oldProgramState)));\n      },\n    });\n  }\n\n  /**\n   * Tell a slave that program state did change\n   * @param {String} slaveIdentifier\n   * @param {Number} programState\n   * @param {Number} oldProgramState\n   */\n  tellASlaveThatProgramStateChanged(slaveIdentifier, programState, oldProgramState) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          STATE_CHANGE,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          identifierSlave: slaveIdentifier,\n          isHeadBodyPattern: true,\n          messageHeaderToSend: STATE_CHANGE,\n\n          messageBodyToSend: {\n            programState,\n            oldProgramState,\n          },\n\n          messageHeaderToGet: STATE_CHANGE,\n          timeoutToGetMessage: RoleAndTask.getInstance()\n            .masterMessageWaitingTimeoutStateChange,\n        });\n\n        // We get either an errors object or an error\n        if (ret === '') return ret;\n\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `[${this.name}] program state get not spread in Slave N°${slaveIdentifier}`.red,\n          });\n\n        throw Errors.deserialize(ret);\n      },\n    });\n  }\n\n  /**\n   * When called: Remove an existing slave(s)\n   * @param {Array} identifiersSlaves\n   * @param {?Number} _i\n   */\n  removeExistingSlave(identifiersSlaves) {\n    return new PromiseCommandPattern({\n      func: () => Utils.promiseQueue([\n        // Close all slaves\n        ...identifiersSlaves.map(x => ({\n          functionToCall: this.sendMessageToSlave,\n\n          context: this,\n\n          args: [\n            x,\n            CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CLOSE,\n          ],\n        })),\n\n        // Say that something changed\n        {\n          functionToCall: this.somethingChangedAboutSlavesOrI,\n          context: this,\n        },\n      ]),\n    });\n  }\n\n  /**\n   * Kill a slave using its identifier\n   * @param {String} programIdentifier\n   */\n  killSlave(programIdentifier) {\n    // Look for the given identifier\n    this.consoleChildObjectPtr.filter((x) => {\n      if (x.programIdentifier === programIdentifier) {\n        try {\n          // Kill the process\n          process.kill(x.pid, CONSTANT.SIGNAL_UNPROPER.SIGUSR1);\n\n          // Remove the slave from the slave list\n          this.slaves = this.slaves.filter(y => !(y.programIdentifier === programIdentifier));\n        } catch (err) {\n          // Ignore the error, because the slave is dead anyway to us\n        }\n\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * When called: remove a task from slave\n   *\n   * THIS FUNCTION HAVE SPECIAL TIMEOUT FOR SLAVE ANSWER\n   *\n   * @param {String} identifier\n   * @param {String} idTask\n   * @param {Object} args\n   */\n  removeTaskFromSlave(identifier, idTask, args = {}) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          STOP_TASK,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `[${this.name}] Ask Slave N°${identifier} to stop the Task N°${idTask}`.blue,\n          });\n\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          identifierSlave: identifier,\n          isHeadBodyPattern: true,\n          messageHeaderToSend: STOP_TASK,\n\n          messageBodyToSend: {\n            idTask,\n            args,\n          },\n\n          messageHeaderToGet: STOP_TASK,\n          timeoutToGetMessage: RoleAndTask.getInstance()\n            .masterMessageWaitingTimeoutStopChange,\n        });\n\n        // We get either an errors object or an error\n        if (ret === '') {\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `[${this.name}] Task N°${idTask} correctly stopped in Slave N°${identifier}`.green,\n            });\n\n          // Modify the task status for the given slave\n          this.modifyTaskStatusToSlaveLocalArray(identifier, idTask, false);\n\n          return ret;\n        }\n\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `[${this.name}] Task N°${idTask} failed to be stopped to Slave N°${identifier}`.red,\n          });\n\n        throw ret;\n      },\n    });\n  }\n\n  /**\n   * Display a message directly\n   * @param {Object} param\n   */\n  displayMessage(param) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          // If we have the display task active, we give the message to it\n          if (RoleAndTask.getInstance()\n            .displayTask) {\n            const task = await this.getTaskHandler()\n              .getTask(RoleAndTask.getInstance()\n                .displayTask);\n\n            // If we disallow log display, stop it here\n            if (!RoleAndTask.getInstance()\n              .displayLog) {\n              return false;\n            }\n\n            if (task.isActive()) {\n              return task.displayMessage(param);\n            }\n          }\n\n          // If not we display\n          Utils.displayMessage(param);\n        } catch (err) {\n          // Ignore error - We can't display the data - it do not require further error treatment\n          // Store the message into file tho\n          Utils.displayMessage({\n            str: Errors.staticIsAnError(err) ? err.getErrorString() : String(err.stack || err),\n            out: process.stderr,\n          });\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * Start a new slave not in a console but in a regular process\n   * @param {{opts: String, uniqueSlaveId: String}} slaveOpts\n   * @param {Object} specificOpts - (Spawn options)\n   * @param {String} connectionTimeout\n   */\n  startNewSlaveInProcessMode(slaveOpts, specificOpts, connectionTimeout) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        // We create a unique Id that will referenciate the slave at the connexion\n        const uniqueSlaveId = (slaveOpts && slaveOpts.uniqueSlaveId) || Utils.generateUniqueProgramID();\n\n        // Options to send to the new created slave\n        const programOpts = (slaveOpts && slaveOpts.opts) || [\n          `--${CONSTANT.PROGRAM_LAUNCHING_PARAMETERS.MODE.name}`,\n          `${CONSTANT.PROGRAM_LAUNCHING_MODE.SLAVE}`,\n          `--${CONSTANT.PROGRAM_LAUNCHING_PARAMETERS.MODE_OPTIONS.name}`,\n          `${CONSTANT.SLAVE_START_ARGS.IDENTIFIER}=${uniqueSlaveId}`,\n        ];\n\n        // Options to give to fork(...)\n        const forkOpts = {};\n\n        // If there is no path to the entry file to execute\n        if (!this.pathToEntryFile) {\n          throw new Errors('EXXXX', 'Cannot start the slave : No pathToEntryFile configured');\n        }\n\n        // Path that lead to the exe of PROGRAM\n        const pathToExec = this.pathToEntryFile;\n\n        // LaunchScenarios program in slave mode in a different process\n        const child = childProcess.fork(pathToExec, programOpts, forkOpts);\n\n        // LaunchScenarios a timeout of connection\n        const timeoutConnection = setTimeout(() => {\n          // Kill the process we did created\n          child.kill(CONSTANT.SIGNAL_TO_KILL_SLAVE_COMMAND);\n\n          return reject(new Errors('E7003', `Timeout ${connectionTimeout} ms passed`));\n        }, connectionTimeout);\n\n        // Look at error event (If it get fired it means the program failed to get launched)\n        // Handle the fact a child can result an error later on after first connection\n        // Error detected\n        child.on('error', err => reject(new Errors('E7003', `Exit Code: ${err}`)));\n\n        // Handle the fact a child get closed\n        // The close can be wanted, or not\n        child.on('close', (code) => {\n          // No error\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `Slave Close: ${code}`.red,\n            });\n        });\n\n        // Handle the fact a child exit\n        // The exit can be wanted or not\n        child.on('exit', (code) => {\n          // No error\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `Slave Exit: ${code}`.red,\n            });\n        });\n\n        // Now we need to look at communicationSystem of the master to know if the new slave connect to PROGRAM\n        // If we pass a connection timeout time, we kill the process we just created and return an error\n        const connectEvent = (slaveInfos) => {\n          // Wait for a new client with the identifier like -> uniqueSlaveId_processId\n          if (slaveInfos && slaveInfos.programIdentifier === uniqueSlaveId) {\n            // We got our slave working well\n            clearTimeout(timeoutConnection);\n            this.unlistenSlaveConnectionEvent(connectEvent);\n\n            // Store the child data\n            this.consoleChildObjectPtr.push({\n              programIdentifier: uniqueSlaveId,\n              pid: slaveInfos.clientPID,\n            });\n\n            return resolve({\n              ...slaveInfos,\n              pid: slaveInfos.clientPID,\n            });\n          }\n\n          // This is not our slave\n\n          return false;\n        };\n\n        this.listenSlaveConnectionEvent(connectEvent);\n      }),\n    });\n  }\n\n  /**\n   * Tell one task about what changed in the architecture\n   */\n  tellOneTaskAboutArchitectureChange(idTask) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          const task = await this.getTaskHandler()\n            .getTask(idTask);\n\n          // Can't find the task  so -> don't tell a new archiecture is here\n          if (!task) return;\n\n          if (task.isActive()) {\n            // Tell HandleProgramTask about new conf\n            task.dynamicallyRefreshDataIntoList({\n              notConfirmedSlaves: this.notConfirmedSlaves,\n              confirmedSlaves: this.slaves,\n\n              master: {\n                tasks: this.getTaskHandler()\n                  .getTaskListStatus(),\n                communication: this.getCommunicationSystem(),\n                ips: Utils.givesLocalIps(),\n                cpuAndMemory: this.cpuUsageAndMemory,\n                tasksInfos: this.tasksInfos,\n              },\n            });\n          }\n        } catch (e) {\n          // Don't od anything because it's not an error\n        }\n      },\n    });\n  }\n\n  /**\n   * Do something when an information changed about PROGRAM architecture\n   */\n  somethingChangedAboutSlavesOrI() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Look at all tasks\n        await Promise.all(RoleAndTask.getInstance()\n          .tasks.filter(x => x.notifyAboutArchitectureChange)\n          .map(x => this.tellOneTaskAboutArchitectureChange(x.id)));\n      },\n    });\n  }\n\n  /**\n   * When called : start a new slave\n   * Take options in parameters or start a regular slave\n   *\n   * @param {{opts: String, uniqueSlaveId: String}} slaveOpts\n   * @param {Object} specificOpts - (Spawn options)\n   * @param {String} connectionTimeout\n   */\n  startNewSlave(slaveOpts, specificOpts, connectionTimeout = CONSTANT.SLAVE_CREATION_CONNECTION_TIMEOUT) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const ret = await this.startNewSlaveInProcessMode(slaveOpts, specificOpts, connectionTimeout);\n\n        // Say something changed\n        await this.somethingChangedAboutSlavesOrI();\n\n        return ret;\n      },\n    });\n  }\n\n  /**\n   * Send a message that match head/body pattern\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * @param {String} programIdentifier\n   * @param {String} headString\n   * @param {String} bodyString\n   */\n  sendMessageToSlaveHeadBodyPattern(programIdentifier, headString, bodyString) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Build up the message\n        const message = {\n          [CONSTANT.PROTOCOL_KEYWORDS.HEAD]: headString,\n          [CONSTANT.PROTOCOL_KEYWORDS.BODY]: bodyString,\n        };\n\n        // Send the message\n        return this.sendMessageToSlave(programIdentifier, JSON.stringify(message));\n      },\n    });\n  }\n\n  /**\n   * Send a message to a slave using an programIdentifier\n   * @param {String} programIdentifier\n   * @param {String} message\n   */\n  sendMessageToSlave(programIdentifier, message) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Look for the slave in confirmSlave\n        const slave = this.getSlaveByProgramIdentifier(programIdentifier);\n\n        // Send the message\n        this.getCommunicationSystem()\n          .sendMessageToClient(slave.clientIdentityByte, slave.clientIdentityString, message);\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Get a slave using its program id\n   * @param {String} programIdentifier\n   */\n  getSlaveByProgramIdentifier(programIdentifier) {\n    // Look for the slave in confirmSlave\n    const slave = this.slaves.find(x => x.programIdentifier === programIdentifier);\n\n    return slave || new Errors('E7004', `Identifier: ${programIdentifier}`);\n  }\n\n  /**\n   * Using the programIdentifier, wait a specific incoming message from a specific slave\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * If there is no answer before the timeout, stop waiting and send an error\n   * @param {String} headString\n   * @param {String} programIdentifier\n   * @param {Number} timeout - in ms\n   */\n  getMessageFromSlave(headString, programIdentifier, timeout = RoleAndTask.getInstance()\n    .masterMessageWaitingTimeout) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        let timeoutFunction = false;\n\n        // Look for the slave in confirmSlave\n        const slave = this.getSlaveByProgramIdentifier(programIdentifier);\n\n        // Function that will receive messages from slaves\n        const msgListener = (clientIdentityByte, clientIdentityString, dataString) => {\n          // Check the identifier to be the one we are waiting a message for\n\n          if (clientIdentityString === slave.clientIdentityString) {\n            const dataJSON = Utils.convertStringToJSON(dataString);\n\n            // Here we got all messages that comes from clients (so slaves)\n            // Check if the message answer particular message\n            if (dataJSON && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] &&\n              dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] === headString) {\n              // Stop the timeout\n              clearTimeout(timeoutFunction);\n\n              // Stop the listening\n              this.getCommunicationSystem()\n                .unlistenToIncomingMessage(msgListener);\n\n              // We get our message\n              return resolve(dataJSON[CONSTANT.PROTOCOL_KEYWORDS.BODY]);\n            }\n          }\n\n          return false;\n        };\n\n        // If the function get triggered, we reject an error\n        timeoutFunction = setTimeout(() => {\n          // Stop the listening\n          this.getCommunicationSystem()\n            .unlistenToIncomingMessage(msgListener);\n\n          // Return an error\n          return reject(new Errors('E7005'));\n        }, timeout);\n\n        // Listen to incoming messages\n        return this.getCommunicationSystem()\n          .listenToIncomingMessage(msgListener);\n      }),\n    });\n  }\n\n  /**\n   * Send the cpu load to the server periodically\n   */\n  infiniteGetCpuAndMemory() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        if (this.intervalFdCpuAndMemory) return;\n\n        if (CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME) {\n          // When we connect, we send our infos to the master\n          this.intervalFdCpuAndMemory = setInterval(async () => {\n            try {\n              const cpuAndMemory = await Utils.getCpuAndMemoryLoad();\n\n              this.cpuUsageAndMemory = cpuAndMemory;\n\n              // Say something change\n              this.somethingChangedAboutSlavesOrI();\n\n              if (!this.active && this.intervalFdCpuAndMemory) {\n                clearInterval(this.intervalFdCpuAndMemory);\n\n                this.intervalFdCpuAndMemory = false;\n              }\n            } catch (err) {\n              RoleAndTask.getInstance()\n                .errorHappened(err);\n            }\n          }, CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME);\n        }\n      },\n    });\n  }\n\n  /**\n   * Get periodically the infos about tasks running in master\n   */\n  infiniteGetTasksInfos() {\n    if (this.intervalFdTasksInfos) return;\n\n    this.intervalFdTasksInfos = setInterval(async () => {\n      try {\n        const infos = await this.taskHandler.getInfosFromAllActiveTasks();\n\n        this.tasksInfos = infos;\n\n        this.somethingChangedAboutSlavesOrI();\n\n        // If the role is still active we call it back\n        if (!this.active && this.intervalFdTasksInfos) {\n          clearInterval(this.intervalFdTasksInfos);\n\n          this.intervalFdTasksInfos = false;\n        }\n      } catch (err) {\n        RoleAndTask.getInstance()\n          .errorHappened(err);\n      }\n    }, CONSTANT.SLAVES_INFOS_CHANGE_TIME);\n  }\n\n  /**\n   * PROGRAM start to play the role\n   *\n   * A master is defined as:\n   * A master have a Server ZeroMQ open\n   * A master is connected to Slaves\n   *\n   * pathToEntryFile is the path we will use to start new slaves\n   *\n   * @param {Object} args\n   * @override\n   */\n  start({\n    ipServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_ADDRESS,\n    portServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_PORT,\n  }) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Reinitialize some properties\n        this.initProperties();\n\n        // Create the OMQ Server\n        this.communicationSystem = new ZeroMQServerRouter();\n\n        // Start the communication system\n        await this.communicationSystem.start({\n          ipServer,\n          portServer,\n          transport: CONSTANT.ZERO_MQ.TRANSPORT.IPC,\n        });\n\n        this.active = true;\n\n        this.protocolMasterSlave();\n\n        // Say something changed\n        this.somethingChangedAboutSlavesOrI();\n\n        // LaunchScenarios an infite get of cpu usage to give to handleProgramTask\n        this.infiniteGetCpuAndMemory();\n\n        // LaunchScenarios an infite get of tasks infos to give to handleProgramTask\n        this.infiniteGetTasksInfos();\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Get the hierarchy level of the given task\n   */\n  static getHierarchyLevelByIdTask(computeListClosure, idTask) {\n    let toRet;\n\n    computeListClosure.some((x) => {\n      if (x.idTask === idTask) {\n        toRet = x.closureHierarchy;\n\n        return true;\n      }\n\n      return false;\n    });\n\n    return toRet;\n  }\n\n  /**\n   * Sort the array ASC by closureHierarchy\n   */\n  static sortArray(ptr) {\n    const arr = ptr;\n\n    for (let i = 0; i < (arr.length - 1); i += 1) {\n      if (arr[i].closureHierarchy > arr[i + 1].closureHierarchy) {\n        const tmp = arr[i + 1];\n\n        arr[i + 1] = arr[i];\n\n        arr[i] = tmp;\n\n        i = -1;\n      }\n    }\n\n    return arr;\n  }\n\n  /**\n   * This methods return the task we need to stop first\n   * There is an hierarchie in tasks closure\n   */\n  chooseWhichTaskToStop() {\n    const tasksMaster = this.getTaskHandler()\n      .getTaskListStatus();\n\n    // Compute a list in order of tasksID to close (following the closure hierarchy)\n    const computeListClosure = Master1_0.sortArray(tasksMaster.map(x => ({\n      idTask: x.id,\n      closureHierarchy: x.closureHierarchy,\n    })));\n\n    // Now look at slaves tasks, then master task, about the task that is the higher in closure hierarchy\n    const ret = {\n      idTaskToRemove: false,\n      isMasterTask: false,\n      isSlaveTask: false,\n      identifierSlave: false,\n      hierarchyLevel: false,\n      args: {},\n    };\n\n    const foundHighestInHierarchy = this.slaves.some(x => x.tasks.some((y) => {\n      // Look at the hierarchy level of the given task\n      const hierarchyY = Master1_0.getHierarchyLevelByIdTask(computeListClosure, y.id);\n\n      if (!y.isActive) return false;\n\n      // Look if this hierarchy is higher than the save one\n      if (ret.hierarchyLevel === false || (ret.hierarchyLevel > hierarchyY)) {\n        // Save the task to be the one that get to be removed (for now!)\n        ret.hierarchyLevel = hierarchyY;\n        ret.idTaskToRemove = y.id;\n        ret.isSlaveTask = true;\n        ret.isMasterTask = false;\n        ret.identifierSlave = x.programIdentifier;\n\n        // If the task we have is the highest in hierarchy, no need to look furthers\n        if (computeListClosure.length && hierarchyY === computeListClosure[0].closureHierarchy) return true;\n      }\n\n      return false;\n    }));\n\n    if (foundHighestInHierarchy) return ret;\n\n    // We didn't found the higest task in the hierarchy so look at master tasks, its maybe there\n    tasksMaster.some((x) => {\n      const hierarchyX = Master1_0.getHierarchyLevelByIdTask(computeListClosure, x.id);\n\n      if (!x.isActive) return false;\n\n      // Look if this hierarchy is higher than the save one\n      if (ret.hierarchyLevel === false || (ret.hierarchyLevel > hierarchyX)) {\n        // Save the task to be the one that get to be removed (for now!)\n        ret.hierarchyLevel = hierarchyX;\n        ret.idTaskToRemove = x.id;\n        ret.isSlaveTask = false;\n        ret.isMasterTask = true;\n        ret.identifierSlave = false;\n\n        // If the task we have is the highest in hierarchy, no need to look furthers\n        if (computeListClosure.length && hierarchyX === computeListClosure[0].closureHierarchy) return true;\n      }\n      return false;\n    });\n\n    return ret;\n  }\n\n  /**\n   * Stop all tasks on every slave and master following a specific closure order\n   * (Some tasks must be closed before/after some others)\n   *\n   * WARNING RECURSIVE CALL\n   */\n  stopAllTaskOnEverySlaveAndMaster() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // close one of the task\n        // master or slave task\n        const {\n          idTaskToRemove,\n          isMasterTask,\n          isSlaveTask,\n          identifierSlave,\n          args,\n        } = this.chooseWhichTaskToStop();\n\n        // No more task to stop\n        if (idTaskToRemove === false) {\n          // Say something changed\n          this.somethingChangedAboutSlavesOrI();\n\n          return true;\n        }\n\n        if (isMasterTask) {\n          await this.getTaskHandler()\n            .stopTask(idTaskToRemove, args);\n\n          // Call next\n          return this.stopAllTaskOnEverySlaveAndMaster();\n        }\n\n        if (isSlaveTask) {\n          await this.removeTaskFromSlave(identifierSlave, idTaskToRemove, args);\n\n          // Call next\n          return this.stopAllTaskOnEverySlaveAndMaster();\n        }\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * PROGRAM stop to play the role\n   * @param {Object} args\n   * @override\n   */\n  stop() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Say bye to every slaves\n        await this.stopAllTaskOnEverySlaveAndMaster();\n\n        await this.removeExistingSlave(this.slaves.map(x => x.programIdentifier));\n\n        // Stop the infinite loops\n        if (this.intervalFdCpuAndMemory) clearInterval(this.intervalFdCpuAndMemory);\n\n        if (this.intervalFdTasksInfos) clearInterval(this.intervalFdTasksInfos);\n\n        // Stop the communication system\n        await this.communicationSystem.stop();\n\n        this.active = false;\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Send the given message and wait for the response\n   *\n   * HERE WE CREATE TWO EXECUTIONS LIFES\n   *\n   * Put isHeadBodyPattern = true if you want to use the headBodyPattern\n   *\n   * @param {Object} args\n   */\n  sendMessageAndWaitForTheResponse({\n    identifierSlave,\n    messageHeaderToSend,\n    messageBodyToSend,\n    messageHeaderToGet,\n    isHeadBodyPattern,\n\n    // Can be equals to undefined -> default timeout\n    timeoutToGetMessage,\n  }) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        // We switch to the appropriated func\n        const sendMessageGoodFunc = () => {\n          if (isHeadBodyPattern) return this.sendMessageToSlaveHeadBodyPattern;\n\n          return this.sendMessageToSlave;\n        };\n\n        let errAlreadyReturned = false;\n\n        // Be ready to get the message from the slave before to send it the command\n        this.getMessageFromSlave(messageHeaderToGet, identifierSlave, timeoutToGetMessage)\n          // Job done\n          .then(resolve)\n          .catch((err) => {\n            if (!errAlreadyReturned) {\n              errAlreadyReturned = true;\n\n              return reject(err);\n            }\n\n            return false;\n          });\n\n        // Send the command to the slave\n        sendMessageGoodFunc()\n          .call(this, identifierSlave, messageHeaderToSend, messageBodyToSend)\n          .then(() => {\n            // It went well, no wait getMessageFromSlave to get the message\n            // If the message is not coming, getMessageFromSlave will timeout and result of an error\n\n            //\n            // Nothing to do here anymore Mate!\n            //\n          })\n          .catch((err) => {\n            // The getMessageFromSlave will automatically timeout\n            if (!errAlreadyReturned) {\n              errAlreadyReturned = true;\n\n              return reject(err);\n            }\n\n            return false;\n          });\n      }),\n    });\n  }\n}\n"],"file":"Master1_0.js"}