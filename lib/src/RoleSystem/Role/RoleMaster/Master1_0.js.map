{"version":3,"sources":["../../../../../src/RoleSystem/Role/RoleMaster/Master1_0.es6"],"names":["instance","Master1_0","name","CONSTANT","DEFAULT_ROLES","MASTER_ROLE","id","pathToEntryFile","tasks","RoleAndTask","getInstance","getRoleTasks","setTaskHandler","TaskHandler","initProperties","communicationSystem","slaves","notConfirmedSlaves","consoleChildObjectPtr","newConnectionListeningFunction","newDisconnectionListeningFunction","cpuUsageAndMemory","tasksInfos","mutexes","func","filter","x","context","push","clientIdentityByte","clientIdentityString","body","regularSlaves","getSlavesOnlyThatAreRegularSlaves","limitToTaskList","forEach","some","y","isActive","includes","sendMessageToSlaveHeadBodyPattern","eliotIdentifier","PROTOCOL_MASTER_SLAVE","MESSAGES","GENERIC_CHANNEL_DATA","spreadDataToEveryLocalTask","data","sendDataToEveryELIOTTaskWhereverItIsLowLevel","err","slave","find","error","somethingChangedAboutSlavesOrI","Error","Utils","displayMessage","str","String","stack","out","process","stderr","changeEliotState","DEFAULT_STATES","ERROR","tellHandleEliotTaskAboutSlaveError","getMakesErrorFatal","exitEliotUnproperDueToError","console","customFunctions","getMasterMutexFunctions","funcTake","funcRelease","TAKE_MUTEX","serialize","RELEASE_MUTEX","ASK_DATABASE_CONNECTION_CHANGE","askForDatabaseConnectionChange","newLogsToApply","all","map","sendMessageAndWaitForTheResponse","identifierSlave","isHeadBodyPattern","messageHeaderToSend","CHANGE_DATABASE_CONNECTION","messageBodyToSend","messageHeaderToGet","rets","changeDatabaseConnection","PROTOCOL_KEYWORDS","HEAD","BODY","SLAVE_CONFIRMATION_INFORMATIONS","OUTPUT_TEXT","INFOS_ABOUT_SLAVES","ERROR_HAPPENED","getCommunicationSystem","listenClientConnectionEvent","split","clientPID","cyan","closeConnectionToClient","sendMessageToClient","listenClientDisconnectionEvent","red","fireUp","confirmSlave","dataJSON","index","findIndex","role","splice","listenToIncomingMessage","dataString","convertStringToJSON","checkFunc","applyFunc","infosAboutSlaveIncomming","errorHappenedIntoSlave","protocolTakeMutex","protocolReleaseMutex","protocolHandleDatabaseConnectionChangeAsk","notConfirmedSlave","ptr","moreInfos","resolve","pid","idTaskToConnectTo","idTaskToConnect","args","monoline","blue","getTaskHandler","getTask","task","connection","connectToTask","green","CONNECT_TASK_TO_TASK","idTask","ret","identifier","status","xi","yi","START_TASK","modifyTaskStatusToSlaveLocalArray","master","getSlave","LIST_TASKS","getSlaveByEliotIdentifier","eliotState","oldEliotState","applyNewEliotState","tellAllSlaveThatEliotStateChanged","SLAVE_ROLE","tellASlaveThatEliotStateChanged","slaveIdentifier","STATE_CHANGE","timeoutToGetMessage","MASTER_MESSAGE_WAITING_TIMEOUT_STATE_CHANGE","identifiersSlaves","promiseQueue","functionToCall","sendMessageToSlave","CLOSE","kill","SIGNAL_UNPROPER","SIGUSR1","STOP_TASK","MASTER_MESSAGE_WAITING_TIMEOUT_STOP_TASK","param","displayTask","getDisplayLog","slaveOpts","specificOpts","connectionTimeout","reject","uniqueSlaveId","generateUniqueEliotID","eliotOpts","opts","ELIOT_LAUNCHING_PARAMETERS","MODE","ELIOT_LAUNCHING_MODE","SLAVE","MODE_OPTIONS","SLAVE_START_ARGS","IDENTIFIER","forkOpts","pathToExec","child","childProcess","fork","timeoutConnection","setTimeout","SIGNAL_TO_KILL_SLAVE_COMMAND","on","code","connectEvent","slaveInfos","clearTimeout","unlistenSlaveConnectionEvent","listenSlaveConnectionEvent","dynamicallyRefreshDataIntoList","confirmedSlaves","getTaskListStatus","communication","ips","givesLocalIps","cpuAndMemory","notifyAboutArchitectureChange","tellOneTaskAboutArchitectureChange","SLAVE_CREATION_CONNECTION_TIMEOUT","startNewSlaveInProcessMode","headString","bodyString","message","timeout","MASTER_MESSAGE_WAITING_TIMEOUT","timeoutFunction","msgListener","unlistenToIncomingMessage","intervalFdCpuAndMemory","DISPLAY_CPU_MEMORY_CHANGE_TIME","setInterval","getCpuAndMemoryLoad","active","clearInterval","errorHappened","intervalFdTasksInfos","taskHandler","getInfosFromAllActiveTasks","infos","SLAVES_INFOS_CHANGE_TIME","ipServer","ZERO_MQ","DEFAULT_SERVER_IP_ADDRESS","portServer","DEFAULT_SERVER_IP_PORT","ZeroMQServerRouter","start","transport","TRANSPORT","IPC","protocolMasterSlave","infiniteGetCpuAndMemory","infiniteGetTasksInfos","tasksMaster","computeListClosure","sortArray","closureHierarchy","idTaskToRemove","isMasterTask","isSlaveTask","hierarchyLevel","foundHighestInHierarchy","hierarchyY","getHierarchyLevelByIdTask","length","hierarchyX","chooseWhichTaskToStop","stopTask","stopAllTaskOnEverySlaveAndMaster","removeTaskFromSlave","removeExistingSlave","stop","sendMessageGoodFunc","errAlreadyReturned","getMessageFromSlave","then","catch","call","toRet","arr","i","tmp","AMaster"],"mappings":"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","file":"Master1_0.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport childProcess from 'child_process';\nimport AMaster from './AMaster.js';\nimport CONSTANT from '../../../Utils/CONSTANT/CONSTANT.js';\nimport TaskHandler from '../../Handlers/TaskHandler.js';\nimport ZeroMQServerRouter from '../../../CommunicationSystem/SocketCommunicationSystem/ZeroMQ/Server/Implementations/ZeroMQServerRouter.js';\nimport Utils from '../../../Utils/Utils.js';\nimport RoleAndTask from '../../../RoleAndTask.js';\n\nlet instance = null;\n\n/**\n * Define the Role of Master which have a job of manager.\n *\n * Manage Slaves.\n */\nexport default class Master1_0 extends AMaster {\n  constructor() {\n    super();\n\n    if (instance) return instance;\n\n    this.name = CONSTANT.DEFAULT_ROLES.MASTER_ROLE.name;\n    this.id = CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id;\n\n    this.pathToEntryFile = false;\n\n    // Get the tasks related to the master role\n    const tasks = RoleAndTask.getInstance()\n      .getRoleTasks(CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id);\n\n    // Define all tasks handled by this role\n    this.setTaskHandler(new TaskHandler(tasks));\n\n    this.initProperties();\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * Init the properties\n   */\n  initProperties() {\n    // Define none communicationSystem for now\n    this.communicationSystem = false;\n\n    // Array of current approved slaves\n    this.slaves = [];\n\n    // Array of slaves that are in the confirmation process\n    this.notConfirmedSlaves = [];\n\n    // Array that contains the relation between console process ptr and eliotIdentifier\n    // We use it too when there is no console launch, because it work with both soluce\n    this.consoleChildObjectPtr = [];\n\n    // Functions called when something happend to a slave connection\n    this.newConnectionListeningFunction = [];\n    this.newDisconnectionListeningFunction = [];\n\n    // Data we keep as attribute to give to handleEliotTask later\n    this.cpuUsageAndMemory = false;\n    this.tasksInfos = false;\n\n    // Store the mutexes here, we use to avoid concurrency between slaves on specific actions\n    this.mutexes = {};\n  }\n\n  /**\n   * Get the communicationSystem\n   */\n  getCommunicationSystem() {\n    return this.communicationSystem;\n  }\n\n  /**\n   * SINGLETON implementation\n   * @override\n   */\n  static getInstance() {\n    return instance || new Master1_0();\n  }\n\n  /**\n   * Pull a function that get fired when a slave get connected\n   */\n  unlistenSlaveConnectionEvent(func) {\n    this.newConnectionListeningFunction = this.newConnectionListeningFunction.filter(x => x.func !== func);\n  }\n\n  /**\n   * Pull a function that get fired when a slave get disconnected\n   */\n  unlistenSlaveDisconnectionEvent(func) {\n    this.newDisconnectionListeningFunction = this.newDisconnectionListeningFunction.filter(x => x.func !== func);\n  }\n\n  /**\n   * Push a function that get fired when a slave get connected\n   */\n  listenSlaveConnectionEvent(func, context) {\n    this.newConnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Push a function that get fired when a slave get disconnected\n   */\n  listenSlaveDisconnectionEvent(func) {\n    this.newDisconnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Return the array that contains non-confirmed slaves\n   */\n  getNonConfirmedSlaves() {\n    return this.notConfirmedSlaves;\n  }\n\n  /**\n   *  Get an array that contains confirmed slaves\n   */\n  getSlaves() {\n    return this.slaves;\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks and our tasks\n   *\n   * WARNING - DO NOT SEND IT TO NON-REGULAR SLAVES (CRON_EXECUTOR_ROLE FOR EXAMPLE)\n   *\n   * @param {[Byte]} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {Object} data\n   */\n  sendDataToEveryELIOTTaskWhereverItIsLowLevel(clientIdentityByte, clientIdentityString, body) {\n    const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n    // Open the body to get the list of tasks we limit the spread on\n    const {\n      limitToTaskList,\n    } = body;\n\n\n    // For each slave\n    regularSlaves.forEach((x) => {\n      // Only send the data to the slaves that holds a tasks that need to know about the message\n      if (!limitToTaskList || x.tasks.some(y => y.isActive && limitToTaskList.includes(y.id))) {\n        // Send a message to every running slaves\n        this.sendMessageToSlaveHeadBodyPattern(x.eliotIdentifier, CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.GENERIC_CHANNEL_DATA, body);\n      }\n    });\n\n    // For itself tasks\n    RoleAndTask.getInstance()\n      .spreadDataToEveryLocalTask(body);\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks and our tasks\n   */\n  sendDataToEveryELIOTTaskWhereverItIs(data) {\n    this.sendDataToEveryELIOTTaskWhereverItIsLowLevel(false, false, data);\n  }\n\n  /**\n   * Tell the handleEliotTask about something happend in slaves\n   */\n  tellHandleEliotTaskAboutSlaveError(clientIdentityString, err) {\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    if (!slave) return;\n\n    slave.error = err;\n    this.somethingChangedAboutSlavesOrI();\n  }\n\n  /**\n   * An error happended into a slave, what do we do?\n   * @param {Array} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {String} body\n   */\n  async errorHappenedIntoSlave(clientIdentityByte, clientIdentityString) {\n    // const err = Errors.deserialize(body);\n    const err = new Error('Deserialized');\n\n    // Display the error\n    Utils.displayMessage({\n      str: String((err && err.stack) || err),\n      out: process.stderr,\n    });\n\n    try {\n      // Get the client that got the problem\n      // We try to change the eliot state to error\n      await RoleAndTask.getInstance()\n        .changeEliotState(CONSTANT.DEFAULT_STATES.ERROR.id);\n\n      // We goodly changed the eliot state\n      // Add informations on error\n\n      Utils.displayMessage({\n        str: String((err && err.stack) || err),\n        out: process.stderr,\n      });\n\n      // Tell the task handleEliot that there had been an error for the slave\n      this.tellHandleEliotTaskAboutSlaveError(clientIdentityString, err);\n\n      // If the errors are supposed to be fatal, exit!\n      if (RoleAndTask.getInstance()\n        .getMakesErrorFatal()) {\n        RoleAndTask.exitEliotUnproperDueToError();\n      }\n      // We leave the process because something get broken\n    } catch (errNested) {\n      Utils.displayMessage({\n        str: 'Exit eliot unproper ERROR HAPPENED IN SLAVE',\n        out: process.stderr,\n      });\n\n      Utils.displayMessage({\n        str: String((errNested && errNested.stack) || errNested),\n        out: process.stderr,\n      });\n\n      RoleAndTask.exitEliotUnproperDueToError();\n    }\n  }\n\n  /**\n   * In master/slave protocol, we ask to get a token. We get directly asked as the master\n   */\n  async takeMutex(id) {\n    console.error(`Master: takeToken : ${id} : START`);\n\n    // The mutex has already been taken\n    if (this.mutexes[id]) {\n      console.error(new Error('E7024'));\n\n      throw new Error('E7024');\n    }\n\n    // Custom function to call when taking or releasing the mutex (if one got set by the user)\n    // If the function throw, we do not take the token\n    const customFunctions = RoleAndTask.getInstance()\n      .getMasterMutexFunctions()\n      .find(x => x.id === id);\n\n    if (customFunctions && customFunctions.funcTake) {\n      await customFunctions.funcTake();\n    }\n\n    this.mutexes[id] = true;\n\n    console.error(`Master: takeToken : ${id} : DONE`);\n  }\n\n  /**\n   * In master/slave protocol, we ask to release the token. We get directly asked as the master.\n   */\n  async releaseMutex(id) {\n    // Custom function to call when taking or releasing the mutex (if one got set by the user)\n    // If the function throw, we do not take the token\n    const customFunctions = RoleAndTask.getInstance()\n      .getMasterMutexFunctions()\n      .find(x => x.id === id);\n\n    if (customFunctions && customFunctions.funcRelease) {\n      await customFunctions.funcRelease();\n    }\n\n    this.mutexes[id] = false;\n  }\n\n  /**\n   * Take the mutex behind the given ID if it's available\n   */\n  async protocolTakeMutex(clientIdentityByte, clientIdentityString, body) {\n    const {\n      TAKE_MUTEX,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    console.error(`Protocol master : takeToken : ${body.id} : START`);\n\n    // Det the slave that asked\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    try {\n      // The mutex has already been taken\n      if (this.mutexes[body.id]) {\n        console.error(new Error('E7024'));\n        throw new Error('E7024');\n      }\n\n      // Custom function to call when taking or releasing the mutex (if one got set by the user)\n      // If the function throw, we do not take the token\n      const customFunctions = RoleAndTask.getInstance()\n        .getMasterMutexFunctions()\n        .find(x => x.id === body.id);\n\n      if (customFunctions && customFunctions.funcTake) {\n        await customFunctions.funcTake();\n      }\n\n      this.mutexes[body.id] = true;\n\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, TAKE_MUTEX, JSON.stringify({\n        error: false,\n      }));\n\n      console.error(`Protocol master: takeToken : ${body.id} : DONE`);\n    } catch (err) {\n      console.error(`Protocol master: takeToken : ${body.id} : ERROR`);\n\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, TAKE_MUTEX, JSON.stringify({\n        error: err.serialize(),\n      }));\n    }\n  }\n\n  /**\n   * Release the mutex behind the given ID\n   */\n  async protocolReleaseMutex(clientIdentityByte, clientIdentityString, body) {\n    const {\n      RELEASE_MUTEX,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    // Det the slave that asked\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    try {\n      // Custom function to call when taking or releasing the mutex (if one got set by the user)\n      // If the function throw, we do not take the token\n      const customFunctions = RoleAndTask.getInstance()\n        .getMasterMutexFunctions()\n        .find(x => x.id === body.id);\n\n      if (customFunctions && customFunctions.funcRelease) {\n        await customFunctions.funcRelease();\n      }\n\n      this.mutexes[body.id] = false;\n\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, RELEASE_MUTEX, JSON.stringify({\n        error: false,\n      }));\n    } catch (err) {\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, RELEASE_MUTEX, JSON.stringify({\n        error: err.serialize(),\n      }));\n    }\n  }\n\n  /**\n   * Handle a slave that ask for database connection change\n   * @param {Array} clientIdentityByte\n   * @param {String} clientIdentityString\n   */\n  async protocolHandleDatabaseConnectionChangeAsk(clientIdentityByte, clientIdentityString, body) {\n    const {\n      ASK_DATABASE_CONNECTION_CHANGE,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    try {\n      await RoleAndTask.getInstance()\n        .askForDatabaseConnectionChange(body);\n\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, ASK_DATABASE_CONNECTION_CHANGE, JSON.stringify({\n        error: false,\n      }));\n    } catch (err) {\n      this.sendMessageToSlaveHeadBodyPattern(slave.eliotIdentifier, ASK_DATABASE_CONNECTION_CHANGE, JSON.stringify({\n        error: err.serialize(),\n      }));\n    }\n  }\n\n  /**\n   * Ask every slave to perform a connection data change and do it yourself\n   */\n  async askForDatabaseConnectionChange(newLogsToApply) {\n    const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n    // For each slave\n    // Send a message to every running slaves\n    const rets = await Promise.all(regularSlaves.map(x => this.sendMessageAndWaitForTheResponse({\n      identifierSlave: x.eliotIdentifier,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CHANGE_DATABASE_CONNECTION,\n      messageBodyToSend: newLogsToApply,\n      messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CHANGE_DATABASE_CONNECTION,\n    })));\n\n    // We get either an errors object or an error\n    if (rets.some(x => x !== '')) {\n      // We got an error\n      return rets.find(x => x !== '');\n    }\n\n    // We change our own database connection\n    await RoleAndTask.getInstance()\n      .changeDatabaseConnection(newLogsToApply);\n\n    return false;\n  }\n\n  /**\n   * Define the master/slave basic protocol\n   * (Authentification)\n   */\n  protocolMasterSlave() {\n    // Shortcuts\n    const {\n      HEAD,\n      BODY,\n    } = CONSTANT.PROTOCOL_KEYWORDS;\n\n    const {\n      SLAVE_CONFIRMATION_INFORMATIONS,\n      GENERIC_CHANNEL_DATA,\n      OUTPUT_TEXT,\n      INFOS_ABOUT_SLAVES,\n      ERROR_HAPPENED,\n      ASK_DATABASE_CONNECTION_CHANGE,\n      TAKE_MUTEX,\n      RELEASE_MUTEX,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    // Listen at new Socket connection\n    //\n    // 1/ Check if the new slave have a correct identifier\n    // 2/ Ask the slave for running tasks\n    // 3/ Get the slave answer\n    // 4/ Add the slave into handled slave\n    //\n    this.getCommunicationSystem()\n      .listenClientConnectionEvent((clientIdentityByte, clientIdentityString) => {\n        const [\n          eliotIdentifier,\n          clientPID,\n        ] = clientIdentityString.split('_');\n\n        // Look at the identity of the slave (and if we have duplicate)\n        if (this.slaves.find(x => x.eliotIdentifier === eliotIdentifier) ||\n          this.notConfirmedSlaves.find(x => x.eliotIdentifier === eliotIdentifier)) {\n          // Identity already in use by an other slave\n          // Close the connection\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `[${this.name}] Refuse slave cause of identity`.cyan,\n            });\n\n          return this.getCommunicationSystem()\n            .closeConnectionToClient(clientIdentityByte, clientIdentityString);\n        }\n\n        // So here the client do not exist already and the identifier is free\n\n        // Add the slave into the declared not confirmed array\n        this.notConfirmedSlaves.push({\n          clientIdentityString,\n          clientIdentityByte,\n          eliotIdentifier,\n          clientPID,\n          tasks: [],\n          error: false,\n        });\n\n        // Ask the slaves about its tasks\n        return this.getCommunicationSystem()\n          .sendMessageToClient(clientIdentityByte, clientIdentityString, SLAVE_CONFIRMATION_INFORMATIONS);\n      });\n\n    // Listen to slaves disconnection\n    this.getCommunicationSystem()\n      .listenClientDisconnectionEvent((clientIdentityString) => {\n        this.slaves = this.slaves.filter((x) => {\n          if (x.clientIdentityString === clientIdentityString) {\n            RoleAndTask.getInstance()\n              .displayMessage({\n                str: `[${this.name}] Slave get removed (connection)`.red,\n              });\n\n            // Fire when a slave get disconnected\n            Utils.fireUp(this.newDisconnectionListeningFunction, [x]);\n\n            return false;\n          }\n\n          return true;\n        });\n\n        this.notConfirmedSlaves = this.notConfirmedSlaves.filter((x) => {\n          if (x.clientIdentityString === clientIdentityString) {\n            RoleAndTask.getInstance()\n              .displayMessage({\n                str: `[${this.name}] Non-confirmed slave get removed (connection)`.red,\n              });\n\n            // Fire when a slave get disconnected\n            Utils.fireUp(this.newDisconnectionListeningFunction, [x]);\n\n            return false;\n          }\n\n          return true;\n        });\n      });\n\n    // Confirm a slave that wasn't\n    const confirmSlave = (clientIdentityByte, clientIdentityString, dataJSON) => {\n      const index = this.notConfirmedSlaves.findIndex(x => x.clientIdentityString === clientIdentityString);\n\n      if (index === -1) return;\n\n      // Confirm the slave\n      const slave = this.notConfirmedSlaves[index];\n\n      slave.tasks = dataJSON[BODY].tasks;\n      slave.role = dataJSON[BODY].role;\n\n      this.slaves.push(slave);\n\n      this.notConfirmedSlaves.splice(index, 1);\n\n      // Fire when a slave get connected\n      Utils.fireUp(this.newConnectionListeningFunction, [slave]);\n    };\n\n    // We listen to incoming messages\n    this.getCommunicationSystem()\n      .listenToIncomingMessage((clientIdentityByte, clientIdentityString, dataString) => {\n        const dataJSON = Utils.convertStringToJSON(dataString);\n\n        // Here we got all messages that comes from clients (so slaves)\n        // Check if the message answer particular message\n        // If it does apply the particular job\n        [{\n          //\n          // Check about the slave infos\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === SLAVE_CONFIRMATION_INFORMATIONS),\n          // It means we get the tasks list\n          applyFunc: () => confirmSlave(clientIdentityByte, clientIdentityString, dataJSON),\n        }, {\n          //\n          // Check about generic news\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === GENERIC_CHANNEL_DATA),\n          applyFunc: () => this.sendDataToEveryELIOTTaskWhereverItIsLowLevel(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about messages to display\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === OUTPUT_TEXT),\n          applyFunc: () => this.displayMessage(dataJSON[BODY]),\n        }, {\n          //\n          // Check about infos about slaves\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === INFOS_ABOUT_SLAVES),\n          applyFunc: () => this.infosAboutSlaveIncomming(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about error happened into slave\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === ERROR_HAPPENED),\n          applyFunc: () => this.errorHappenedIntoSlave(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about slave asking for taking a mutex\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === TAKE_MUTEX),\n          applyFunc: () => this.protocolTakeMutex(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about slave asking for releasing a mutex\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === RELEASE_MUTEX),\n          applyFunc: () => this.protocolReleaseMutex(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about slave asking for DB update startup\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === ASK_DATABASE_CONNECTION_CHANGE),\n          applyFunc: () => this.protocolHandleDatabaseConnectionChangeAsk(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }].forEach((x) => {\n          if (x.checkFunc()) x.applyFunc();\n        });\n      });\n  }\n\n  /**\n   * We got news about a slave -> infos\n   * Store it and call HandleEliotTask if it's up\n   * @param {Object} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {Object} data\n   */\n  infosAboutSlaveIncomming(clientIdentityByte, clientIdentityString, data) {\n    // Get the right slave\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n    const notConfirmedSlave = this.notConfirmedSlaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    const ptr = slave || notConfirmedSlave;\n\n    if (!ptr) return;\n\n    if (!ptr.moreInfos) ptr.moreInfos = {};\n\n    // Apply values to moreInfos\n    [\n      'cpuAndMemory',\n      'ips',\n      'tasksInfos',\n    ]\n    .forEach((x) => {\n      // To get the 0 value\n      if (data[x] !== void 0) ptr.moreInfos[x] = data[x];\n    });\n\n    // Tell something changed in the conf\n    this.somethingChangedAboutSlavesOrI();\n  }\n\n  /**\n   * Returns in an array the whole system pids (Master + Slaves processes)\n   */\n  getFullSystemPids() {\n    return new Promise((resolve) => {\n      resolve([\n        String(process.pid),\n        ...this.slaves.map(x => String(x.clientPID)),\n      ]);\n    });\n  }\n\n  /**\n   * Connect the second Task to the first one\n   * @param {String} idTaskToConnectTo\n   * @param {String} idTaskToConnect\n   * @param {Object} args\n   */\n  async connectMasterToTask(idTaskToConnectTo, idTaskToConnect, args) {\n    try {\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: Utils.monoline([\n              `[${this.name}] Ask Master to connect the Task N°${idTaskToConnect}`,\n              ` to the Task N°${idTaskToConnectTo}`,\n            ])\n            .blue,\n        });\n\n      const task = await this.getTaskHandler()\n        .getTask(idTaskToConnectTo);\n\n      // We get the task\n      // Error if the task is not active\n      if (!task.isActive()) {\n        throw new Error(`E7009 : idTask: ${idTaskToConnectTo}`);\n      }\n\n      // Ask the connection to be made\n      const connection = task.connectToTask(idTaskToConnect, args);\n\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: Utils.monoline([\n              `[${this.name}] Task N°${idTaskToConnect} correctly connected to Task `,\n              `N°${idTaskToConnectTo} in Master`,\n            ])\n            .green,\n        });\n\n      return connection;\n    } catch (err) {\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: Utils.monoline([\n              `[${this.name}] Task N°${idTaskToConnect} failed to be connected`,\n              ` to Task N°${idTaskToConnectTo} in Master`,\n            ])\n            .red,\n        });\n\n      throw err;\n    }\n  }\n\n  /**\n   * Connect the second Task to the first one\n   * @param {String} identifierSlave - Identifier of the slave that host the idTaskToConnectTo\n   * @param {String} idTaskToConnectTo\n   * @param {String} idTaskToConnect\n   * @param {Object} args\n   */\n  async connectTaskToTask(identifierSlave, idTaskToConnectTo, idTaskToConnect, args) {\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      identifierSlave,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CONNECT_TASK_TO_TASK,\n\n      messageBodyToSend: {\n        idTask: idTaskToConnectTo,\n        idTaskToConnect,\n        args,\n      },\n\n      messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CONNECT_TASK_TO_TASK,\n    });\n\n    // We get either an errors object or an error\n    if (ret === '') return ret;\n\n    throw ret;\n  }\n\n  /**\n   * Modify the status of the task attached to the given identifier\n   * (local data, have no impact in the real slave)\n   * @param {String} identifier\n   * @param {String} idTask\n   * @param {Boolean} status\n   */\n  modifyTaskStatusToSlaveLocalArray(identifier, idTask, status) {\n    this.slaves.some((x, xi) => {\n      if (x.eliotIdentifier === identifier) {\n        return x.tasks.some((y, yi) => {\n          if (y.id === idTask) {\n            this.slaves[xi].tasks[yi].isActive = status;\n\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * When called: Add a task to a slave\n   * @param {String} identifier\n   * @param {String} idTask\n   */\n  async startTaskToSlave(identifier, idTask, args = {}) {\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      identifierSlave: identifier,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.START_TASK,\n\n      messageBodyToSend: {\n        idTask,\n        args,\n      },\n\n      messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.START_TASK,\n    });\n\n    // We get either an errors object or an error\n    if (ret === '') {\n      // Modify the task status for the given slave\n      this.modifyTaskStatusToSlaveLocalArray(identifier, idTask, true);\n\n      // Say something changed\n      this.somethingChangedAboutSlavesOrI();\n\n      return ret;\n    }\n\n    // throw Errors.deserialize(ret);\n    throw new Error('deserialize');\n  }\n\n  /**\n   * List the existing slaves\n   */\n  async listSlaves() {\n    return this.master.getSlave;\n  }\n\n  /**\n   * List a slave tasks using its identifier (Ask the slave to it)\n   * @param {String} identifier\n   */\n  async distantListSlaveTask(identifier) {\n    return this.sendMessageAndWaitForTheResponse({\n      identifierSlave: identifier,\n      isHeadBodyPattern: false,\n      messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS,\n      messageBodyToSend: {},\n      messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS,\n    });\n  }\n\n  /**\n   * List a slave tasks using its identifier (Use local data to it)\n   * @param {String} identifier\n   */\n  async listSlaveTask(identifier) {\n    // Look for the slave in confirmSlave\n    const slave = this.getSlaveByEliotIdentifier(identifier);\n\n    return slave.tasks;\n  }\n\n  /**\n   * Handle the fact the eliot state change\n   * We spread the data on our tasks and to our slaves\n   * @param {Number} eliotState\n   * @param {Number} oldEliotState\n   */\n  async handleEliotStateChange(eliotState, oldEliotState) {\n    return Promise.all([\n      // Spread to our tasks\n      this.getTaskHandler()\n      .applyNewEliotState(eliotState, oldEliotState),\n\n      // Spread to slaves\n      this.tellAllSlaveThatEliotStateChanged(eliotState, oldEliotState),\n\n      // The spread n slaves went well\n    ]);\n  }\n\n  /**\n   * Return only the slaves that are regular slaves (not CRON_EXECUTOR_ROLE for example)\n   */\n  getSlavesOnlyThatAreRegularSlaves() {\n    return this.slaves.filter(x => x.role.id === CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.id);\n  }\n\n  /**\n   * Tell all slave that the eliot state did change\n   *\n   * WARNING - DO NOT INCLUDE CRON_EXECUTOR_ROLE SLAVES INTO THE PIPE\n   *\n   * @param {Number} eliotState\n   * @param {Number} oldEliotState\n   */\n  async tellAllSlaveThatEliotStateChanged(eliotState, oldEliotState) {\n    const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n    return Promise.all(regularSlaves.map(x => this.tellASlaveThatEliotStateChanged(x.eliotIdentifier, eliotState, oldEliotState)));\n  }\n\n  /**\n   * Tell a slave that eliot state did change\n   * @param {String} slaveIdentifier\n   * @param {Number} eliotState\n   * @param {Number} oldEliotState\n   */\n  async tellASlaveThatEliotStateChanged(slaveIdentifier, eliotState, oldEliotState) {\n    const {\n      STATE_CHANGE,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      identifierSlave: slaveIdentifier,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: STATE_CHANGE,\n\n      messageBodyToSend: {\n        eliotState,\n        oldEliotState,\n      },\n\n      messageHeaderToGet: STATE_CHANGE,\n      timeoutToGetMessage: CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT_STATE_CHANGE,\n    });\n\n    // We get either an errors object or an error\n    if (ret === '') return ret;\n\n    RoleAndTask.getInstance()\n      .displayMessage({\n        str: `[${this.name}] eliot state get not spread in Slave N°${slaveIdentifier}`.red,\n      });\n\n    throw new Error('deserialize');\n\n    // throw Errors.deserialize(ret);\n  }\n\n  /**\n   * When called: Remove an existing slave(s)\n   * @param {Array} identifiersSlaves\n   * @param {?Number} _i\n   */\n  async removeExistingSlave(identifiersSlaves) {\n    return Utils.promiseQueue([\n      // Close all slaves\n      ...identifiersSlaves.map(x => ({\n        functionToCall: this.sendMessageToSlave,\n\n        context: this,\n\n        args: [\n          x,\n          CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CLOSE,\n        ],\n      })),\n\n      // Say that something changed\n      {\n        functionToCall: this.somethingChangedAboutSlavesOrI,\n        context: this,\n      },\n    ]);\n  }\n\n  /**\n   * Kill a slave using its identifier\n   * @param {String} eliotIdentifier\n   */\n  killSlave(eliotIdentifier) {\n    // Look for the given identifier\n    this.consoleChildObjectPtr.filter((x) => {\n      if (x.eliotIdentifier === eliotIdentifier) {\n        try {\n          // Kill the process\n          process.kill(x.pid, CONSTANT.SIGNAL_UNPROPER.SIGUSR1);\n\n          // Remove the slave from the slave list\n          this.slaves = this.slaves.filter(y => !(y.eliotIdentifier === eliotIdentifier));\n        } catch (err) {\n          // Ignore the error, because the slave is dead anyway to us\n        }\n\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * When called: remove a task from slave\n   *\n   * THIS FUNCTION HAVE SPECIAL TIMEOUT FOR SLAVE ANSWER\n   *\n   * @param {String} identifier\n   * @param {String} idTask\n   * @param {Object} args\n   */\n  async removeTaskFromSlave(identifier, idTask, args = {}) {\n    const {\n      STOP_TASK,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    RoleAndTask.getInstance()\n      .displayMessage({\n        str: `[${this.name}] Ask Slave N°${identifier} to stop the Task N°${idTask}`.blue,\n      });\n\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      identifierSlave: identifier,\n      isHeadBodyPattern: true,\n      messageHeaderToSend: STOP_TASK,\n\n      messageBodyToSend: {\n        idTask,\n        args,\n      },\n\n      messageHeaderToGet: STOP_TASK,\n      timeoutToGetMessage: CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT_STOP_TASK,\n    });\n\n    // We get either an errors object or an error\n    if (ret === '') {\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: `[${this.name}] Task N°${idTask} correctly stopped in Slave N°${identifier}`.green,\n        });\n\n      // Modify the task status for the given slave\n      this.modifyTaskStatusToSlaveLocalArray(identifier, idTask, false);\n\n      return ret;\n    }\n\n    RoleAndTask.getInstance()\n      .displayMessage({\n        str: `[${this.name}] Task N°${idTask} failed to be stopped to Slave N°${identifier}`.red,\n      });\n\n    throw ret;\n  }\n\n  /**\n   * Display a message directly\n   * @param {Object} param\n   */\n  async displayMessage(param) {\n    try {\n      // If we have the display task active, we give the message to it\n      if (this.displayTask) {\n        const task = await this.getTaskHandler()\n          .getTask(this.displayTask);\n\n        // If we disallow log display, stop it here\n        if (!RoleAndTask.getInstance()\n          .getDisplayLog()) {\n          return false;\n        }\n\n        if (task.isActive()) {\n          return task.displayMessage(param);\n        }\n      }\n\n      // If not we display\n      Utils.displayMessage(param);\n    } catch (err) {\n      // Ignore error - We can't display the data - it do not require further error treatment\n      // Store the message into file tho\n      Utils.displayMessage({\n        str: String(err.stack || err),\n        out: process.stderr,\n      });\n    }\n\n    return false;\n  }\n\n  /**\n   * Start a new slave not in a console but in a regular process\n   * @param {{opts: String, uniqueSlaveId: String}} slaveOpts\n   * @param {Object} specificOpts - (Spawn options)\n   * @param {String} connectionTimeout\n   */\n  startNewSlaveInProcessMode(slaveOpts, specificOpts, connectionTimeout) {\n    return new Promise((resolve, reject) => {\n      // We create a unique Id that will referenciate the slave at the connexion\n      const uniqueSlaveId = (slaveOpts && slaveOpts.uniqueSlaveId) || Utils.generateUniqueEliotID();\n\n      // Options to send to the new created slave\n      const eliotOpts = (slaveOpts && slaveOpts.opts) || [\n        `--${CONSTANT.ELIOT_LAUNCHING_PARAMETERS.MODE.name}`,\n        `${CONSTANT.ELIOT_LAUNCHING_MODE.SLAVE}`,\n        `--${CONSTANT.ELIOT_LAUNCHING_PARAMETERS.MODE_OPTIONS.name}`,\n        `${CONSTANT.SLAVE_START_ARGS.IDENTIFIER}=${uniqueSlaveId}`,\n      ];\n\n      // Options to give to fork(...)\n      const forkOpts = {};\n\n      // If there is no path to the entry file to execute\n      if (!this.pathToEntryFile) {\n        throw new Error('Cannot start the slave : No pathToEntryFile configured');\n      }\n\n      // Path that lead to the exe of ELIOT\n      const pathToExec = this.pathToEntryFile;\n\n      // LaunchScenarios eliot in slave mode in a different process\n      const child = childProcess.fork(pathToExec, eliotOpts, forkOpts);\n\n      // LaunchScenarios a timeout of connection\n      const timeoutConnection = setTimeout(() => {\n        // Kill the process we did created\n        child.kill(CONSTANT.SIGNAL_TO_KILL_SLAVE_COMMAND);\n\n        return reject(new Error(`E7003 : Timeout ${connectionTimeout} ms passed`));\n      }, connectionTimeout);\n\n      // Look at error event (If it get fired it means the program failed to get launched)\n      // Handle the fact a child can result an error later on after first connection\n      // Error detected\n      child.on('error', err => reject(new Error(`E7003 : Exit Code: ${err}`)));\n\n      // Handle the fact a child get closed\n      // The close can be wanted, or not\n      child.on('close', (code) => {\n        // No error\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `Slave Close: ${code}`.red,\n          });\n      });\n\n      // Handle the fact a child exit\n      // The exit can be wanted or not\n      child.on('exit', (code) => {\n        // No error\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `Slave Exit: ${code}`.red,\n          });\n      });\n\n      // Now we need to look at communicationSystem of the master to know if the new slave connect to ELIOT\n      // If we pass a connection timeout time, we kill the process we just created and return an error\n      const connectEvent = (slaveInfos) => {\n        // Wait for a new client with the identifier like -> uniqueSlaveId_processId\n        if (slaveInfos && slaveInfos.eliotIdentifier === uniqueSlaveId) {\n          // We got our slave working well\n          clearTimeout(timeoutConnection);\n          this.unlistenSlaveConnectionEvent(connectEvent);\n\n          // Store the child data\n          this.consoleChildObjectPtr.push({\n            eliotIdentifier: uniqueSlaveId,\n            pid: slaveInfos.clientPID,\n          });\n\n          return resolve({\n            ...slaveInfos,\n            pid: slaveInfos.clientPID,\n          });\n        }\n\n        // This is not our slave\n\n        return false;\n      };\n\n      this.listenSlaveConnectionEvent(connectEvent);\n    });\n  }\n\n  /**\n   * Tell one task about what changed in the architecture\n   */\n  async tellOneTaskAboutArchitectureChange(idTask) {\n    try {\n      const task = await this.getTaskHandler()\n        .getTask(idTask);\n\n      // Can't find the task  so -> don't tell a new archiecture is here\n      if (!task) return;\n\n      if (task.isActive()) {\n        // Tell HandleEliotTask about new conf\n        task.dynamicallyRefreshDataIntoList({\n          notConfirmedSlaves: this.notConfirmedSlaves,\n          confirmedSlaves: this.slaves,\n\n          master: {\n            tasks: this.getTaskHandler()\n              .getTaskListStatus(),\n            communication: this.getCommunicationSystem(),\n            ips: Utils.givesLocalIps(),\n            cpuAndMemory: this.cpuUsageAndMemory,\n            tasksInfos: this.tasksInfos,\n          },\n        });\n      }\n    } catch (e) {\n      // Don't od anything because it's not an error\n    }\n  }\n\n  /**\n   * Do something when an information changed about ELIOT architecture\n   */\n  async somethingChangedAboutSlavesOrI() {\n    // Look at all tasks\n    await Promise.all(RoleAndTask.getInstance()\n      .tasks.filter(x => x.notifyAboutArchitectureChange)\n      .map(x => this.tellOneTaskAboutArchitectureChange(x.id)));\n  }\n\n  /**\n   * When called : start a new slave\n   * Take options in parameters or start a regular slave\n   *\n   * @param {{opts: String, uniqueSlaveId: String}} slaveOpts\n   * @param {Object} specificOpts - (Spawn options)\n   * @param {String} connectionTimeout\n   */\n  async startNewSlave(slaveOpts, specificOpts, connectionTimeout = CONSTANT.SLAVE_CREATION_CONNECTION_TIMEOUT) {\n    const ret = await this.startNewSlaveInProcessMode(slaveOpts, specificOpts, connectionTimeout);\n\n    // Say something changed\n    await this.somethingChangedAboutSlavesOrI();\n\n    return ret;\n  }\n\n  /**\n   * Send a message that match head/body pattern\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * @param {String} eliotIdentifier\n   * @param {String} headString\n   * @param {String} bodyString\n   */\n  async sendMessageToSlaveHeadBodyPattern(eliotIdentifier, headString, bodyString) {\n    // Build up the message\n    const message = {\n      [CONSTANT.PROTOCOL_KEYWORDS.HEAD]: headString,\n      [CONSTANT.PROTOCOL_KEYWORDS.BODY]: bodyString,\n    };\n\n    // Send the message\n    return this.sendMessageToSlave(eliotIdentifier, JSON.stringify(message));\n  }\n\n  /**\n   * Send a message to a slave using an eliotIdentifier\n   * @param {String} eliotIdentifier\n   * @param {String} message\n   */\n  async sendMessageToSlave(eliotIdentifier, message) {\n    // Look for the slave in confirmSlave\n    const slave = this.getSlaveByEliotIdentifier(eliotIdentifier);\n\n    // Send the message\n    this.getCommunicationSystem()\n      .sendMessageToClient(slave.clientIdentityByte, slave.clientIdentityString, message);\n\n    return true;\n  }\n\n  /**\n   * Get a slave using its eliot id\n   * @param {String} eliotIdentifier\n   */\n  getSlaveByEliotIdentifier(eliotIdentifier) {\n    // Look for the slave in confirmSlave\n    const slave = this.slaves.find(x => x.eliotIdentifier === eliotIdentifier);\n\n    return slave || new Error(`E7004 : Identifier: ${eliotIdentifier}`);\n  }\n\n  /**\n   * Using the eliotIdentifier, wait a specific incoming message from a specific slave\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * If there is no answer before the timeout, stop waiting and send an error\n   * @param {String} headString\n   * @param {String} eliotIdentifier\n   * @param {Number} timeout - in ms\n   */\n  getMessageFromSlave(headString, eliotIdentifier, timeout = CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT) {\n    return new Promise((resolve, reject) => {\n      let timeoutFunction = false;\n\n      // Look for the slave in confirmSlave\n      const slave = this.getSlaveByEliotIdentifier(eliotIdentifier);\n\n      // Function that will receive messages from slaves\n      const msgListener = (clientIdentityByte, clientIdentityString, dataString) => {\n        // Check the identifier to be the one we are waiting a message for\n\n        if (clientIdentityString === slave.clientIdentityString) {\n          const dataJSON = Utils.convertStringToJSON(dataString);\n\n          // Here we got all messages that comes from clients (so slaves)\n          // Check if the message answer particular message\n          if (dataJSON && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] &&\n            dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] === headString) {\n            // Stop the timeout\n            clearTimeout(timeoutFunction);\n\n            // Stop the listening\n            this.getCommunicationSystem()\n              .unlistenToIncomingMessage(msgListener);\n\n            // We get our message\n            return resolve(dataJSON[CONSTANT.PROTOCOL_KEYWORDS.BODY]);\n          }\n        }\n\n        return false;\n      };\n\n      // If the function get triggered, we reject an error\n      timeoutFunction = setTimeout(() => {\n        // Stop the listening\n        this.getCommunicationSystem()\n          .unlistenToIncomingMessage(msgListener);\n\n        // Return an error\n        return reject(new Error('E7005'));\n      }, timeout);\n\n      // Listen to incoming messages\n      return this.getCommunicationSystem()\n        .listenToIncomingMessage(msgListener);\n    });\n  }\n\n  /**\n   * Send the cpu load to the server periodically\n   */\n  infiniteGetCpuAndMemory() {\n    if (this.intervalFdCpuAndMemory) return;\n\n    if (CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME) {\n      // When we connect, we send our infos to the master\n      this.intervalFdCpuAndMemory = setInterval(async () => {\n        try {\n          const cpuAndMemory = await Utils.getCpuAndMemoryLoad();\n\n          this.cpuUsageAndMemory = cpuAndMemory;\n\n          // Say something change\n          this.somethingChangedAboutSlavesOrI();\n\n          if (!this.active && this.intervalFdCpuAndMemory) {\n            clearInterval(this.intervalFdCpuAndMemory);\n\n            this.intervalFdCpuAndMemory = false;\n          }\n        } catch (err) {\n          RoleAndTask.getInstance()\n            .errorHappened(err);\n        }\n      }, CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME);\n    }\n  }\n\n  /**\n   * Get periodically the infos about tasks running in master\n   */\n  async infiniteGetTasksInfos() {\n    if (this.intervalFdTasksInfos) return;\n\n    this.intervalFdTasksInfos = setInterval(async () => {\n      try {\n        const infos = await this.taskHandler.getInfosFromAllActiveTasks();\n\n        this.tasksInfos = infos;\n\n        this.somethingChangedAboutSlavesOrI();\n\n        // If the role is still active we call it back\n        if (!this.active && this.intervalFdTasksInfos) {\n          clearInterval(this.intervalFdTasksInfos);\n\n          this.intervalFdTasksInfos = false;\n        }\n      } catch (err) {\n        RoleAndTask.getInstance()\n          .errorHappened(err);\n      }\n    }, CONSTANT.SLAVES_INFOS_CHANGE_TIME);\n  }\n\n  /**\n   * ELIOT start to play the role\n   *\n   * A master is defined as:\n   * A master have a Server ZeroMQ open\n   * A master is connected to Slaves\n   *\n   * pathToEntryFile is the path we will use to start new slaves\n   *\n   * @param {Object} args\n   * @override\n   */\n  async start({\n    ipServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_ADDRESS,\n    portServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_PORT,\n  }) {\n    // Reinitialize some properties\n    this.initProperties();\n\n    // Create the OMQ Server\n    this.communicationSystem = new ZeroMQServerRouter();\n\n    // Start the communication system\n    await this.communicationSystem.start({\n      ipServer,\n      portServer,\n      transport: CONSTANT.ZERO_MQ.TRANSPORT.IPC,\n    });\n\n    this.active = true;\n\n    this.protocolMasterSlave();\n\n    // Say something changed\n    this.somethingChangedAboutSlavesOrI();\n\n    // LaunchScenarios an infite get of cpu usage to give to handleEliotTask\n    this.infiniteGetCpuAndMemory();\n\n    // LaunchScenarios an infite get of tasks infos to give to handleEliotTask\n    this.infiniteGetTasksInfos();\n\n    return true;\n  }\n\n  /**\n   * Get the hierarchy level of the given task\n   */\n  static getHierarchyLevelByIdTask(computeListClosure, idTask) {\n    let toRet;\n\n    computeListClosure.some((x) => {\n      if (x.idTask === idTask) {\n        toRet = x.closureHierarchy;\n\n        return true;\n      }\n\n      return false;\n    });\n\n    return toRet;\n  }\n\n  /**\n   * Sort the array ASC by closureHierarchy\n   */\n  static sortArray(ptr) {\n    const arr = ptr;\n\n    for (let i = 0; i < (arr.length - 1); i += 1) {\n      if (arr[i].closureHierarchy > arr[i + 1].closureHierarchy) {\n        const tmp = arr[i + 1];\n\n        arr[i + 1] = arr[i];\n\n        arr[i] = tmp;\n\n        i = -1;\n      }\n    }\n\n    return arr;\n  }\n\n  /**\n   * This methods return the task we need to stop first\n   * There is an hierarchie in tasks closure\n   */\n  chooseWhichTaskToStop() {\n    const tasksMaster = this.getTaskHandler()\n      .getTaskListStatus();\n\n    // Compute a list in order of tasksID to close (following the closure hierarchy)\n    const computeListClosure = Master1_0.sortArray(tasksMaster.map(x => ({\n      idTask: x.id,\n      closureHierarchy: x.closureHierarchy,\n    })));\n\n    // Now look at slaves tasks, then master task, about the task that is the higher in closure hierarchy\n    const ret = {\n      idTaskToRemove: false,\n      isMasterTask: false,\n      isSlaveTask: false,\n      identifierSlave: false,\n      hierarchyLevel: false,\n      args: {},\n    };\n\n    const foundHighestInHierarchy = this.slaves.some(x => x.tasks.some((y) => {\n      // Look at the hierarchy level of the given task\n      const hierarchyY = Master1_0.getHierarchyLevelByIdTask(computeListClosure, y.id);\n\n      if (!y.isActive) return false;\n\n      // Look if this hierarchy is higher than the save one\n      if (ret.hierarchyLevel === false || (ret.hierarchyLevel > hierarchyY)) {\n        // Save the task to be the one that get to be removed (for now!)\n        ret.hierarchyLevel = hierarchyY;\n        ret.idTaskToRemove = y.id;\n        ret.isSlaveTask = true;\n        ret.isMasterTask = false;\n        ret.identifierSlave = x.eliotIdentifier;\n\n        // If the task we have is the highest in hierarchy, no need to look furthers\n        if (computeListClosure.length && hierarchyY === computeListClosure[0].closureHierarchy) return true;\n      }\n\n      return false;\n    }));\n\n    if (foundHighestInHierarchy) return ret;\n\n    // We didn't found the higest task in the hierarchy so look at master tasks, its maybe there\n    tasksMaster.some((x) => {\n      const hierarchyX = Master1_0.getHierarchyLevelByIdTask(computeListClosure, x.id);\n\n      if (!x.isActive) return false;\n\n      // Look if this hierarchy is higher than the save one\n      if (ret.hierarchyLevel === false || (ret.hierarchyLevel > hierarchyX)) {\n        // Save the task to be the one that get to be removed (for now!)\n        ret.hierarchyLevel = hierarchyX;\n        ret.idTaskToRemove = x.id;\n        ret.isSlaveTask = false;\n        ret.isMasterTask = true;\n        ret.identifierSlave = false;\n\n        // If the task we have is the highest in hierarchy, no need to look furthers\n        if (computeListClosure.length && hierarchyX === computeListClosure[0].closureHierarchy) return true;\n      }\n      return false;\n    });\n\n    return ret;\n  }\n\n  /**\n   * Stop all tasks on every slave and master following a specific closure order\n   * (Some tasks must be closed before/after some others)\n   *\n   * WARNING RECURSIVE CALL\n   */\n  async stopAllTaskOnEverySlaveAndMaster() {\n    // close one of the task\n    // master or slave task\n    const {\n      idTaskToRemove,\n      isMasterTask,\n      isSlaveTask,\n      identifierSlave,\n      args,\n    } = this.chooseWhichTaskToStop();\n\n    // No more task to stop\n    if (idTaskToRemove === false) {\n      // Say something changed\n      this.somethingChangedAboutSlavesOrI();\n\n      return true;\n    }\n\n    if (isMasterTask) {\n      await this.getTaskHandler()\n        .stopTask(idTaskToRemove, args);\n\n      // Call next\n      return this.stopAllTaskOnEverySlaveAndMaster();\n    }\n\n    if (isSlaveTask) {\n      await this.removeTaskFromSlave(identifierSlave, idTaskToRemove, args);\n\n      // Call next\n      return this.stopAllTaskOnEverySlaveAndMaster();\n    }\n\n    return true;\n  }\n\n  /**\n   * ELIOT stop to play the role\n   * @param {Object} args\n   * @override\n   */\n  async stop() {\n    // Say bye to every slaves\n    await this.stopAllTaskOnEverySlaveAndMaster();\n\n    await this.removeExistingSlave(this.slaves.map(x => x.eliotIdentifier));\n\n    // Stop the infinite loops\n    if (this.intervalFdCpuAndMemory) clearInterval(this.intervalFdCpuAndMemory);\n\n    if (this.intervalFdTasksInfos) clearInterval(this.intervalFdTasksInfos);\n\n    // Stop the communication system\n    await this.communicationSystem.stop();\n\n    this.active = false;\n\n    return true;\n  }\n\n  /**\n   * Send the given message and wait for the response\n   *\n   * HERE WE CREATE TWO EXECUTIONS LIFES\n   *\n   * Put isHeadBodyPattern = true if you want to use the headBodyPattern\n   *\n   * @param {Object} args\n   */\n  sendMessageAndWaitForTheResponse({\n    identifierSlave,\n    messageHeaderToSend,\n    messageBodyToSend,\n    messageHeaderToGet,\n    isHeadBodyPattern,\n\n    // Can be equals to undefined -> default timeout\n    timeoutToGetMessage,\n  }) {\n    return new Promise((resolve, reject) => {\n      // We switch to the appropriated func\n      const sendMessageGoodFunc = () => {\n        if (isHeadBodyPattern) return this.sendMessageToSlaveHeadBodyPattern;\n\n        return this.sendMessageToSlave;\n      };\n\n      let errAlreadyReturned = false;\n\n      // Be ready to get the message from the slave before to send it the command\n      this.getMessageFromSlave(messageHeaderToGet, identifierSlave, timeoutToGetMessage)\n        // Job done\n        .then(resolve)\n        .catch((err) => {\n          if (!errAlreadyReturned) {\n            errAlreadyReturned = true;\n\n            return reject(err);\n          }\n\n          return false;\n        });\n\n      // Send the command to the slave\n      sendMessageGoodFunc()\n        .call(this, identifierSlave, messageHeaderToSend, messageBodyToSend)\n        .then(() => {\n          // It went well, no wait getMessageFromSlave to get the message\n          // If the message is not coming, getMessageFromSlave will timeout and result of an error\n\n          //\n          // Nothing to do here anymore Mate!\n          //\n        })\n        .catch((err) => {\n          // The getMessageFromSlave will automatically timeout\n          if (!errAlreadyReturned) {\n            errAlreadyReturned = true;\n\n            return reject(err);\n          }\n\n          return false;\n        });\n    });\n  }\n}\n"]}