{"version":3,"sources":["../../../../../src/RoleSystem/Role/RoleSlave/Slave1_0.es6"],"names":["instance","Slave1_0","oneshotNewInstance","name","CONSTANT","DEFAULT_ROLE","SLAVE_ROLE","id","tasks","RoleAndTask","getInstance","getRoleTasks","communicationSystem","setTaskHandler","TaskHandler","params","getDisplayLog","sendHeadBodyMessageToServer","PROTOCOL_MASTER_SLAVE","MESSAGES","OUTPUT_TEXT","buildMsg","buildHeadBodyMessage","LIST_TASKS","getTaskHandler","getTaskListStatus","getCommunicationSystem","sendMessageToServer","SLAVE_CONFIRMATION_INFORMATIONS","role","data","GENERIC_CHANNEL_DATA","head","body","START_TASK","idTask","args","Error","serialize","startTask","STOP_TASK","stopTask","ip","cpuAndMemory","tasksInfos","INFOS_ABOUT_SLAVES","infos","ips","Utils","givesLocalIps","getCpuAndMemoryLoad","ret","CONNECT_TASK_TO_TASK","idTaskToConnect","getTask","task","isActive","connectToTask","STATE_CHANGE","eliotState","oldEliotState","changeEliotState","applyNewEliotState","err","ERROR_HAPPENED","String","DB_INIT_DONE","sendMessageAndWaitForTheResponse","messageHeaderToSend","messageBodyToSend","messageHeaderToGet","isHeadBodyPattern","timeoutToGetMessage","MASTER_SLAVE_DB_INIT_MESSAGES_WAITING_TIMEOUT","json","convertStringToJSON","error","ASK_DB_INIT","newLogsToApply","ASK_DATABASE_CONNECTION_CHANGE","CHANGE_DATABASE_CONNECTION","changeDatabaseConnection","listenToIncomingMessage","dataString","dataJSON","PROTOCOL_KEYWORDS","HEAD","BODY","CLOSE","checkFunc","applyFunc","sendTaskList","sendConfirmationInformations","protocolStartTask","protocolConnectTasks","protocolGenericChannelData","protocolStateChange","protocolDatabaseConnectionChange","stop","exitEliotGood","displayMessage","str","out","process","stderr","exitEliotUnproperDueToError","protocolStopTask","forEach","x","intervalFdCpuAndMemory","DISPLAY_CPU_MEMORY_CHANGE_TIME","setInterval","protocolSendMyInfosToMaster","active","clearInterval","intervalFdTasksInfos","taskHandler","getInfosFromAllActiveTasks","errorHappened","SLAVES_INFOS_CHANGE_TIME","ipServer","ZERO_MQ","DEFAULT_SERVER_IP_ADDRESS","portServer","DEFAULT_SERVER_IP_PORT","identifier","ZeroMQClientDealer","protocolMasterSlave","start","transport","TRANSPORT","IPC","identityPrefix","infiniteSendCpuAndMemoryLoadToMaster","infiniteSendTasksInfosToMaster","listenConnectEvent","client","yellow","listenDisconnectEvent","startSlave1_0","cyan","stopAllTask","red","headString","timeout","MASTER_MESSAGE_WAITING_TIMEOUT","resolve","reject","timeoutFunction","msgListener","clearTimeout","unlistenToIncomingMessage","setTimeout","errAlreadyReturned","getMessageFromServer","then","catch","spreadDataToEveryLocalTask","ASlave"],"mappings":"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","file":"Slave1_0.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport ASlave from './ASlave.js';\nimport CONSTANT from '../../../Utils/CONSTANT/CONSTANT.js';\nimport ZeroMQClientDealer from '../../../CommunicationSystem/SocketCommunicationSystem/ZeroMQ/Client/Implementations/ZeroMQClientDealer.js';\nimport TaskHandler from '../../Handlers/TaskHandler.js';\nimport Utils from '../../../Utils/Utils.js';\nimport RoleAndTask from '../../../RoleAndTask.js';\n\nlet instance = null;\n\n/**\n * Define the Role of Slave which have a job of executant.\n *\n * Execute orders and special tasks.\n */\nexport default class Slave1_0 extends ASlave {\n  /**\n   * Ask if we want a brand new instance (If you don't create a new instance here as asked\n   * you will have trouble in inheritance - child of this class)\n   */\n  constructor(oneshotNewInstance = false) {\n    super();\n\n    if (instance && !oneshotNewInstance) return instance;\n\n    this.name = CONSTANT.DEFAULT_ROLE.SLAVE_ROLE.name;\n    this.id = CONSTANT.DEFAULT_ROLE.SLAVE_ROLE.id;\n\n    // Get the tasks related to the master role\n    const tasks = RoleAndTask.getInstance()\n      .getRoleTasks(CONSTANT.DEFAULT_ROLE.SLAVE_ROLE.id);\n\n    // Define none communicationSystem for now\n    this.communicationSystem = false;\n\n    // Define all tasks handled by this role\n    this.setTaskHandler(new TaskHandler(tasks));\n\n    if (oneshotNewInstance) return this;\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * SINGLETON implementation\n   * @override\n   */\n  static getInstance() {\n    return instance || new Slave1_0();\n  }\n\n  /**\n   * Get the communicationSystem\n   */\n  getCommunicationSystem() {\n    return this.communicationSystem;\n  }\n\n  /**\n   * Display a message by giving it to the master\n   * @param {Object} param\n   */\n  displayMessage(params) {\n    // If we disallow log display, stop it here\n    if (!RoleAndTask.getInstance()\n      .getDisplayLog()) return;\n\n    this.sendHeadBodyMessageToServer(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.OUTPUT_TEXT, params);\n  }\n\n  /**\n   * Send the task list to the server\n   */\n  sendTaskList() {\n    const buildMsg = this.buildHeadBodyMessage(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS, this.getTaskHandler()\n      .getTaskListStatus());\n\n    return this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * We send our tasks and the type of slave we are\n   */\n  sendConfirmationInformations() {\n    const buildMsg = this.buildHeadBodyMessage(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.SLAVE_CONFIRMATION_INFORMATIONS, {\n      tasks: this.getTaskHandler()\n        .getTaskListStatus(),\n\n      role: {\n        id: this.id,\n        name: this.name,\n      },\n    });\n\n    return this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks -> Send the request to master\n   * @param {String} dataName\n   * @param {Object} data\n   * @param {Date} timestamp\n   */\n  sendDataToEveryELIOTTaskWhereverItIs(data) {\n    const buildMsg = this.buildHeadBodyMessage(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.GENERIC_CHANNEL_DATA, data);\n\n    this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * Send message to server using head/body pattern\n   * @param {String} head\n   * @param {Object} body\n   */\n  sendHeadBodyMessageToServer(head, body) {\n    const buildMsg = this.buildHeadBodyMessage(head, body);\n\n    // Error in message\n    return this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * Start a task\n   * @param {{idTask: String, args: Object}} body\n   */\n  async protocolStartTask(body) {\n    const {\n      START_TASK,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    // We should have something like { idTask: String, args: {} }\n    if (!body || !body.idTask || !body.args) {\n      // Error in message\n      return this.sendHeadBodyMessageToServer(START_TASK, new Error('E7006')\n        .serialize());\n    }\n\n    try {\n      await this.getTaskHandler()\n        .startTask(body.idTask, {\n          ...body.args,\n          role: this,\n        });\n\n      // Task get successfuly added\n      this.sendHeadBodyMessageToServer(START_TASK, '');\n    } catch (err) {\n      this.sendHeadBodyMessageToServer(START_TASK, err.serialize());\n    }\n\n    return false;\n  }\n\n  /**\n   * Stop a task\n   * @param {Object} body\n   */\n  async protocolStopTask(body) {\n    const {\n      STOP_TASK,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    // We should have something like { idTask: String, args: {} }\n    if (!body || !body.idTask || !body.args) {\n      // Error in message\n      return this.sendHeadBodyMessageToServer(STOP_TASK, new Error('E7006')\n        .serialize());\n    }\n\n    try {\n      await this.getTaskHandler()\n        .stopTask(body.idTask, body.args);\n\n      // Task get successfuly stopped\n      this.sendHeadBodyMessageToServer(STOP_TASK, '');\n    } catch (err) {\n      this.sendHeadBodyMessageToServer(STOP_TASK, err.serialize());\n    }\n\n    return false;\n  }\n\n  /**\n   * As a slave we send our infos to the master throught this method\n   * Infos are: IP Address, CPU and memory Load, tasks infos ...\n   */\n  async protocolSendMyInfosToMaster({\n    ip,\n    cpuAndMemory,\n    tasksInfos,\n  }) {\n    const {\n      INFOS_ABOUT_SLAVES,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const infos = {};\n\n    // Add the ip address\n    if (ip) infos.ips = Utils.givesLocalIps();\n\n    // Add the tasks infos\n    if (tasksInfos) infos.tasksInfos = tasksInfos;\n\n    // Add the cpu and memory Load\n    if (cpuAndMemory) {\n      try {\n        const ret = await Utils.getCpuAndMemoryLoad();\n\n        infos.cpuAndMemory = ret;\n\n        this.sendHeadBodyMessageToServer(INFOS_ABOUT_SLAVES, infos);\n      } catch (err) {\n        infos.cpuAndMemory = err.serialize();\n\n        this.sendHeadBodyMessageToServer(INFOS_ABOUT_SLAVES, infos);\n      }\n\n      return false;\n    }\n\n    return this.sendHeadBodyMessageToServer(INFOS_ABOUT_SLAVES, infos);\n  }\n\n  /**\n   * Connect a task to an other task\n   * @param {Object} body\n   */\n  async protocolConnectTasks(body) {\n    const {\n      CONNECT_TASK_TO_TASK,\n      START_TASK,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    // We should have something like { idTask: String, idTaskToConnect: String, args: {} }\n    if (!body || !body.idTask || !body.idTaskToConnect || !body.args) {\n      // Error in message\n      return this.sendHeadBodyMessageToServer(CONNECT_TASK_TO_TASK, new Error('E7006')\n        .serialize());\n    }\n\n    try {\n      const task = await this.getTaskHandler()\n        .getTask(body.idTask);\n\n      // We get the task\n      // Error if the task is not active\n      if (!task.isActive()) {\n        await this.sendHeadBodyMessageToServer(START_TASK, new Error(`E7009 : idTask: ${body.idTask}`));\n      } else {\n        // Ask the connection to be made\n        await task.connectToTask(body.idTaskToConnect, body.args);\n      }\n\n      this.sendHeadBodyMessageToServer(CONNECT_TASK_TO_TASK, '');\n    } catch (err) {\n      this.sendHeadBodyMessageToServer(CONNECT_TASK_TO_TASK, err.serialize());\n    }\n\n    return false;\n  }\n\n  /**\n   * We got a news from the master. We have to spread the news to every tasks we hold.\n   * @param {{dataName: String, data: Object, timestamp: Date}} body\n   */\n  static protocolGenericChannelData(body) {\n    // For itself tasks\n    RoleAndTask.getInstance()\n      .spreadDataToEveryLocalTask(body);\n  }\n\n  /**\n   * We got a news about ELIOT state change\n   * We tell all our tasks about the change and send a result of spread to the master\n   * @param {{ eliotState: Number, oldEliotState: Number }} body\n   */\n  async protocolStateChange(body) {\n    const {\n      STATE_CHANGE,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    // We should have something like { eliotState: Number }\n    if (!body || !body.eliotState || !body.oldEliotState) {\n      // Error in message\n      return this.sendHeadBodyMessageToServer(STATE_CHANGE, new Error('E7006')\n        .serialize());\n    }\n\n    try {\n      // Store the new state\n      await RoleAndTask.getInstance()\n        .changeEliotState(body.eliotState.id);\n\n      // Apply the new state\n      await this.getTaskHandler()\n        .applyNewEliotState(body.eliotState, body.oldEliotState);\n\n      // New state get successfuly spread\n      return this.sendHeadBodyMessageToServer(STATE_CHANGE, '');\n    } catch (err) {\n      // New state didn't get successfuly spread\n      this.sendHeadBodyMessageToServer(STATE_CHANGE, err.serialize());\n    }\n\n    return false;\n  }\n\n  /**\n   * We got an error that happended into the slave process\n   * We send the error to the master, to make it do something about it\n   * @param {Error)} err\n   */\n  tellMasterErrorHappened(err) {\n    // Send the error to the master\n    this.sendHeadBodyMessageToServer(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.ERROR_HAPPENED, String(new Error(err)));\n  }\n\n  /**\n   * Tell the master that the database initialization is done\n   */\n  async databaseIntializationDone() {\n    const {\n      DB_INIT_DONE,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      messageHeaderToSend: DB_INIT_DONE,\n      messageBodyToSend: '',\n      messageHeaderToGet: DB_INIT_DONE,\n      isHeadBodyPattern: true,\n      timeoutToGetMessage: CONSTANT.MASTER_SLAVE_DB_INIT_MESSAGES_WAITING_TIMEOUT,\n    });\n\n    const json = Utils.convertStringToJSON(ret);\n\n    if (!json || !json.error) return true;\n\n    throw new Error('Deserialized');\n    // throw Errors.deserialize(json.error);\n  }\n\n  /**\n   * Ask the master to perform a database initialization\n   */\n  async askForDatabaseInitialization() {\n    const {\n      ASK_DB_INIT,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      messageHeaderToSend: ASK_DB_INIT,\n      messageBodyToSend: '',\n      messageHeaderToGet: ASK_DB_INIT,\n      isHeadBodyPattern: true,\n      timeoutToGetMessage: CONSTANT.MASTER_SLAVE_DB_INIT_MESSAGES_WAITING_TIMEOUT,\n    });\n\n    const json = Utils.convertStringToJSON(ret);\n\n    if (!json || !json.error) return true;\n\n    return new Error('Deserialized');\n\n    // return Errors.deserialize(json.error);\n  }\n\n  /**\n   * Ask the master to perform a database connection change\n   */\n  async askForDatabaseConnectionChange(newLogsToApply) {\n    const {\n      ASK_DATABASE_CONNECTION_CHANGE,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    const ret = await this.sendMessageAndWaitForTheResponse({\n      messageHeaderToSend: ASK_DATABASE_CONNECTION_CHANGE,\n      messageBodyToSend: newLogsToApply,\n      messageHeaderToGet: ASK_DATABASE_CONNECTION_CHANGE,\n      isHeadBodyPattern: true,\n      timeoutToGetMessage: CONSTANT.MASTER_SLAVE_DB_INIT_MESSAGES_WAITING_TIMEOUT,\n    });\n\n    const json = Utils.convertStringToJSON(ret);\n\n    if (!json || !json.error) return true;\n\n    return new Error('Deserialized');\n    // return Errors.deserialize(json.error);\n  }\n\n  /**\n   * We get an order of setting up new database connections\n   */\n  async protocolDatabaseConnectionChange(body) {\n    const {\n      CHANGE_DATABASE_CONNECTION,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    try {\n      // Apply the new connection\n      await RoleAndTask.getInstance()\n        .changeDatabaseConnection(body);\n\n      // New connection get successfuly setted\n      this.sendHeadBodyMessageToServer(CHANGE_DATABASE_CONNECTION, '');\n    } catch (err) {\n      // New state didn't get successfuly setted\n      this.sendHeadBodyMessageToServer(CHANGE_DATABASE_CONNECTION, err.serialize());\n    }\n  }\n\n  /**\n   * Define the protocol between master and a slaves\n   */\n  protocolMasterSlave() {\n    // We listen to incoming messages\n    this.getCommunicationSystem()\n      .listenToIncomingMessage((dataString) => {\n        const dataJSON = Utils.convertStringToJSON(dataString);\n        const {\n          HEAD,\n          BODY,\n        } = CONSTANT.PROTOCOL_KEYWORDS;\n\n        const {\n          LIST_TASKS,\n          START_TASK,\n          STOP_TASK,\n          CONNECT_TASK_TO_TASK,\n          GENERIC_CHANNEL_DATA,\n          CLOSE,\n          STATE_CHANGE,\n          SLAVE_CONFIRMATION_INFORMATIONS,\n          CHANGE_DATABASE_CONNECTION,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // Here we got all messages that comes from server (so master)\n        // Check if the message answer particular message\n        // If it does apply the particular job\n        [{\n          // Check about the list of tasks\n          checkFunc: () => dataString === LIST_TASKS,\n\n          // It means we get asked about our tasks list\n          applyFunc: () => this.sendTaskList(),\n        }, {\n          // Check about the ask for infos\n          checkFunc: () => dataString === SLAVE_CONFIRMATION_INFORMATIONS,\n\n          // It means we get asked about our informations\n          applyFunc: () => this.sendConfirmationInformations(),\n        }, {\n          // Check about add a task\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === START_TASK,\n\n          // It means we get asked about starting a task\n          applyFunc: () => this.protocolStartTask(dataJSON[BODY]),\n        }, {\n          // Check about connect a task to an other task\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === CONNECT_TASK_TO_TASK,\n          applyFunc: () => this.protocolConnectTasks(dataJSON[BODY]),\n        }, {\n          // Check about news about generic channel data\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === GENERIC_CHANNEL_DATA,\n          applyFunc: () => Slave1_0.protocolGenericChannelData(dataJSON[BODY]),\n        }, {\n          // Check about news about eliot state\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === STATE_CHANGE,\n          applyFunc: () => this.protocolStateChange(dataJSON[BODY]),\n        }, {\n          // Check about news about eliot connection change\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === CHANGE_DATABASE_CONNECTION,\n          applyFunc: () => this.protocolDatabaseConnectionChange(dataJSON[BODY]),\n        }, {\n          // Check about close order\n          checkFunc: () => dataString === CLOSE,\n          applyFunc: async () => {\n            try {\n              await this.stop();\n\n              RoleAndTask.exitEliotGood();\n            } catch (e) {\n              Utils.displayMessage({\n                str: `Exit eliot unproper CLOSE ORDER FAILED [${String(e)}]`,\n                out: process.stderr,\n              });\n\n              RoleAndTask.exitEliotUnproperDueToError();\n            }\n          },\n        }, {\n          // Check about close a task\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === STOP_TASK,\n          applyFunc: () => this.protocolStopTask(dataJSON[BODY]),\n        }].forEach((x) => {\n          if (x.checkFunc()) x.applyFunc();\n        });\n      });\n  }\n\n  /**\n   * Send the cpu and memory load to the server periodically\n   */\n  infiniteSendCpuAndMemoryLoadToMaster() {\n    if (this.intervalFdCpuAndMemory) return;\n\n    if (CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME) {\n      // When we connect, we send our infos to the master\n      this.intervalFdCpuAndMemory = setInterval(() => {\n        this.protocolSendMyInfosToMaster({\n          cpuAndMemory: true,\n        });\n\n        if (!this.active && this.intervalFdCpuAndMemory) {\n          clearInterval(this.intervalFdCpuAndMemory);\n          this.intervalFdCpuAndMemory = false;\n        }\n      }, CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME);\n    }\n  }\n\n  /**\n   * Send the cpu and memory load to the server periodically\n   */\n  infiniteSendTasksInfosToMaster() {\n    if (this.intervalFdTasksInfos) return;\n\n    // When we connect, we send our infos to the master\n    this.intervalFdTasksInfos = setInterval(async () => {\n      try {\n        const infos = await this.taskHandler.getInfosFromAllActiveTasks();\n\n        // Send the data to the master\n        this.protocolSendMyInfosToMaster({\n          tasksInfos: infos,\n        });\n\n        // If the role is still active we call it back\n        if (!this.active && this.intervalFdTasksInfos) {\n          clearInterval(this.intervalFdTasksInfos);\n\n          this.intervalFdTasksInfos = false;\n        }\n      } catch (err) {\n        RoleAndTask.getInstance()\n          .errorHappened(err);\n      }\n    }, CONSTANT.SLAVES_INFOS_CHANGE_TIME);\n  }\n\n  /**\n   * Start the slave1_0\n   * @param {Object} args\n   * @override\n   */\n  async startSlave1_0({\n    ipServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_ADDRESS,\n    portServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_PORT,\n    identifier,\n  }) {\n    // Create the OMQ Server\n    this.communicationSystem = new ZeroMQClientDealer();\n\n    this.protocolMasterSlave();\n\n    // Start the communication system\n    await this.communicationSystem.start({\n      ipServer,\n      portServer,\n      transport: CONSTANT.ZERO_MQ.TRANSPORT.IPC,\n      identityPrefix: identifier,\n    });\n\n    this.active = true;\n\n    // When we connect, we send our infos to the master\n    this.protocolSendMyInfosToMaster({\n      ip: true,\n    });\n\n    // Every X sec get the CPU and the Memory and send it to the master\n    this.infiniteSendCpuAndMemoryLoadToMaster();\n\n    // Every X sec get infos from the active tasks and send them to the master\n    this.infiniteSendTasksInfosToMaster();\n\n    // Look at when we get connected\n    this.communicationSystem.listenConnectEvent((client) => {\n      RoleAndTask.getInstance()\n        .displayMessage({\n          str: `Connected ${client}`.yellow,\n        });\n    });\n\n    // Look at when we get disconnected\n    this.communicationSystem.listenDisconnectEvent(client => RoleAndTask.getInstance()\n      .displayMessage({\n        str: `Disconnected ${client}`.yellow,\n      }));\n\n    return true;\n  }\n\n  /**\n   * ELIOT start to play the role\n   * @param {Object} args\n   * @override\n   */\n  async start(args) {\n    return this.startSlave1_0(args);\n  }\n\n  /**\n   * ELIOT stop to play the role\n   * @param {Object} args\n   * @override\n   */\n  async stop() {\n    RoleAndTask.getInstance()\n      .displayMessage({\n        str: 'Ask Role Slave To Stop'.cyan,\n      });\n\n    // Stop all its tasks\n    await this.getTaskHandler()\n      .stopAllTask();\n\n    // Stop the infinite loops\n    if (this.intervalFdCpuAndMemory) clearInterval(this.intervalFdCpuAndMemory);\n\n    if (this.intervalFdTasksInfos) clearInterval(this.intervalFdTasksInfos);\n\n    // Stop the communication system\n    await this.communicationSystem.stop();\n\n    RoleAndTask.getInstance()\n      .displayMessage({\n        str: 'Role Slave Stopped'.red,\n      });\n\n    this.active = false;\n\n    return true;\n  }\n\n  /**\n   * Send the data to the server\n   * @param {String} data\n   */\n  sendMessageToServer(data) {\n    this.getCommunicationSystem()\n      .sendMessageToServer(data);\n  }\n\n  /**\n   * Wait a specific incoming message from the server\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * If there is no answer before the timeout, stop waiting and send an error\n   * @param {String} headString\n   * @param {Number} timeout - in ms\n   */\n  getMessageFromServer(headString, timeout = CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT) {\n    return new Promise((resolve, reject) => {\n      let timeoutFunction = false;\n\n      // Function that will receive messages from the server\n      const msgListener = (dataString) => {\n        const dataJSON = Utils.convertStringToJSON(dataString);\n\n        // Here we got all messages that comes from the server\n        // Check if the message answer particular message\n        if (dataJSON && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] === headString) {\n          // Stop the timeout\n          clearTimeout(timeoutFunction);\n\n          // Stop the listening\n          this.getCommunicationSystem()\n            .unlistenToIncomingMessage(msgListener);\n\n          // We get our message\n          return resolve(dataJSON[CONSTANT.PROTOCOL_KEYWORDS.BODY]);\n        }\n\n        return false;\n      };\n\n      // If the function get triggered, we reject an error\n      timeoutFunction = setTimeout(() => {\n        // Stop the listening\n        this.getCommunicationSystem()\n          .unlistenToIncomingMessage(msgListener);\n\n        // Return an error\n        return reject(new Error('E7005'));\n      }, timeout);\n\n      // Listen to incoming messages\n      return this.getCommunicationSystem()\n        .listenToIncomingMessage(msgListener);\n    });\n  }\n\n  /**\n   * Send the given message and wait for the response\n   *\n   * HERE WE CREATE TWO EXECUTIONS LIFES\n   *\n   * Put isHeadBodyPattern = true if you want to use the headBodyPattern\n   *\n   * @param {Object} args\n   */\n  sendMessageAndWaitForTheResponse({\n    messageHeaderToSend,\n    messageBodyToSend,\n    messageHeaderToGet,\n    isHeadBodyPattern,\n\n    // Can be equals to undefined -> default timeout\n    timeoutToGetMessage,\n  }) {\n    return new Promise((resolve, reject) => {\n      let errAlreadyReturned = false;\n\n      // Be ready to get the message from the slave before to send it the command\n      this.getMessageFromServer(messageHeaderToGet, timeoutToGetMessage)\n        // Job done\n        .then(resolve)\n        .catch((err) => {\n          if (!errAlreadyReturned) {\n            errAlreadyReturned = true;\n\n            return reject(err);\n          }\n\n          return false;\n        });\n\n      // Send the command to the slave\n      if (isHeadBodyPattern) return this.sendHeadBodyMessageToServer(messageHeaderToSend, messageBodyToSend);\n\n      return this.sendMessageToServer(messageBodyToSend);\n\n      // It went well, no wait getMessageFromServer to get the message\n      // If the message is not coming, getMessageFromServer will timeout and result of an error\n\n      //\n      // Nothing to do here anymore Mate!\n      //\n    });\n  }\n}\n"]}