{"version":3,"sources":["../../../../../src/RoleSystem/Role/RoleSlave/Slave1_0.es6"],"names":["instance","Slave1_0","oneshotNewInstance","name","CONSTANT","DEFAULT_ROLES","SLAVE_ROLE","id","tasks","RoleAndTask","getInstance","getRoleTasks","communicationSystem","setTaskHandler","TaskHandler","params","displayLog","sendHeadBodyMessageToServer","PROTOCOL_MASTER_SLAVE","MESSAGES","OUTPUT_TEXT","buildMsg","buildHeadBodyMessage","LIST_TASKS","getTaskHandler","getTaskListStatus","getCommunicationSystem","sendMessageToServer","SLAVE_CONFIRMATION_INFORMATIONS","role","data","GENERIC_CHANNEL_DATA","head","body","PromiseCommandPattern","func","START_TASK","idTask","args","Errors","serialize","startTask","STOP_TASK","stopTask","ip","cpuAndMemory","tasksInfos","INFOS_ABOUT_SLAVES","infos","ips","Utils","givesLocalIps","getCpuAndMemoryLoad","ret","CONNECT_TASK_TO_TASK","idTaskToConnect","getTask","task","isActive","connectToTask","STATE_CHANGE","programState","oldProgramState","changeProgramState","applyNewProgramState","err","ERROR_HAPPENED","String","TAKE_MUTEX","sendMessageAndWaitForTheResponse","messageHeaderToSend","messageBodyToSend","JSON","stringify","messageHeaderToGet","isHeadBodyPattern","timeoutToGetMessage","MASTER_SLAVE_MUTEX_MESSAGES_WAITING_TIMEOUT","json","convertStringToJSON","error","deserialize","RELEASE_MUTEX","listenToIncomingMessage","dataString","dataJSON","PROTOCOL_KEYWORDS","HEAD","BODY","CLOSE","checkFunc","applyFunc","sendTaskList","sendConfirmationInformations","protocolStartTask","protocolConnectTasks","protocolGenericChannelData","protocolStateChange","stop","exitProgramGood","displayMessage","str","out","process","stderr","exitProgramUnproperDueToError","protocolStopTask","forEach","x","intervalFdCpuAndMemory","DISPLAY_CPU_MEMORY_CHANGE_TIME","setInterval","protocolSendMyInfosToMaster","active","clearInterval","intervalFdTasksInfos","taskHandler","getInfosFromAllActiveTasks","errorHappened","SLAVES_INFOS_CHANGE_TIME","ipServer","ZERO_MQ","DEFAULT_SERVER_IP_ADDRESS","portServer","DEFAULT_SERVER_IP_PORT","identifier","ZeroMQClientDealer","protocolMasterSlave","start","transport","TRANSPORT","IPC","identityPrefix","infiniteSendCpuAndMemoryLoadToMaster","infiniteSendTasksInfosToMaster","listenConnectEvent","client","yellow","listenDisconnectEvent","startSlave1_0","cyan","stopAllTask","red","headString","timeout","masterMessageWaitingTimeout","Promise","resolve","reject","timeoutFunction","msgListener","clearTimeout","unlistenToIncomingMessage","setTimeout","errAlreadyReturned","getMessageFromServer","then","spreadDataToEveryLocalTask","ASlave"],"mappings":"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","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport ASlave from './ASlave.js';\nimport CONSTANT from '../../../Utils/CONSTANT/CONSTANT.js';\nimport ZeroMQClientDealer from '../../../CommunicationSystem/SocketCommunicationSystem/ZeroMQ/Client/Implementations/ZeroMQClientDealer.js';\nimport TaskHandler from '../../Handlers/TaskHandler.js';\nimport Utils from '../../../Utils/Utils.js';\nimport Errors from '../../../Utils/Errors.js';\nimport RoleAndTask from '../../../RoleAndTask.js';\nimport PromiseCommandPattern from '../../../Utils/PromiseCommandPattern.js';\n\nlet instance = null;\n\n/**\n * Define the Role of Slave which have a job of executant.\n *\n * Execute orders and special tasks.\n */\nexport default class Slave1_0 extends ASlave {\n  /**\n   * Ask if we want a brand new instance (If you don't create a new instance here as asked\n   * you will have trouble in inheritance - child of this class)\n   */\n  constructor(oneshotNewInstance = false) {\n    super();\n\n    if (instance && !oneshotNewInstance) return instance;\n\n    this.name = CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.name;\n    this.id = CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.id;\n\n    // Get the tasks related to the master role\n    const tasks = RoleAndTask.getInstance()\n      .getRoleTasks(CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.id);\n\n    // Define none communicationSystem for now\n    this.communicationSystem = false;\n\n    // Define all tasks handled by this role\n    this.setTaskHandler(new TaskHandler(tasks));\n\n    if (oneshotNewInstance) return this;\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * SINGLETON implementation\n   * @override\n   */\n  static getInstance() {\n    return instance || new Slave1_0();\n  }\n\n  /**\n   * Get the communicationSystem\n   */\n  getCommunicationSystem() {\n    return this.communicationSystem;\n  }\n\n  /**\n   * Display a message by giving it to the master\n   * @param {Object} param\n   */\n  displayMessage(params) {\n    // If we disallow log display, stop it here\n    if (!RoleAndTask.getInstance()\n      .displayLog) return;\n\n    this.sendHeadBodyMessageToServer(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.OUTPUT_TEXT, params);\n  }\n\n  /**\n   * Send the task list to the server\n   */\n  sendTaskList() {\n    const buildMsg = this.buildHeadBodyMessage(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS, this.getTaskHandler()\n      .getTaskListStatus());\n\n    return this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * We send our tasks and the type of slave we are\n   */\n  sendConfirmationInformations() {\n    const buildMsg = this.buildHeadBodyMessage(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.SLAVE_CONFIRMATION_INFORMATIONS, {\n      tasks: this.getTaskHandler()\n        .getTaskListStatus(),\n\n      role: {\n        id: this.id,\n        name: this.name,\n      },\n    });\n\n    return this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks -> Send the request to master\n   * @param {String} dataName\n   * @param {Object} data\n   * @param {Date} timestamp\n   */\n  sendDataToEveryProgramTaskWhereverItIs(data) {\n    const buildMsg = this.buildHeadBodyMessage(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.GENERIC_CHANNEL_DATA, data);\n\n    this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * Send message to server using head/body pattern\n   * @param {String} head\n   * @param {Object} body\n   */\n  sendHeadBodyMessageToServer(head, body) {\n    const buildMsg = this.buildHeadBodyMessage(head, body);\n\n    // Error in message\n    return this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * Start a task\n   * @param {{idTask: String, args: Object}} body\n   */\n  protocolStartTask(body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          START_TASK,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // We should have something like { idTask: String, args: {} }\n        if (!body || !body.idTask || !body.args) {\n          // Error in message\n          return this.sendHeadBodyMessageToServer(START_TASK, new Errors('E7006')\n            .serialize());\n        }\n\n        try {\n          await this.getTaskHandler()\n            .startTask(body.idTask, {\n              ...body.args,\n              role: this,\n            });\n\n          // Task get successfuly added\n          this.sendHeadBodyMessageToServer(START_TASK, '');\n        } catch (err) {\n          this.sendHeadBodyMessageToServer(START_TASK, err.serialize());\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * Stop a task\n   * @param {Object} body\n   */\n  protocolStopTask(body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          STOP_TASK,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // We should have something like { idTask: String, args: {} }\n        if (!body || !body.idTask || !body.args) {\n          // Error in message\n          return this.sendHeadBodyMessageToServer(STOP_TASK, new Errors('E7006')\n            .serialize());\n        }\n\n        try {\n          await this.getTaskHandler()\n            .stopTask(body.idTask, body.args);\n\n          // Task get successfuly stopped\n          this.sendHeadBodyMessageToServer(STOP_TASK, '');\n        } catch (err) {\n          this.sendHeadBodyMessageToServer(STOP_TASK, err.serialize());\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * As a slave we send our infos to the master throught this method\n   * Infos are: IP Address, CPU and memory Load, tasks infos ...\n   */\n  protocolSendMyInfosToMaster({\n    ip,\n    cpuAndMemory,\n    tasksInfos,\n  }) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          INFOS_ABOUT_SLAVES,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        const infos = {};\n\n        // Add the ip address\n        if (ip) infos.ips = Utils.givesLocalIps();\n\n        // Add the tasks infos\n        if (tasksInfos) infos.tasksInfos = tasksInfos;\n\n        // Add the cpu and memory Load\n        if (cpuAndMemory) {\n          try {\n            const ret = await Utils.getCpuAndMemoryLoad();\n\n            infos.cpuAndMemory = ret;\n\n            this.sendHeadBodyMessageToServer(INFOS_ABOUT_SLAVES, infos);\n          } catch (err) {\n            infos.cpuAndMemory = err.serialize();\n\n            this.sendHeadBodyMessageToServer(INFOS_ABOUT_SLAVES, infos);\n          }\n\n          return false;\n        }\n\n        return this.sendHeadBodyMessageToServer(INFOS_ABOUT_SLAVES, infos);\n      },\n    });\n  }\n\n  /**\n   * Connect a task to an other task\n   * @param {Object} body\n   */\n  protocolConnectTasks(body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          CONNECT_TASK_TO_TASK,\n          START_TASK,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // We should have something like { idTask: String, idTaskToConnect: String, args: {} }\n        if (!body || !body.idTask || !body.idTaskToConnect || !body.args) {\n          // Error in message\n          return this.sendHeadBodyMessageToServer(CONNECT_TASK_TO_TASK, new Errors('E7006')\n            .serialize());\n        }\n\n        try {\n          const task = await this.getTaskHandler()\n            .getTask(body.idTask);\n\n          // We get the task\n          // Error if the task is not active\n          if (!task.isActive()) {\n            await this.sendHeadBodyMessageToServer(START_TASK, new Errors('E7009', `idTask: ${body.idTask}`));\n          } else {\n            // Ask the connection to be made\n            await task.connectToTask(body.idTaskToConnect, body.args);\n          }\n\n          this.sendHeadBodyMessageToServer(CONNECT_TASK_TO_TASK, '');\n        } catch (err) {\n          this.sendHeadBodyMessageToServer(CONNECT_TASK_TO_TASK, err.serialize());\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * We got a news from the master. We have to spread the news to every tasks we hold.\n   * @param {{dataName: String, data: Object, timestamp: Date}} body\n   */\n  static protocolGenericChannelData(body) {\n    // For itself tasks\n    RoleAndTask.getInstance()\n      .spreadDataToEveryLocalTask(body);\n  }\n\n  /**\n   * We got a news about PROGRAM state change\n   * We tell all our tasks about the change and send a result of spread to the master\n   * @param {{ programState: Number, oldProgramState: Number }} body\n   */\n  protocolStateChange(body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          STATE_CHANGE,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // We should have something like { programState: Number }\n        if (!body || !body.programState || !body.oldProgramState) {\n          // Error in message\n          return this.sendHeadBodyMessageToServer(STATE_CHANGE, new Errors('E7006')\n            .serialize());\n        }\n\n        try {\n          // Store the new state\n          await RoleAndTask.getInstance()\n            .changeProgramState(body.programState.id);\n\n          // Apply the new state\n          await this.getTaskHandler()\n            .applyNewProgramState(body.programState, body.oldProgramState);\n\n          // New state get successfuly spread\n          return this.sendHeadBodyMessageToServer(STATE_CHANGE, '');\n        } catch (err) {\n          // New state didn't get successfuly spread\n          this.sendHeadBodyMessageToServer(STATE_CHANGE, err.serialize());\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * We got an error that happended into the slave process\n   * We send the error to the master, to make it do something about it\n   * @param {Error)} err\n   */\n  tellMasterErrorHappened(err) {\n    // Send the error to the master\n    this.sendHeadBodyMessageToServer(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.ERROR_HAPPENED, String(new Errors(err)));\n  }\n\n  /**\n   * We want to take the mutex behind the given id\n   */\n  takeMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          TAKE_MUTEX,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          messageHeaderToSend: TAKE_MUTEX,\n\n          messageBodyToSend: JSON.stringify({\n            id,\n          }),\n\n          messageHeaderToGet: TAKE_MUTEX,\n          isHeadBodyPattern: true,\n          timeoutToGetMessage: CONSTANT.MASTER_SLAVE_MUTEX_MESSAGES_WAITING_TIMEOUT,\n        });\n\n        const json = Utils.convertStringToJSON(ret);\n\n        if (!json || !json.error) return true;\n\n        throw Errors.deserialize(json.error);\n      },\n    });\n  }\n\n  /**\n   * We want to release the mutex behind the given id\n   */\n  releaseMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          RELEASE_MUTEX,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          messageHeaderToSend: RELEASE_MUTEX,\n\n          messageBodyToSend: JSON.stringify({\n            id,\n          }),\n\n          messageHeaderToGet: RELEASE_MUTEX,\n          isHeadBodyPattern: true,\n          timeoutToGetMessage: CONSTANT.MASTER_SLAVE_MUTEX_MESSAGES_WAITING_TIMEOUT,\n        });\n\n        const json = Utils.convertStringToJSON(ret);\n\n        if (!json || !json.error) return true;\n\n        throw Errors.deserialize(json.error);\n      },\n    });\n  }\n\n  /**\n   * Define the protocol between master and a slaves\n   */\n  protocolMasterSlave() {\n    // We listen to incoming messages\n    this.getCommunicationSystem()\n      .listenToIncomingMessage((dataString) => {\n        const dataJSON = Utils.convertStringToJSON(dataString);\n        const {\n          HEAD,\n          BODY,\n        } = CONSTANT.PROTOCOL_KEYWORDS;\n\n        const {\n          LIST_TASKS,\n          START_TASK,\n          STOP_TASK,\n          CONNECT_TASK_TO_TASK,\n          GENERIC_CHANNEL_DATA,\n          CLOSE,\n          STATE_CHANGE,\n          SLAVE_CONFIRMATION_INFORMATIONS,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // Here we got all messages that comes from server (so master)\n        // Check if the message answer particular message\n        // If it does apply the particular job\n        [{\n          // Check about the list of tasks\n          checkFunc: () => dataString === LIST_TASKS,\n\n          // It means we get asked about our tasks list\n          applyFunc: () => this.sendTaskList(),\n        }, {\n          // Check about the ask for infos\n          checkFunc: () => dataString === SLAVE_CONFIRMATION_INFORMATIONS,\n\n          // It means we get asked about our informations\n          applyFunc: () => this.sendConfirmationInformations(),\n        }, {\n          // Check about add a task\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === START_TASK,\n\n          // It means we get asked about starting a task\n          applyFunc: () => this.protocolStartTask(dataJSON[BODY]),\n        }, {\n          // Check about connect a task to an other task\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === CONNECT_TASK_TO_TASK,\n          applyFunc: () => this.protocolConnectTasks(dataJSON[BODY]),\n        }, {\n          // Check about news about generic channel data\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === GENERIC_CHANNEL_DATA,\n          applyFunc: () => Slave1_0.protocolGenericChannelData(dataJSON[BODY]),\n        }, {\n          // Check about news about program state\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === STATE_CHANGE,\n          applyFunc: () => this.protocolStateChange(dataJSON[BODY]),\n        }, {\n          // Check about close order\n          checkFunc: () => dataString === CLOSE,\n          applyFunc: async () => {\n            try {\n              await this.stop();\n\n              RoleAndTask.exitProgramGood();\n            } catch (e) {\n              Utils.displayMessage({\n                str: `Exit program unproper CLOSE ORDER FAILED [${String(e)}]`,\n                out: process.stderr,\n              });\n\n              RoleAndTask.exitProgramUnproperDueToError();\n            }\n          },\n        }, {\n          // Check about close a task\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === STOP_TASK,\n          applyFunc: () => this.protocolStopTask(dataJSON[BODY]),\n        }].forEach((x) => {\n          if (x.checkFunc()) x.applyFunc();\n        });\n      });\n  }\n\n  /**\n   * Send the cpu and memory load to the server periodically\n   */\n  infiniteSendCpuAndMemoryLoadToMaster() {\n    if (this.intervalFdCpuAndMemory) return;\n\n    if (CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME) {\n      // When we connect, we send our infos to the master\n      this.intervalFdCpuAndMemory = setInterval(() => {\n        this.protocolSendMyInfosToMaster({\n          cpuAndMemory: true,\n        });\n\n        if (!this.active && this.intervalFdCpuAndMemory) {\n          clearInterval(this.intervalFdCpuAndMemory);\n          this.intervalFdCpuAndMemory = false;\n        }\n      }, CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME);\n    }\n  }\n\n  /**\n   * Send the cpu and memory load to the server periodically\n   */\n  infiniteSendTasksInfosToMaster() {\n    if (this.intervalFdTasksInfos) return;\n\n    // When we connect, we send our infos to the master\n    this.intervalFdTasksInfos = setInterval(async () => {\n      try {\n        const infos = await this.taskHandler.getInfosFromAllActiveTasks();\n\n        // Send the data to the master\n        this.protocolSendMyInfosToMaster({\n          tasksInfos: infos,\n        });\n\n        // If the role is still active we call it back\n        if (!this.active && this.intervalFdTasksInfos) {\n          clearInterval(this.intervalFdTasksInfos);\n\n          this.intervalFdTasksInfos = false;\n        }\n      } catch (err) {\n        RoleAndTask.getInstance()\n          .errorHappened(err);\n      }\n    }, CONSTANT.SLAVES_INFOS_CHANGE_TIME);\n  }\n\n  /**\n   * Start the slave1_0\n   * @param {Object} args\n   * @override\n   */\n  startSlave1_0({\n    ipServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_ADDRESS,\n    portServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_PORT,\n    identifier,\n  }) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Create the OMQ Server\n        this.communicationSystem = new ZeroMQClientDealer();\n\n        this.protocolMasterSlave();\n\n        // Start the communication system\n        await this.communicationSystem.start({\n          ipServer,\n          portServer,\n          transport: CONSTANT.ZERO_MQ.TRANSPORT.IPC,\n          identityPrefix: identifier,\n        });\n\n        this.active = true;\n\n        // When we connect, we send our infos to the master\n        this.protocolSendMyInfosToMaster({\n          ip: true,\n        });\n\n        // Every X sec get the CPU and the Memory and send it to the master\n        this.infiniteSendCpuAndMemoryLoadToMaster();\n\n        // Every X sec get infos from the active tasks and send them to the master\n        this.infiniteSendTasksInfosToMaster();\n\n        // Look at when we get connected\n        this.communicationSystem.listenConnectEvent((client) => {\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `Connected ${client}`.yellow,\n            });\n        });\n\n        // Look at when we get disconnected\n        this.communicationSystem.listenDisconnectEvent(client => RoleAndTask.getInstance()\n          .displayMessage({\n            str: `Disconnected ${client}`.yellow,\n          }));\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * PROGRAM start to play the role\n   * @param {Object} args\n   * @override\n   */\n  start(args) {\n    return new PromiseCommandPattern({\n      func: () => this.startSlave1_0(args),\n    });\n  }\n\n  /**\n   * PROGRAM stop to play the role\n   * @param {Object} args\n   * @override\n   */\n  stop() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: 'Ask Role Slave To Stop'.cyan,\n          });\n\n        // Stop all its tasks\n        await this.getTaskHandler()\n          .stopAllTask();\n\n        // Stop the infinite loops\n        if (this.intervalFdCpuAndMemory) clearInterval(this.intervalFdCpuAndMemory);\n\n        if (this.intervalFdTasksInfos) clearInterval(this.intervalFdTasksInfos);\n\n        // Stop the communication system\n        await this.communicationSystem.stop();\n\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: 'Role Slave Stopped'.red,\n          });\n\n        this.active = false;\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Send the data to the server\n   * @param {String} data\n   */\n  sendMessageToServer(data) {\n    this.getCommunicationSystem()\n      .sendMessageToServer(data);\n  }\n\n  /**\n   * Wait a specific incoming message from the server\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * If there is no answer before the timeout, stop waiting and send an error\n   * @param {String} headString\n   * @param {Number} timeout - in ms\n   */\n  getMessageFromServer(headString, timeout = RoleAndTask.getInstance()\n    .masterMessageWaitingTimeout) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        let timeoutFunction = false;\n\n        // Function that will receive messages from the server\n        const msgListener = (dataString) => {\n          const dataJSON = Utils.convertStringToJSON(dataString);\n\n          // Here we got all messages that comes from the server\n          // Check if the message answer particular message\n          if (dataJSON && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] === headString) {\n            // Stop the timeout\n            clearTimeout(timeoutFunction);\n\n            // Stop the listening\n            this.getCommunicationSystem()\n              .unlistenToIncomingMessage(msgListener);\n\n            // We get our message\n            return resolve(dataJSON[CONSTANT.PROTOCOL_KEYWORDS.BODY]);\n          }\n\n          return false;\n        };\n\n        // If the function get triggered, we reject an error\n        timeoutFunction = setTimeout(() => {\n          // Stop the listening\n          this.getCommunicationSystem()\n            .unlistenToIncomingMessage(msgListener);\n\n          // Return an error\n          return reject(new Errors('E7005'));\n        }, timeout);\n\n        // Listen to incoming messages\n        return this.getCommunicationSystem()\n          .listenToIncomingMessage(msgListener);\n      }),\n    });\n  }\n\n  /**\n   * Send the given message and wait for the response\n   *\n   * HERE WE CREATE TWO EXECUTIONS LIFES\n   *\n   * Put isHeadBodyPattern = true if you want to use the headBodyPattern\n   *\n   * @param {Object} args\n   */\n  sendMessageAndWaitForTheResponse({\n    messageHeaderToSend,\n    messageBodyToSend,\n    messageHeaderToGet,\n    isHeadBodyPattern,\n\n    // Can be equals to undefined -> default timeout\n    timeoutToGetMessage,\n  }) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        let errAlreadyReturned = false;\n\n        // Be ready to get the message from the slave before to send it the command\n        this.getMessageFromServer(messageHeaderToGet, timeoutToGetMessage)\n          // Job done\n          .then(resolve)\n          .catch((err) => {\n            if (!errAlreadyReturned) {\n              errAlreadyReturned = true;\n\n              return reject(err);\n            }\n\n            return false;\n          });\n\n        // Send the command to the slave\n        if (isHeadBodyPattern) return this.sendHeadBodyMessageToServer(messageHeaderToSend, messageBodyToSend);\n\n        return this.sendMessageToServer(messageBodyToSend);\n\n        // It went well, no wait getMessageFromServer to get the message\n        // If the message is not coming, getMessageFromServer will timeout and result of an error\n\n        //\n        // Nothing to do here anymore Mate!\n        //\n      }),\n    });\n  }\n}\n"],"file":"Slave1_0.js"}