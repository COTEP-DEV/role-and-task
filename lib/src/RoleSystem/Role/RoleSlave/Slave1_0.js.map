{"version":3,"sources":["../../../../../src/RoleSystem/Role/RoleSlave/Slave1_0.es6"],"names":["instance","Slave1_0","oneshotNewInstance","name","CONSTANT","DEFAULT_ROLES","SLAVE_ROLE","id","tasks","RoleAndTask","getInstance","getRoleTasks","communicationSystem","setTaskHandler","TaskHandler","params","getDisplayLog","sendHeadBodyMessageToServer","PROTOCOL_MASTER_SLAVE","MESSAGES","OUTPUT_TEXT","buildMsg","buildHeadBodyMessage","LIST_TASKS","getTaskHandler","getTaskListStatus","getCommunicationSystem","sendMessageToServer","SLAVE_CONFIRMATION_INFORMATIONS","role","data","GENERIC_CHANNEL_DATA","head","body","PromiseCommandPattern","func","START_TASK","idTask","args","Errors","serialize","startTask","STOP_TASK","stopTask","ip","cpuAndMemory","tasksInfos","INFOS_ABOUT_SLAVES","infos","ips","Utils","givesLocalIps","getCpuAndMemoryLoad","ret","CONNECT_TASK_TO_TASK","idTaskToConnect","getTask","task","isActive","connectToTask","STATE_CHANGE","eliotState","oldEliotState","changeEliotState","applyNewEliotState","err","ERROR_HAPPENED","String","TAKE_MUTEX","sendMessageAndWaitForTheResponse","messageHeaderToSend","messageBodyToSend","messageHeaderToGet","isHeadBodyPattern","timeoutToGetMessage","MASTER_SLAVE_MUTEX_MESSAGES_WAITING_TIMEOUT","json","convertStringToJSON","error","deserialize","RELEASE_MUTEX","listenToIncomingMessage","dataString","dataJSON","PROTOCOL_KEYWORDS","HEAD","BODY","CLOSE","checkFunc","applyFunc","sendTaskList","sendConfirmationInformations","protocolStartTask","protocolConnectTasks","protocolGenericChannelData","protocolStateChange","stop","exitEliotGood","displayMessage","str","out","process","stderr","exitEliotUnproperDueToError","protocolStopTask","forEach","x","intervalFdCpuAndMemory","DISPLAY_CPU_MEMORY_CHANGE_TIME","setInterval","protocolSendMyInfosToMaster","active","clearInterval","intervalFdTasksInfos","taskHandler","getInfosFromAllActiveTasks","errorHappened","SLAVES_INFOS_CHANGE_TIME","ipServer","ZERO_MQ","DEFAULT_SERVER_IP_ADDRESS","portServer","DEFAULT_SERVER_IP_PORT","identifier","ZeroMQClientDealer","protocolMasterSlave","start","transport","TRANSPORT","IPC","identityPrefix","infiniteSendCpuAndMemoryLoadToMaster","infiniteSendTasksInfosToMaster","listenConnectEvent","client","yellow","listenDisconnectEvent","startSlave1_0","cyan","stopAllTask","red","headString","timeout","MASTER_MESSAGE_WAITING_TIMEOUT","resolve","reject","timeoutFunction","msgListener","clearTimeout","unlistenToIncomingMessage","setTimeout","errAlreadyReturned","getMessageFromServer","then","catch","spreadDataToEveryLocalTask","ASlave"],"mappings":"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","file":"Slave1_0.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport ASlave from './ASlave.js';\nimport CONSTANT from '../../../Utils/CONSTANT/CONSTANT.js';\nimport ZeroMQClientDealer from '../../../CommunicationSystem/SocketCommunicationSystem/ZeroMQ/Client/Implementations/ZeroMQClientDealer.js';\nimport TaskHandler from '../../Handlers/TaskHandler.js';\nimport Utils from '../../../Utils/Utils.js';\nimport Errors from '../../../Utils/Errors.js';\nimport RoleAndTask from '../../../RoleAndTask.js';\nimport PromiseCommandPattern from '../../../Utils/PromiseCommandPattern.js';\n\nlet instance = null;\n\n/**\n * Define the Role of Slave which have a job of executant.\n *\n * Execute orders and special tasks.\n */\nexport default class Slave1_0 extends ASlave {\n  /**\n   * Ask if we want a brand new instance (If you don't create a new instance here as asked\n   * you will have trouble in inheritance - child of this class)\n   */\n  constructor(oneshotNewInstance = false) {\n    super();\n\n    if (instance && !oneshotNewInstance) return instance;\n\n    this.name = CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.name;\n    this.id = CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.id;\n\n    // Get the tasks related to the master role\n    const tasks = RoleAndTask.getInstance()\n      .getRoleTasks(CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.id);\n\n    // Define none communicationSystem for now\n    this.communicationSystem = false;\n\n    // Define all tasks handled by this role\n    this.setTaskHandler(new TaskHandler(tasks));\n\n    if (oneshotNewInstance) return this;\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * SINGLETON implementation\n   * @override\n   */\n  static getInstance() {\n    return instance || new Slave1_0();\n  }\n\n  /**\n   * Get the communicationSystem\n   */\n  getCommunicationSystem() {\n    return this.communicationSystem;\n  }\n\n  /**\n   * Display a message by giving it to the master\n   * @param {Object} param\n   */\n  displayMessage(params) {\n    // If we disallow log display, stop it here\n    if (!RoleAndTask.getInstance()\n      .getDisplayLog()) return;\n\n    this.sendHeadBodyMessageToServer(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.OUTPUT_TEXT, params);\n  }\n\n  /**\n   * Send the task list to the server\n   */\n  sendTaskList() {\n    const buildMsg = this.buildHeadBodyMessage(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS, this.getTaskHandler()\n      .getTaskListStatus());\n\n    return this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * We send our tasks and the type of slave we are\n   */\n  sendConfirmationInformations() {\n    const buildMsg = this.buildHeadBodyMessage(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.SLAVE_CONFIRMATION_INFORMATIONS, {\n      tasks: this.getTaskHandler()\n        .getTaskListStatus(),\n\n      role: {\n        id: this.id,\n        name: this.name,\n      },\n    });\n\n    return this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks -> Send the request to master\n   * @param {String} dataName\n   * @param {Object} data\n   * @param {Date} timestamp\n   */\n  sendDataToEveryELIOTTaskWhereverItIs(data) {\n    const buildMsg = this.buildHeadBodyMessage(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.GENERIC_CHANNEL_DATA, data);\n\n    this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * Send message to server using head/body pattern\n   * @param {String} head\n   * @param {Object} body\n   */\n  sendHeadBodyMessageToServer(head, body) {\n    const buildMsg = this.buildHeadBodyMessage(head, body);\n\n    // Error in message\n    return this.getCommunicationSystem()\n      .sendMessageToServer(buildMsg);\n  }\n\n  /**\n   * Start a task\n   * @param {{idTask: String, args: Object}} body\n   */\n  protocolStartTask(body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          START_TASK,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // We should have something like { idTask: String, args: {} }\n        if (!body || !body.idTask || !body.args) {\n          // Error in message\n          return this.sendHeadBodyMessageToServer(START_TASK, new Errors('E7006')\n            .serialize());\n        }\n\n        try {\n          await this.getTaskHandler()\n            .startTask(body.idTask, {\n              ...body.args,\n              role: this,\n            });\n\n          // Task get successfuly added\n          this.sendHeadBodyMessageToServer(START_TASK, '');\n        } catch (err) {\n          this.sendHeadBodyMessageToServer(START_TASK, err.serialize());\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * Stop a task\n   * @param {Object} body\n   */\n  protocolStopTask(body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          STOP_TASK,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // We should have something like { idTask: String, args: {} }\n        if (!body || !body.idTask || !body.args) {\n          // Error in message\n          return this.sendHeadBodyMessageToServer(STOP_TASK, new Errors('E7006')\n            .serialize());\n        }\n\n        try {\n          await this.getTaskHandler()\n            .stopTask(body.idTask, body.args);\n\n          // Task get successfuly stopped\n          this.sendHeadBodyMessageToServer(STOP_TASK, '');\n        } catch (err) {\n          this.sendHeadBodyMessageToServer(STOP_TASK, err.serialize());\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * As a slave we send our infos to the master throught this method\n   * Infos are: IP Address, CPU and memory Load, tasks infos ...\n   */\n  protocolSendMyInfosToMaster({\n    ip,\n    cpuAndMemory,\n    tasksInfos,\n  }) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          INFOS_ABOUT_SLAVES,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        const infos = {};\n\n        // Add the ip address\n        if (ip) infos.ips = Utils.givesLocalIps();\n\n        // Add the tasks infos\n        if (tasksInfos) infos.tasksInfos = tasksInfos;\n\n        // Add the cpu and memory Load\n        if (cpuAndMemory) {\n          try {\n            const ret = await Utils.getCpuAndMemoryLoad();\n\n            infos.cpuAndMemory = ret;\n\n            this.sendHeadBodyMessageToServer(INFOS_ABOUT_SLAVES, infos);\n          } catch (err) {\n            infos.cpuAndMemory = err.serialize();\n\n            this.sendHeadBodyMessageToServer(INFOS_ABOUT_SLAVES, infos);\n          }\n\n          return false;\n        }\n\n        return this.sendHeadBodyMessageToServer(INFOS_ABOUT_SLAVES, infos);\n      },\n    });\n  }\n\n  /**\n   * Connect a task to an other task\n   * @param {Object} body\n   */\n  protocolConnectTasks(body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          CONNECT_TASK_TO_TASK,\n          START_TASK,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // We should have something like { idTask: String, idTaskToConnect: String, args: {} }\n        if (!body || !body.idTask || !body.idTaskToConnect || !body.args) {\n          // Error in message\n          return this.sendHeadBodyMessageToServer(CONNECT_TASK_TO_TASK, new Errors('E7006')\n            .serialize());\n        }\n\n        try {\n          const task = await this.getTaskHandler()\n            .getTask(body.idTask);\n\n          // We get the task\n          // Error if the task is not active\n          if (!task.isActive()) {\n            await this.sendHeadBodyMessageToServer(START_TASK, new Errors('E7009', `idTask: ${body.idTask}`));\n          } else {\n            // Ask the connection to be made\n            await task.connectToTask(body.idTaskToConnect, body.args);\n          }\n\n          this.sendHeadBodyMessageToServer(CONNECT_TASK_TO_TASK, '');\n        } catch (err) {\n          this.sendHeadBodyMessageToServer(CONNECT_TASK_TO_TASK, err.serialize());\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * We got a news from the master. We have to spread the news to every tasks we hold.\n   * @param {{dataName: String, data: Object, timestamp: Date}} body\n   */\n  static protocolGenericChannelData(body) {\n    // For itself tasks\n    RoleAndTask.getInstance()\n      .spreadDataToEveryLocalTask(body);\n  }\n\n  /**\n   * We got a news about ELIOT state change\n   * We tell all our tasks about the change and send a result of spread to the master\n   * @param {{ eliotState: Number, oldEliotState: Number }} body\n   */\n  protocolStateChange(body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          STATE_CHANGE,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // We should have something like { eliotState: Number }\n        if (!body || !body.eliotState || !body.oldEliotState) {\n          // Error in message\n          return this.sendHeadBodyMessageToServer(STATE_CHANGE, new Errors('E7006')\n            .serialize());\n        }\n\n        try {\n          // Store the new state\n          await RoleAndTask.getInstance()\n            .changeEliotState(body.eliotState.id);\n\n          // Apply the new state\n          await this.getTaskHandler()\n            .applyNewEliotState(body.eliotState, body.oldEliotState);\n\n          // New state get successfuly spread\n          return this.sendHeadBodyMessageToServer(STATE_CHANGE, '');\n        } catch (err) {\n          // New state didn't get successfuly spread\n          this.sendHeadBodyMessageToServer(STATE_CHANGE, err.serialize());\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * We got an error that happended into the slave process\n   * We send the error to the master, to make it do something about it\n   * @param {Error)} err\n   */\n  tellMasterErrorHappened(err) {\n    // Send the error to the master\n    this.sendHeadBodyMessageToServer(CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.ERROR_HAPPENED, String(new Errors(err)));\n  }\n\n  /**\n   * We want to take the mutex behind the given id\n   */\n  takeMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          TAKE_MUTEX,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          messageHeaderToSend: TAKE_MUTEX,\n\n          messageBodyToSend: JSON.stringify({\n            id,\n          }),\n\n          messageHeaderToGet: TAKE_MUTEX,\n          isHeadBodyPattern: true,\n          timeoutToGetMessage: CONSTANT.MASTER_SLAVE_MUTEX_MESSAGES_WAITING_TIMEOUT,\n        });\n\n        const json = Utils.convertStringToJSON(ret);\n\n        if (!json || !json.error) return true;\n\n        throw Errors.deserialize(json.error);\n      },\n    });\n  }\n\n  /**\n   * We want to release the mutex behind the given id\n   */\n  releaseMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          RELEASE_MUTEX,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          messageHeaderToSend: RELEASE_MUTEX,\n\n          messageBodyToSend: JSON.stringify({\n            id,\n          }),\n\n          messageHeaderToGet: RELEASE_MUTEX,\n          isHeadBodyPattern: true,\n          timeoutToGetMessage: CONSTANT.MASTER_SLAVE_MUTEX_MESSAGES_WAITING_TIMEOUT,\n        });\n\n        const json = Utils.convertStringToJSON(ret);\n\n        if (!json || !json.error) return true;\n\n        throw Errors.deserialize(json.error);\n      },\n    });\n  }\n\n  /**\n   * Define the protocol between master and a slaves\n   */\n  protocolMasterSlave() {\n    // We listen to incoming messages\n    this.getCommunicationSystem()\n      .listenToIncomingMessage((dataString) => {\n        const dataJSON = Utils.convertStringToJSON(dataString);\n        const {\n          HEAD,\n          BODY,\n        } = CONSTANT.PROTOCOL_KEYWORDS;\n\n        const {\n          LIST_TASKS,\n          START_TASK,\n          STOP_TASK,\n          CONNECT_TASK_TO_TASK,\n          GENERIC_CHANNEL_DATA,\n          CLOSE,\n          STATE_CHANGE,\n          SLAVE_CONFIRMATION_INFORMATIONS,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // Here we got all messages that comes from server (so master)\n        // Check if the message answer particular message\n        // If it does apply the particular job\n        [{\n          // Check about the list of tasks\n          checkFunc: () => dataString === LIST_TASKS,\n\n          // It means we get asked about our tasks list\n          applyFunc: () => this.sendTaskList(),\n        }, {\n          // Check about the ask for infos\n          checkFunc: () => dataString === SLAVE_CONFIRMATION_INFORMATIONS,\n\n          // It means we get asked about our informations\n          applyFunc: () => this.sendConfirmationInformations(),\n        }, {\n          // Check about add a task\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === START_TASK,\n\n          // It means we get asked about starting a task\n          applyFunc: () => this.protocolStartTask(dataJSON[BODY]),\n        }, {\n          // Check about connect a task to an other task\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === CONNECT_TASK_TO_TASK,\n          applyFunc: () => this.protocolConnectTasks(dataJSON[BODY]),\n        }, {\n          // Check about news about generic channel data\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === GENERIC_CHANNEL_DATA,\n          applyFunc: () => Slave1_0.protocolGenericChannelData(dataJSON[BODY]),\n        }, {\n          // Check about news about eliot state\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === STATE_CHANGE,\n          applyFunc: () => this.protocolStateChange(dataJSON[BODY]),\n        }, {\n          // Check about close order\n          checkFunc: () => dataString === CLOSE,\n          applyFunc: async () => {\n            try {\n              await this.stop();\n\n              RoleAndTask.exitEliotGood();\n            } catch (e) {\n              Utils.displayMessage({\n                str: `Exit eliot unproper CLOSE ORDER FAILED [${String(e)}]`,\n                out: process.stderr,\n              });\n\n              RoleAndTask.exitEliotUnproperDueToError();\n            }\n          },\n        }, {\n          // Check about close a task\n          checkFunc: () => dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === STOP_TASK,\n          applyFunc: () => this.protocolStopTask(dataJSON[BODY]),\n        }].forEach((x) => {\n          if (x.checkFunc()) x.applyFunc();\n        });\n      });\n  }\n\n  /**\n   * Send the cpu and memory load to the server periodically\n   */\n  infiniteSendCpuAndMemoryLoadToMaster() {\n    if (this.intervalFdCpuAndMemory) return;\n\n    if (CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME) {\n      // When we connect, we send our infos to the master\n      this.intervalFdCpuAndMemory = setInterval(() => {\n        this.protocolSendMyInfosToMaster({\n          cpuAndMemory: true,\n        });\n\n        if (!this.active && this.intervalFdCpuAndMemory) {\n          clearInterval(this.intervalFdCpuAndMemory);\n          this.intervalFdCpuAndMemory = false;\n        }\n      }, CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME);\n    }\n  }\n\n  /**\n   * Send the cpu and memory load to the server periodically\n   */\n  infiniteSendTasksInfosToMaster() {\n    if (this.intervalFdTasksInfos) return;\n\n    // When we connect, we send our infos to the master\n    this.intervalFdTasksInfos = setInterval(async () => {\n      try {\n        const infos = await this.taskHandler.getInfosFromAllActiveTasks();\n\n        // Send the data to the master\n        this.protocolSendMyInfosToMaster({\n          tasksInfos: infos,\n        });\n\n        // If the role is still active we call it back\n        if (!this.active && this.intervalFdTasksInfos) {\n          clearInterval(this.intervalFdTasksInfos);\n\n          this.intervalFdTasksInfos = false;\n        }\n      } catch (err) {\n        RoleAndTask.getInstance()\n          .errorHappened(err);\n      }\n    }, CONSTANT.SLAVES_INFOS_CHANGE_TIME);\n  }\n\n  /**\n   * Start the slave1_0\n   * @param {Object} args\n   * @override\n   */\n  startSlave1_0({\n    ipServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_ADDRESS,\n    portServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_PORT,\n    identifier,\n  }) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Create the OMQ Server\n        this.communicationSystem = new ZeroMQClientDealer();\n\n        this.protocolMasterSlave();\n\n        // Start the communication system\n        await this.communicationSystem.start({\n          ipServer,\n          portServer,\n          transport: CONSTANT.ZERO_MQ.TRANSPORT.IPC,\n          identityPrefix: identifier,\n        });\n\n        this.active = true;\n\n        // When we connect, we send our infos to the master\n        this.protocolSendMyInfosToMaster({\n          ip: true,\n        });\n\n        // Every X sec get the CPU and the Memory and send it to the master\n        this.infiniteSendCpuAndMemoryLoadToMaster();\n\n        // Every X sec get infos from the active tasks and send them to the master\n        this.infiniteSendTasksInfosToMaster();\n\n        // Look at when we get connected\n        this.communicationSystem.listenConnectEvent((client) => {\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `Connected ${client}`.yellow,\n            });\n        });\n\n        // Look at when we get disconnected\n        this.communicationSystem.listenDisconnectEvent(client => RoleAndTask.getInstance()\n          .displayMessage({\n            str: `Disconnected ${client}`.yellow,\n          }));\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * ELIOT start to play the role\n   * @param {Object} args\n   * @override\n   */\n  start(args) {\n    return new PromiseCommandPattern({\n      func: () => this.startSlave1_0(args),\n    });\n  }\n\n  /**\n   * ELIOT stop to play the role\n   * @param {Object} args\n   * @override\n   */\n  stop() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: 'Ask Role Slave To Stop'.cyan,\n          });\n\n        // Stop all its tasks\n        await this.getTaskHandler()\n          .stopAllTask();\n\n        // Stop the infinite loops\n        if (this.intervalFdCpuAndMemory) clearInterval(this.intervalFdCpuAndMemory);\n\n        if (this.intervalFdTasksInfos) clearInterval(this.intervalFdTasksInfos);\n\n        // Stop the communication system\n        await this.communicationSystem.stop();\n\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: 'Role Slave Stopped'.red,\n          });\n\n        this.active = false;\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Send the data to the server\n   * @param {String} data\n   */\n  sendMessageToServer(data) {\n    this.getCommunicationSystem()\n      .sendMessageToServer(data);\n  }\n\n  /**\n   * Wait a specific incoming message from the server\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * If there is no answer before the timeout, stop waiting and send an error\n   * @param {String} headString\n   * @param {Number} timeout - in ms\n   */\n  getMessageFromServer(headString, timeout = CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        let timeoutFunction = false;\n\n        // Function that will receive messages from the server\n        const msgListener = (dataString) => {\n          const dataJSON = Utils.convertStringToJSON(dataString);\n\n          // Here we got all messages that comes from the server\n          // Check if the message answer particular message\n          if (dataJSON && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] === headString) {\n            // Stop the timeout\n            clearTimeout(timeoutFunction);\n\n            // Stop the listening\n            this.getCommunicationSystem()\n              .unlistenToIncomingMessage(msgListener);\n\n            // We get our message\n            return resolve(dataJSON[CONSTANT.PROTOCOL_KEYWORDS.BODY]);\n          }\n\n          return false;\n        };\n\n        // If the function get triggered, we reject an error\n        timeoutFunction = setTimeout(() => {\n          // Stop the listening\n          this.getCommunicationSystem()\n            .unlistenToIncomingMessage(msgListener);\n\n          // Return an error\n          return reject(new Errors('E7005'));\n        }, timeout);\n\n        // Listen to incoming messages\n        return this.getCommunicationSystem()\n          .listenToIncomingMessage(msgListener);\n      }),\n    });\n  }\n\n  /**\n   * Send the given message and wait for the response\n   *\n   * HERE WE CREATE TWO EXECUTIONS LIFES\n   *\n   * Put isHeadBodyPattern = true if you want to use the headBodyPattern\n   *\n   * @param {Object} args\n   */\n  sendMessageAndWaitForTheResponse({\n    messageHeaderToSend,\n    messageBodyToSend,\n    messageHeaderToGet,\n    isHeadBodyPattern,\n\n    // Can be equals to undefined -> default timeout\n    timeoutToGetMessage,\n  }) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        let errAlreadyReturned = false;\n\n        // Be ready to get the message from the slave before to send it the command\n        this.getMessageFromServer(messageHeaderToGet, timeoutToGetMessage)\n          // Job done\n          .then(resolve)\n          .catch((err) => {\n            if (!errAlreadyReturned) {\n              errAlreadyReturned = true;\n\n              return reject(err);\n            }\n\n            return false;\n          });\n\n        // Send the command to the slave\n        if (isHeadBodyPattern) return this.sendHeadBodyMessageToServer(messageHeaderToSend, messageBodyToSend);\n\n        return this.sendMessageToServer(messageBodyToSend);\n\n        // It went well, no wait getMessageFromServer to get the message\n        // If the message is not coming, getMessageFromServer will timeout and result of an error\n\n        //\n        // Nothing to do here anymore Mate!\n        //\n      }),\n    });\n  }\n}\n"]}