{"version":3,"sources":["../../src/RoleAndTask.es6"],"names":["instance","RoleAndTask","launchMasterSlaveConfigurationFile","pathToEntryFile","displayTask","displayLog","makesErrorFatal","CONSTANT","MAKES_ERROR_FATAL","considerWarningAsErrors","CONSIDER_WARNING_AS_ERRORS","masterMessageWaitingTimeout","MASTER_MESSAGE_WAITING_TIMEOUT","masterMessageWaitingTimeoutStateChange","MASTER_MESSAGE_WAITING_TIMEOUT_STATE_CHANGE","masterMessageWaitingTimeoutStopTask","MASTER_MESSAGE_WAITING_TIMEOUT_STOP_TASK","tasks","Object","keys","DEFAULT_TASK","map","x","filter","id","roles","DEFAULT_ROLES","states","DEFAULT_STATES","stateChangeCallbacks","programState","LAUNCHING","programStateChangeWaitingList","customLaunchingMode","quitOrder","masterMutexValidationFunctions","handleSignals","length","inProgress","errorElement","some","ERROR","elem","lookAtProgramStateChangePipe","forEach","callback","setImmediate","find","PromiseCommandPattern","func","elementToTreat","getProgramStateChangeToTreat","resolve","programChangeElementGotTreated","oldProgramState","getSlaveNorMaster","role","MASTER_ROLE","handleProgramStateChange","ret","spreadStateToListener","reject","SystemBoot","require","systemBoot","mode","modeoptions","initialization","obj","getInstance","roleHandler","RoleHandler","launch","startDate","Date","descriptor","Utils","generateLittleID","push","name","stateConfiguration","roleConfiguration","taskConfiguration","taskName","idRole","idsAllowedRole","includes","possibilities","i","Errors","getRole","isActive","promiseCallUntilTrue","functionToCall","getActualRole","context","args","idProgramState","Promise","param","isString","isAString","str","displayMessage","from","getTheTaskWhoPerformTheDisplay","time","now","newParam","JSON","stringify","err","String","stack","out","process","stderr","tellMasterErrorHappened","changeProgramState","tags","MESSAGE_DISPLAY_TAGS","exitProgramUnproperDueToError","exitProgramMsg","CLOSE","quit","makeTheMasterToQuitEverySlaveAndTask","exitProgramGood","errorHappened","signalActionProper","makeTheMasterToQuitTheWholeApp","signalActionUnproper","SIGNAL","on","SIGNAL_UNPROPER","dataName","data","timestamp","limitToTaskList","getTaskHandler","getAllActiveTasks","y","setTimeout","consumeNewsData","getMasterRole","getFullSystemPids","getRoleHandler","roleMaster","stop","opts","availableOpts","mandatoryOpts","reduce","tmp","setted","values","Error","takeMutex","releaseMutex","funcTake","funcRelease","boot","activeTasks","pid","txt","e","exit","TIMEOUT_LEAVE_PROGRAM_UNPROPER","declareRole","declareState","declareTask","removeTask"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AAEA,IAAIA,QAAQ,GAAG,IAAf;AAEA;;;;IAGqBC,W;;;AACnB;;;AAGA,yBAAc;AAAA;AACZ,QAAID,QAAJ,EAAc,OAAOA,QAAP,CADF,CAGZ;AACA;AACA;AAEA;;AACA,SAAKE,kCAAL,GAA0C,KAA1C,CARY,CAUZ;;AACA,SAAKC,eAAL,GAAuB,KAAvB,CAXY,CAaZ;;AACA,SAAKC,WAAL,GAAmB,KAAnB,CAdY,CAgBZ;AACA;AACA;AAEA;;AACA,SAAKC,UAAL,GAAkB,IAAlB,CArBY,CAuBZ;;AACA,SAAKC,eAAL,GAAuBC,qBAASC,iBAAhC,CAxBY,CA0BZ;;AACA,SAAKC,uBAAL,GAA+BF,qBAASG,0BAAxC,CA3BY,CA6BZ;;AACA,SAAKC,2BAAL,GAAmCJ,qBAASK,8BAA5C,CA9BY,CAgCZ;;AACA,SAAKC,sCAAL,GAA8CN,qBAASO,2CAAvD,CAjCY,CAmCZ;;AACA,SAAKC,mCAAL,GAA2CR,qBAASS,wCAApD,CApCY,CAsCZ;AACA;AAEA;;AACA,SAAKC,KAAL,GAAa,oCACRC,MAAM,CAACC,IAAP,CAAYZ,qBAASa,YAArB,EACFC,GADE,CACE,UAAAC,CAAC;AAAA,aAAIf,qBAASa,YAAT,CAAsBE,CAAtB,CAAJ;AAAA,KADH,CADQ,EAGXC,MAHW,CAGJ,UAAAD,CAAC;AAAA,aAAIA,CAAC,CAACE,EAAF,KAAS,CAAC,CAAd;AAAA,KAHG,CAAb,CA1CY,CA+CZ;;AACA,SAAKC,KAAL,GAAa,oCACRP,MAAM,CAACC,IAAP,CAAYZ,qBAASmB,aAArB,EACFL,GADE,CACE,UAAAC,CAAC;AAAA,aAAIf,qBAASmB,aAAT,CAAuBJ,CAAvB,CAAJ;AAAA,KADH,CADQ,EAGXC,MAHW,CAGJ,UAAAD,CAAC;AAAA,aAAIA,CAAC,CAACE,EAAF,KAAS,CAAC,CAAd;AAAA,KAHG,CAAb,CAhDY,CAqDZ;;AACA,SAAKG,MAAL,uCACKT,MAAM,CAACC,IAAP,CAAYZ,qBAASqB,cAArB,EACFP,GADE,CACE,UAAAC,CAAC;AAAA,aAAIf,qBAASqB,cAAT,CAAwBN,CAAxB,CAAJ;AAAA,KADH,CADL,EAtDY,CA2DZ;;AACA,SAAKO,oBAAL,GAA4B,EAA5B,CA5DY,CA8DZ;;AACA,SAAKC,YAAL,GAAoBvB,qBAASqB,cAAT,CAAwBG,SAA5C,CA/DY,CAiEZ;;AACA,SAAKC,6BAAL,GAAqC,EAArC,CAlEY,CAoEZ;AACA;;AACA,SAAKC,mBAAL,GAA2B,EAA3B,CAtEY,CAwEZ;;AACA,SAAKC,SAAL,GAAiB,KAAjB,CAzEY,CA2EZ;;AACA,SAAKC,8BAAL,GAAsC,EAAtC,CA5EY,CA8EZ;;AACA,SAAKC,aAAL;AAEApC,IAAAA,QAAQ,GAAG,IAAX;AAEA,WAAOA,QAAP;AACD,G,CAED;AACA;AACA;;AAEA;;;;;;;;mDAI+B;AAC7B;AACA,UAAI,CAAC,KAAKgC,6BAAL,CAAmCK,MAAxC,EAAgD,OAAO,KAAP;AAEhD,UAAIC,UAAU,GAAG,KAAjB;AACA,UAAIC,YAAY,GAAG,KAAnB;AAEA,WAAKP,6BAAL,CAAmCQ,IAAnC,CAAwC,UAAClB,CAAD,EAAO;AAC7C;AACA,YAAIA,CAAC,CAACgB,UAAN,EAAkBA,UAAU,GAAG,IAAb;;AAElB,YAAIhB,CAAC,CAACQ,YAAF,CAAeN,EAAf,KAAsBjB,qBAASqB,cAAT,CAAwBa,KAAxB,CAA8BjB,EAAxD,EAA4D;AAC1De,UAAAA,YAAY,GAAGjB,CAAf;AAEA,iBAAO,IAAP;AACD;;AAED,eAAO,KAAP;AACD,OAXD,EAP6B,CAoB7B;;AACA,UAAIiB,YAAJ,EAAkB,OAAOA,YAAP,CArBW,CAuB7B;;AACA,UAAID,UAAJ,EAAgB,OAAO,KAAP,CAxBa,CA0B7B;;AACA,aAAO,KAAKN,6BAAL,CAAmC,CAAnC,CAAP;AACD;AAED;;;;;;;mDAI+BU,I,EAAM;AACnC,WAAKV,6BAAL,GAAqC,KAAKA,6BAAL,CAAmCT,MAAnC,CAA0C,UAAAD,CAAC;AAAA,eAAIA,CAAC,KAAKoB,IAAV;AAAA,OAA3C,CAArC,CADmC,CAGnC;;AACA,WAAKC,4BAAL;AACD;AAED;;;;;;4CAGwB;AAAA;;AACtB,WAAKd,oBAAL,CAA0Be,OAA1B,CAAkC,gBAE5B;AAAA,YADJC,QACI,QADJA,QACI;AACJC,QAAAA,YAAY,CAAC;AAAA,iBAAMD,QAAQ,CAAC,KAAI,CAAClB,MAAL,CAAYoB,IAAZ,CAAiB,UAAAzB,CAAC;AAAA,mBAAIA,CAAC,CAACE,EAAF,KAAS,KAAI,CAACM,YAAL,CAAkBN,EAA/B;AAAA,WAAlB,CAAD,CAAd;AAAA,SAAD,EAAuE,CAAvE,CAAZ;AACD,OAJD;AAKD;AAED;;;;;;;;;;mDAO+B;AAAA;;AAC7B,aAAO,IAAIwB,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AACEC,oBAAAA,cADF,GACmB,MAAI,CAACC,4BAAL,EADnB,EAGJ;;AAHI,wBAICD,cAJD;AAAA;AAAA;AAAA;;AAAA,qDAIwB,KAJxB;;AAAA;AAMJA,oBAAAA,cAAc,CAACZ,UAAf,GAA4B,IAA5B,CANI,CAQJ;;AARI,0BASAY,cAAc,CAACpB,YAAf,CAA4BN,EAA5B,KAAmC,MAAI,CAACM,YAAL,CAAkBN,EATrD;AAAA;AAAA;AAAA;;AAUF;AACA0B,oBAAAA,cAAc,CAACE,OAAf;AAXE,qDAaK,MAAI,CAACC,8BAAL,CAAoCH,cAApC,CAbL;;AAAA;AAgBEI,oBAAAA,eAhBF,GAgBoB,MAAI,CAACxB,YAhBzB;AAkBJ,oBAAA,MAAI,CAACA,YAAL,GAAoBoB,cAAc,CAACpB,YAAnC;AAlBI;AAAA;AAAA,2BAqBiB,MAAI,CAACyB,iBAAL,EArBjB;;AAAA;AAqBIC,oBAAAA,IArBJ;;AAAA,0BAwBEA,IAAI,CAAChC,EAAL,KAAYjB,qBAASmB,aAAT,CAAuB+B,WAAvB,CAAmCjC,EAxBjD;AAAA;AAAA;AAAA;;AAAA;AAAA,2BAyBkBgC,IAAI,CAACE,wBAAL,CAA8BR,cAAc,CAACpB,YAA7C,EAA2DwB,eAA3D,CAzBlB;;AAAA;AAyBMK,oBAAAA,GAzBN;;AA2BA;AACA,oBAAA,MAAI,CAACC,qBAAL;;AAEAV,oBAAAA,cAAc,CAACE,OAAf,CAAuBO,GAAvB;AA9BA,qDAgCO,MAAI,CAACN,8BAAL,CAAoCH,cAApC,CAhCP;;AAAA;AAmCF;AACA,oBAAA,MAAI,CAACU,qBAAL,GApCE,CAsCF;;;AACAV,oBAAAA,cAAc,CAACE,OAAf;AAvCE,qDAyCK,MAAI,CAACC,8BAAL,CAAoCH,cAApC,CAzCL;;AAAA;AAAA;AAAA;AA2CFA,oBAAAA,cAAc,CAACW,MAAf;AA3CE,qDA6CK,MAAI,CAACR,8BAAL,CAAoCH,cAApC,CA7CL;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAkDD,K,CAED;AACA;AACA;;AAEA;;;;;;;AAOA;;;;;2BAKO;AACL,UAAMY,UAAU,GAAGC,OAAO,CAAC,4BAAD,CAAP,WAAnB;;AAGA,WAAKC,UAAL,GAAkB,IAAIF,UAAJ,CAAe;AAC/BG,QAAAA,IAAI,EAAE,KAAKA,IADoB;AAE/BC,QAAAA,WAAW,EAAE,KAAKA;AAFa,OAAf,EAGfC,cAHe,EAAlB,CAJK,CASL;;AACA,WAAK1C,KAAL,GAAa,KAAKA,KAAL,CAAWJ,GAAX,CAAe,UAAAC,CAAC;AAAA,kDACxBA,CADwB;AAG3B8C,UAAAA,GAAG,EAAE9C,CAAC,SAAD,CAAQ+C,WAAR;AAHsB;AAAA,OAAhB,CAAb,CAVK,CAgBL;;AACA,WAAKC,WAAL,GAAmB,IAAIC,uBAAJ,CAAgB,KAAK9C,KAArB,CAAnB;AAEA,WAAKuC,UAAL,CACGQ,MADH,CACU,KAAKtE,kCADf;AAGA,WAAKuE,SAAL,GAAiB,IAAIC,IAAJ,EAAjB;AACD;AAED;;;;;;;AAQA;;;2CAGuB7B,Q,EAAU;AAC/B,UAAM8B,UAAU,GAAGC,kBAAMC,gBAAN,EAAnB;;AAEA,WAAKhD,oBAAL,CAA0BiD,IAA1B,CAA+B;AAC7BjC,QAAAA,QAAQ,EAARA,QAD6B;AAE7B8B,QAAAA,UAAU,EAAVA;AAF6B,OAA/B;AAKA,aAAOA,UAAP;AACD;AAED;;;;;;6CAGyBA,U,EAAY;AACnC,WAAK9C,oBAAL,GAA4B,KAAKA,oBAAL,CAA0BN,MAA1B,CAAiC,UAAAD,CAAC;AAAA,eAAIA,CAAC,CAACqD,UAAF,KAAiBA,UAArB;AAAA,OAAlC,CAA5B;AACD;AAED;;;;;;;;;;yCAOqBI,I,EAAM9B,I,EAAM;AAC/B,WAAKhB,mBAAL,CAAyB6C,IAAzB,CAA8B;AAC5BC,QAAAA,IAAI,EAAJA,IAD4B;AAE5B9B,QAAAA,IAAI,EAAJA;AAF4B,OAA9B;AAID;AAED;;;;;;2CAGuB8B,I,EAAM;AAC3B,WAAK9C,mBAAL,GAA2B,KAAKA,mBAAL,CAAyBV,MAAzB,CAAgC,UAAAD,CAAC;AAAA,eAAIA,CAAC,CAACyD,IAAF,KAAWA,IAAf;AAAA,OAAjC,CAA3B;AACD;AAED;;;;;;;;;;;iCAQaC,kB,EAAoB;AAC/B,WAAKrD,MAAL,CAAYmD,IAAZ,CAAiBE,kBAAjB;AACD;AAED;;;;;;;;;;;;gCASYC,iB,EAAmB;AAC7B,WAAKxD,KAAL,CAAWqD,IAAX,CAAgBG,iBAAhB;AACD;AAED;;;;;;;;;;;;;;;;;;gCAeYC,iB,EAAmB;AAC7B,WAAKjE,KAAL,CAAW6D,IAAX,CAAgBI,iBAAhB;AACD;AAED;;;;;;+BAGWC,Q,EAAU;AACnB,WAAKlE,KAAL,GAAa,KAAKA,KAAL,CAAWM,MAAX,CAAkB,UAAAD,CAAC;AAAA,eAAIA,CAAC,CAACE,EAAF,KAAS2D,QAAb;AAAA,OAAnB,CAAb;AACD;AAED;;;;;;iCAGaC,M,EAAQ;AACnB,aAAO,KAAKnE,KAAL,CAAWM,MAAX,CAAkB,UAAAD,CAAC;AAAA,eAAIA,CAAC,CAAC+D,cAAF,CAAiBC,QAAjB,CAA0BF,MAA1B,CAAJ;AAAA,OAAnB,CAAP;AACD;AAED;;;;;;+BAGW;AACT,aAAO,KAAK3D,KAAL,CAAWJ,GAAX,CAAe,UAACC,CAAD,EAAO;AACzB,YAAIA,CAAC,CAACE,EAAF,KAAS,CAAC,CAAd,EAAiB,OAAO,KAAP;AAEjB,kDACKF,CADL;AAGE8C,UAAAA,GAAG,EAAE9C,CAAC,SAAD,CAAQ+C,WAAR;AAHP;AAKD,OARI,EASJ9C,MATI,CASG,UAAAD,CAAC;AAAA,eAAIA,CAAJ;AAAA,OATJ,CAAP;AAUD;AAED;;;;;;kCAGciE,a,EAAeC,C,EAAG;AAAA;;AAC9B,aAAO,IAAIxC,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAEAuC,CAAC,IAAID,aAAa,CAAClD,MAFnB;AAAA;AAAA;AAAA;;AAAA,0BAEiC,IAAIoD,kBAAJ,CAAW,OAAX,EAAoB,mBAApB,CAFjC;;AAAA;AAAA;AAAA,2BAKe,MAAI,CAACnB,WAAL,CAAiBoB,OAAjB,CAAyBH,aAAa,CAACC,CAAD,CAAtC,CALf;;AAAA;AAKEhC,oBAAAA,IALF;;AAAA,wBAQCA,IAAI,CAACmC,QAAL,EARD;AAAA;AAAA;AAAA;;AAAA,sDAUK,KAVL;;AAAA;AAAA,sDAcGnC,IAdH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAkBD;AAED;;;;;;;wCAIoB;AAAA;;AAClB,aAAO,IAAIR,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI,EAAE;AAAA,iBAAM2B,kBAAMgB,oBAAN,CAA2B;AACrCC,YAAAA,cAAc,EAAE,MAAI,CAACC,aADgB;AAErCC,YAAAA,OAAO,EAAE,MAF4B;AAIrCC,YAAAA,IAAI,EAAE,CACJ,MAAI,CAACvE,KAAL,CAAWJ,GAAX,CAAe,UAAAC,CAAC;AAAA,qBAAIA,CAAC,CAACE,EAAN;AAAA,aAAhB,CADI;AAJ+B,WAA3B,CAAN;AAAA;AADyB,OAA1B,CAAP;AAUD;AAED;;;;;;;;uCAKmByE,c,EAAgB;AAAA;;AACjC,aAAO,IAAIjD,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI,EAAE;AAAA,iBAAM,IAAIiD,OAAJ,CAAY,UAAC9C,OAAD,EAAUS,MAAV,EAAqB;AAC3C;AACA,YAAA,MAAI,CAAC7B,6BAAL,CAAmC8C,IAAnC,CAAwC;AACtC1B,cAAAA,OAAO,EAAPA,OADsC;AAEtCS,cAAAA,MAAM,EAANA,MAFsC;AAGtC/B,cAAAA,YAAY,EAAE,MAAI,CAACH,MAAL,CAAYoB,IAAZ,CAAiB,UAAAzB,CAAC;AAAA,uBAAIA,CAAC,CAACE,EAAF,KAASyE,cAAb;AAAA,eAAlB,CAHwB;AAItC3D,cAAAA,UAAU,EAAE;AAJ0B,aAAxC;;AAOA,YAAA,MAAI,CAACK,4BAAL;AACD,WAVW,CAAN;AAAA;AADyB,OAA1B,CAAP;AAaD;AAED;;;;;;;AAYA;;;;;;mCAMewD,K,EAAO;AAAA;;AACpB,aAAO,IAAInD,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAEiB,MAAI,CAACM,iBAAL,EAFjB;;AAAA;AAEIC,oBAAAA,IAFJ;AAIF;AACM4C,oBAAAA,QALJ,GAKexB,kBAAMyB,SAAN,CAAgBF,KAAK,CAACG,GAAtB,CALf;;AAAA,yBAOEF,QAPF;AAAA;AAAA;AAAA;;AAAA,sDAQO5C,IAAI,CAAC+C,cAAL,oCACFJ,KADE;AAGL;AACAK,sBAAAA,IAAI,EAAEvG,WAAW,CAACwG,8BAAZ,CAA2CjD,IAA3C,CAJD;AAMLkD,sBAAAA,IAAI,EAAEhC,IAAI,CAACiC,GAAL;AAND,uBARP;;AAAA;AAkBIC,oBAAAA,QAlBJ,sCAmBGT,KAnBH;AAqBA;AACAK,sBAAAA,IAAI,EAAEvG,WAAW,CAACwG,8BAAZ,CAA2CjD,IAA3C,CAtBN;AAwBAkD,sBAAAA,IAAI,EAAEhC,IAAI,CAACiC,GAAL;AAxBN;AA2BFC,oBAAAA,QAAQ,CAACN,GAAT,GAAeO,IAAI,CAACC,SAAL,CAAeF,QAAQ,CAACN,GAAxB,EAA6B,IAA7B,EAAmC,CAAnC,CAAf,CA3BE,CA6BF;;AA7BE,sDA+BK9C,IAAI,CAAC+C,cAAL,CAAoBK,QAApB,CA/BL;;AAAA;AAAA;AAAA;AAAA,sDAqCK,KArCL;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AA0CD;AAED;;;;;;;;kCAKcG,G,EAAK;AAAA;;AACjB,aAAO,IAAI/D,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AACJ;AACA2B,sCAAM2B,cAAN,CAAqB;AACnBD,sBAAAA,GAAG,EAAEU,MAAM,CAAED,GAAG,IAAIA,GAAG,CAACE,KAAZ,IAAsBF,GAAvB,CADQ;AAGnBG,sBAAAA,GAAG,EAAEC,OAAO,CAACC;AAHM,qBAArB;;AAFI;AAAA;AAAA,2BASiB,MAAI,CAAC7D,iBAAL,EATjB;;AAAA;AASIC,oBAAAA,IATJ;;AAAA,0BAWEA,IAAI,CAAChC,EAAL,KAAYjB,qBAASmB,aAAT,CAAuB+B,WAAvB,CAAmCjC,EAXjD;AAAA;AAAA;AAAA;;AAAA,sDAaOgC,IAAI,CAAC6D,uBAAL,CAA6BN,GAA7B,CAbP;;AAAA;AAAA;AAAA;AAAA,2BAkBM,MAAI,CAACO,kBAAL,CAAwB/G,qBAASqB,cAAT,CAAwBa,KAAxB,CAA8BjB,EAAtD,CAlBN;;AAAA;AAoBA;AACA;AACA,oBAAA,MAAI,CAAC+E,cAAL,CAAoB;AAClBD,sBAAAA,GAAG,EAAEU,MAAM,CAAED,GAAG,IAAIA,GAAG,CAACE,KAAZ,IAAsBF,GAAvB,CADO;AAGlBQ,sBAAAA,IAAI,EAAE,CACJhH,qBAASiH,oBAAT,CAA8B/E,KAD1B;AAHY,qBAApB,EAtBA,CA8BA;;;AACA,wBAAIxC,WAAW,CAACoE,WAAZ,GACD/D,eADH,EACoB;AAClBL,sBAAAA,WAAW,CAACwH,6BAAZ;AACD;;AAlCD;AAAA;;AAAA;AAAA;AAAA;AAoCA;AACA;AACAxH,oBAAAA,WAAW,CAACyH,cAAZ,CAA2B,sCAA3B,EAAmEX,GAAnE,gBAtCA,CAwCA;;AACA9G,oBAAAA,WAAW,CAACwH,6BAAZ;;AAzCA;AAAA;AAAA;;AAAA;AAAA;AAAA;AA4CFxH,oBAAAA,WAAW,CAACyH,cAAZ,CAA2B,4CAA3B,EAAyEX,GAAzE,gBA5CE,CA8CF;;AACA9G,oBAAAA,WAAW,CAACwH,6BAAZ;;AA/CE;AAAA,sDAkDG,KAlDH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAsDD;AAED;;;;;;;AAsBA;;;;2DAIuC;AAAA;;AACrC,aAAO,IAAIzE,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAEA,MAAI,CAACf,SAFL;AAAA;AAAA;AAAA;;AAAA,sDAEuB,KAFvB;;AAAA;AAIJ,oBAAA,MAAI,CAACA,SAAL,GAAiB,IAAjB;AAJI;AAAA,2BAMe,MAAI,CAACqB,iBAAL,EANf;;AAAA;AAMEC,oBAAAA,IANF;;AAAA,0BASAA,IAAI,CAAChC,EAAL,KAAYjB,qBAASmB,aAAT,CAAuB+B,WAAvB,CAAmCjC,EAT/C;AAAA;AAAA;AAAA;;AAAA,0BASyD,IAAIiE,kBAAJ,CAAW,OAAX,EAAoB,iCAApB,CATzD;;AAAA;AAAA;AAAA,2BAcE,MAAI,CAAC6B,kBAAL,CAAwB/G,qBAASqB,cAAT,CAAwB+F,KAAxB,CAA8BnG,EAAtD,CAdF;;AAAA;AAAA,sDAgBG,MAAI,CAACoG,IAAL,EAhBH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAoBD;AAED;;;;;;;qDAIiC;AAAA;;AAC/B,aAAO,IAAI5E,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAEA,MAAI,CAACnB,YAAL,CAAkBN,EAAlB,KAAyBjB,qBAASqB,cAAT,CAAwBG,SAAxB,CAAkCP,EAF3D;AAAA;AAAA;AAAA;;AAGF,oBAAA,MAAI,CAAC+E,cAAL,CAAoB;AAClBD,sBAAAA,GAAG,EAAE;AADa,qBAApB;;AAHE;;AAAA;AAAA;AAAA;AAAA,2BAWiB,MAAI,CAACuB,oCAAL,EAXjB;;AAAA;AAWID,oBAAAA,IAXJ;AAaF,wBAAIA,IAAJ,EAAU3H,WAAW,CAAC6H,eAAZ,GAbR,CAeF;AACA;;AAhBE;AAAA;;AAAA;AAAA;AAAA;AAkBF7H,oBAAAA,WAAW,CAACoE,WAAZ,GACG0D,aADH;;AAlBE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAwBD;AAED;;;;;;;;AAqBA;;;oCAGgB;AAAA;;AACd;AACA,UAAMC,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA,qCAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACN,OAAI,CAACzE,iBAAL,EADM;;AAAA;AACnBC,kBAAAA,IADmB;;AAAA,wBAIrBA,IAAI,CAAChC,EAAL,KAAYjB,qBAASmB,aAAT,CAAuB+B,WAAvB,CAAmCjC,EAJ1B;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAMzB,kBAAA,OAAI,CAACyG,8BAAL;;AANyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAH;;AAAA,wBAAlBD,kBAAkB;AAAA;AAAA;AAAA,SAAxB,CAFc,CAWd;;;AACA,UAAME,oBAAoB,GAAG,SAAvBA,oBAAuB,GAAM;AACjCjI,QAAAA,WAAW,CAACwH,6BAAZ;AACD,OAFD;;AAIAvG,MAAAA,MAAM,CAACC,IAAP,CAAYZ,qBAAS4H,MAArB,EACGvF,OADH,CACW,UAACtB,CAAD,EAAO;AACd6F,QAAAA,OAAO,CAACiB,EAAR,CAAW7H,qBAAS4H,MAAT,CAAgB7G,CAAhB,CAAX,EAA+B;AAAA,iBAAM0G,kBAAkB,EAAxB;AAAA,SAA/B;AACD,OAHH;AAKA9G,MAAAA,MAAM,CAACC,IAAP,CAAYZ,qBAAS8H,eAArB,EACGzF,OADH,CACW,UAACtB,CAAD,EAAO;AACd6F,QAAAA,OAAO,CAACiB,EAAR,CAAW7H,qBAAS8H,eAAT,CAAyB/G,CAAzB,CAAX,EAAwC;AAAA,iBAAM4G,oBAAoB,EAA1B;AAAA,SAAxC;AACD,OAHH;AAID;AAED;;;;;;;sDASG;AAAA;;AAAA,UAJDI,QAIC,SAJDA,QAIC;AAAA,UAHDC,IAGC,SAHDA,IAGC;AAAA,UAFDC,SAEC,SAFDA,SAEC;AAAA,UADDC,eACC,SADDA,eACC;AACD,aAAO,IAAIzF,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAEiB,OAAI,CAACM,iBAAL,EAFjB;;AAAA;AAEIC,oBAAAA,IAFJ;AAIFA,oBAAAA,IAAI,CAACkF,cAAL,GACGC,iBADH,GAEG/F,OAFH,CAEW,UAACtB,CAAD,EAAO;AACd;AACA,0BAAI,CAACmH,eAAD,IAAoBA,eAAe,CAACjG,IAAhB,CAAqB,UAAAoG,CAAC;AAAA,+BAAItH,CAAC,CAACE,EAAF,KAASoH,CAAb;AAAA,uBAAtB,CAAxB,EAA+D;AAC7D;AACAC,wBAAAA,UAAU,CAAC,YAAM;AACfvH,0BAAAA,CAAC,CAACwH,eAAF,CAAkBR,QAAlB,EAA4BC,IAA5B,EAAkCC,SAAlC;AACD,yBAFS,EAEP,CAFO,CAAV;AAGD;AACF,qBAVH;AAJE;AAAA;;AAAA;AAAA;AAAA;;AAgBF,oBAAA,OAAI,CAACT,aAAL;;AAhBE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAqBD;AAED;;;;;;;;;wCAMoB;AAAA;;AAClB,aAAO,IAAI/E,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BACe,OAAI,CAAC8F,aAAL,EADf;;AAAA;AACEvF,oBAAAA,IADF;AAAA,sDAGGA,IAAI,CAACwF,iBAAL,EAHH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAOD;AAED;;;;;;oCAGgB;AAAA;;AACd,aAAO,IAAIhG,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BACqB,OAAI,CAACgG,cAAL,GACtBvD,OADsB,CACdnF,qBAASmB,aAAT,CAAuB+B,WAAvB,CAAmCjC,EADrB,CADrB;;AAAA;AACE0H,oBAAAA,UADF;;AAAA,wBAKCA,UAAU,CAACvD,QAAX,EALD;AAAA;AAAA;AAAA;;AAAA,0BAK8B,IAAIF,kBAAJ,CAAW,OAAX,EAAoB,uCAApB,CAL9B;;AAAA;AAAA,uDAQGyD,UARH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAYD,K,CAED;;;;qCACiB;AACf,aAAO,KAAK5E,WAAZ;AACD;AAED;;;;;;;;;;;;2BASO;AAAA;;AACL,aAAO,IAAItB,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BACe,OAAI,CAACM,iBAAL,EADf;;AAAA;AACEC,oBAAAA,IADF;AAAA;AAAA,2BAGEA,IAAI,CAAC2F,IAAL,EAHF;;AAAA;AAAA,uDAKG,IALH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AASD;AAED;;;;;;;;;;;;;AAuDA;;;;;qCAKiBC,I,EAAM;AAAA;;AACrB,UAAMC,aAAa,GAAG,CACpB,MADoB,EAEpB,aAFoB,EAGpB,aAHoB,EAIpB,oCAJoB,EAKpB,iBALoB,EAMpB,YANoB,EAOpB,iBAPoB,EAQpB,yBARoB,EASpB,6BAToB,EAUpB,wCAVoB,EAWpB,qCAXoB,CAAtB;AAcA,UAAMC,aAAa,GAAG,CACpB,MADoB,EAEpB,aAFoB,EAGpB,oCAHoB,EAIpB,iBAJoB,EAKpBC,MALoB,CAKb,UAACC,GAAD,EAAMlI,CAAN,EAAY;AACnBkI,QAAAA,GAAG,CAAClI,CAAD,CAAH,GAAS,IAAT;AACA,eAAOkI,GAAP;AACD,OARqB,EAQnB,EARmB,CAAtB;AAUA,UAAMC,MAAM,GAAGvI,MAAM,CAACC,IAAP,CAAYiI,IAAZ,EACZG,MADY,CACL,UAACC,GAAD,EAAMlI,CAAN,EAAY;AAClB;AACA,YAAI,CAAC+H,aAAa,CAAC/D,QAAd,CAAuBhE,CAAvB,CAAL,EAAgC,OAAOkI,GAAP,CAFd,CAIlB;;AACA,QAAA,OAAI,CAAClI,CAAD,CAAJ,GAAU8H,IAAI,CAAC9H,CAAD,CAAd;AAEAkI,QAAAA,GAAG,CAAClI,CAAD,CAAH,GAAS8H,IAAI,CAAC9H,CAAD,CAAb;;AAEA,YAAIgI,aAAa,CAAChI,CAAD,CAAb,KAAqB,KAAK,CAA9B,EAAiC;AAC/BgI,UAAAA,aAAa,CAAChI,CAAD,CAAb,GAAmB,IAAnB;AACD;;AAED,eAAOkI,GAAP;AACD,OAfY,EAeV,EAfU,CAAf;;AAiBA,UAAItI,MAAM,CAACwI,MAAP,CAAcJ,aAAd,EAA6BhE,QAA7B,CAAsC,IAAtC,CAAJ,EAAiD;AAC/C,cAAM,IAAIqE,KAAJ,4BAA8BzI,MAAM,CAACC,IAAP,CAAYmI,aAAZ,EAA2BvG,IAA3B,CAAgC,UAAAzB,CAAC;AAAA,iBAAIgI,aAAa,CAAChI,CAAD,CAAb,KAAqB,IAAzB;AAAA,SAAjC,CAA9B,iBAAN;AACD,OA5CoB,CA8CrB;;;AACA,WAAKiF,cAAL,CAAoB;AAClBD,QAAAA,GAAG,EAAE;AADa,OAApB;AAIA,WAAKC,cAAL,CAAoB;AAClBD,QAAAA,GAAG,EAAEmD;AADa,OAApB;AAIA,aAAOA,MAAP;AACD;AAED;;;;;;;;8BAKUjI,E,EAAI;AAAA;;AACZ,aAAO,IAAIwB,iCAAJ,CAA0B;AAC/BC,QAAAA,IAAI;AAAA;AAAA;AAAA,uCAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BACe,OAAI,CAACM,iBAAL,EADf;;AAAA;AACEC,oBAAAA,IADF;AAAA,uDAGGA,IAAI,CAACoG,SAAL,CAAepI,EAAf,CAHH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,OAA1B,CAAP;AAOD;AAED;;;;;;;;;;;sDAKmBA,E;;;;;;;mDACV,IAAIwB,iCAAJ,CAA0B;AAC/BC,kBAAAA,IAAI;AAAA;AAAA;AAAA,iDAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qCACe,OAAI,CAACM,iBAAL,EADf;;AAAA;AACEC,8BAAAA,IADF;AAAA,iEAGGA,IAAI,CAACqG,YAAL,CAAkBrI,EAAlB,CAHH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAD2B,iBAA1B,C;;;;;;;;;;;;;;;;AAST;;;;;;8CAG0B;AACxB,aAAO,KAAKW,8BAAZ;AACD;AAED;;;;;;;;4CAKwBX,E,EAAIsI,Q,EAAUC,W,EAAa;AACjD,WAAK5H,8BAAL,CAAoC2C,IAApC,CAAyC;AACvCtD,QAAAA,EAAE,EAAFA,EADuC;AAEvCsI,QAAAA,QAAQ,EAARA,QAFuC;AAGvCC,QAAAA,WAAW,EAAXA;AAHuC,OAAzC;AAKD;;;kCA/tBoB;AACnB,aAAO/J,QAAQ,IAAI,IAAIC,WAAJ,EAAnB;AACD;;;2BAmCa;AACZA,MAAAA,WAAW,CAACoE,WAAZ,GACG2F,IADH;AAED;;;mDAuLqCxG,I,EAAM;AAC1C,UAAMyG,WAAW,GAAGzG,IAAI,CAACkF,cAAL,GACjBC,iBADiB,EAApB;AAGA,UAAI,CAACsB,WAAW,CAAC5H,MAAjB,EAAyB,iBAAU8E,OAAO,CAAC+C,GAAlB;AAEzB,aAAOD,WAAW,CAAC,CAAD,CAAX,CAAelF,IAAtB;AACD;;;mCAsHqBoF,G,EAAKpD,G,EAAKqD,C,EAAG;AACjC;AACAxF,wBAAM2B,cAAN,CAAqB;AACnBD,QAAAA,GAAG,EAAEU,MAAM,CAAED,GAAG,IAAIA,GAAG,CAACE,KAAZ,IAAsBF,GAAvB,CADQ;AAEnBG,QAAAA,GAAG,EAAEC,OAAO,CAACC;AAFM,OAArB,EAFiC,CAOjC;;;AACAxC,wBAAM2B,cAAN,CAAqB;AACnBD,QAAAA,GAAG,EAAEU,MAAM,CAACoD,CAAD,CADQ;AAEnBlD,QAAAA,GAAG,EAAEC,OAAO,CAACC;AAFM,OAArB;;AAKAxC,wBAAM2B,cAAN,CAAqB;AACnBD,QAAAA,GAAG,EAAE,4CADc;AAEnBY,QAAAA,GAAG,EAAEC,OAAO,CAACC;AAFM,OAArB;AAID;;;oDAgEsC;AACrC;AACAyB,MAAAA,UAAU,CAAC;AAAA,eAAM1B,OAAO,CAACkD,IAAR,CAAa,CAAb,CAAN;AAAA,OAAD,EAAwB9J,qBAAS+J,8BAAjC,CAAV;AACD;AAED;;;;;;sCAGyB;AACvB1F,wBAAM2B,cAAN,CAAqB;AACnBD,QAAAA,GAAG,EAAE,mBADc;AAEnBY,QAAAA,GAAG,EAAEC,OAAO,CAACC;AAFM,OAArB;;AAKAD,MAAAA,OAAO,CAACkD,IAAR,CAAa,CAAb;AACD;;;gCAsIkBpF,iB,EAAmB;AACpC,WAAKZ,WAAL,GACGkG,WADH,CACetF,iBADf;AAED;AAED;;;;;;;;;;;iCAQoBD,kB,EAAoB;AACtC,WAAKX,WAAL,GACGmG,YADH,CACgBxF,kBADhB;AAED;AAED;;;;;;;;;;;;;;;;;;gCAemBE,iB,EAAmB;AACpC,WAAKb,WAAL,GACGoG,WADH,CACevF,iBADf;AAED;AAED;;;;;;+BAGkBC,Q,EAAU;AAC1B,WAAKd,WAAL,GACGqG,UADH,CACcvF,QADd;AAED","sourcesContent":["import CONSTANT from './Utils/CONSTANT/CONSTANT.js';\nimport Utils from './Utils/Utils.js';\nimport Errors from './Utils/Errors.js';\nimport RoleHandler from './RoleSystem/Handlers/RoleHandler.js';\nimport PromiseCommandPattern from './Utils/PromiseCommandPattern.js';\n\nlet instance = null;\n\n/**\n * Class which is the interface with the library user\n */\nexport default class RoleAndTask {\n  /**\n   * Constructor working the Singleton way\n   */\n  constructor() {\n    if (instance) return instance;\n\n    //\n    // Mandatory to fill\n    //\n\n    // Set the Master Slave Configuration File to load\n    this.launchMasterSlaveConfigurationFile = false;\n\n    // Path to the entry point of your program, we use to pop a new slave\n    this.pathToEntryFile = false;\n\n    // The task we use to perform the displays : The task must be in master! If no task is provided here, the display is made to stdout\n    this.displayTask = false;\n\n    //\n    // Options\n    //\n\n    // Are we displaying the logs ?\n    this.displayLog = true;\n\n    // Do we makes the error to be fatal ? One error -> Exit\n    this.makesErrorFatal = CONSTANT.MAKES_ERROR_FATAL;\n\n    // Do we consider warning as errors ?\n    this.considerWarningAsErrors = CONSTANT.CONSIDER_WARNING_AS_ERRORS;\n\n    // The amount of time a master wait for a slave message before to timeout\n    this.masterMessageWaitingTimeout = CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT;\n\n    // The amount of time a master wait for a slave message to acknowledge the state change before to timeout\n    this.masterMessageWaitingTimeoutStateChange = CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT_STATE_CHANGE;\n\n    // The amount of time a master wait for a slave message before to timeout\n    this.masterMessageWaitingTimeoutStopTask = CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT_STOP_TASK;\n\n    //\n    //\n\n    // Contains all the tasks referenced\n    this.tasks = [\n      ...Object.keys(CONSTANT.DEFAULT_TASK)\n      .map(x => CONSTANT.DEFAULT_TASK[x]),\n    ].filter(x => x.id !== -1);\n\n    // Contains all the roles referenced\n    this.roles = [\n      ...Object.keys(CONSTANT.DEFAULT_ROLES)\n      .map(x => CONSTANT.DEFAULT_ROLES[x]),\n    ].filter(x => x.id !== -1);\n\n    // Contains all the states the system can have\n    this.states = [\n      ...Object.keys(CONSTANT.DEFAULT_STATES)\n      .map(x => CONSTANT.DEFAULT_STATES[x]),\n    ];\n\n    // Array where we store the functions to call when the state change\n    this.stateChangeCallbacks = [];\n\n    // The state of program patform\n    this.programState = CONSTANT.DEFAULT_STATES.LAUNCHING;\n\n    // All the orders in a row to change the program state\n    this.programStateChangeWaitingList = [];\n\n    // When poping a new process, we start it using a \"launching mode\", there are two basic launching mode for \"slave\" and \"master\"\n    // You can set up a custom launching mode\n    this.customLaunchingMode = [];\n\n    // Are we quitting?\n    this.quitOrder = false;\n\n    // Contains the functions to call to validate mutex take and release in master/slave protocol\n    this.masterMutexValidationFunctions = [];\n\n    // Handle the signals\n    this.handleSignals();\n\n    instance = this;\n\n    return instance;\n  }\n\n  //\n  // PRIVATE METHODS\n  //\n\n  /**\n   * Get the good element to treat (Look at specific behavior described into lookAtProgramStateChangePipe comment)\n   * (If there is actually something in progress, do nothing)\n   */\n  getProgramStateChangeToTreat() {\n    // No change to perform\n    if (!this.programStateChangeWaitingList.length) return false;\n\n    let inProgress = false;\n    let errorElement = false;\n\n    this.programStateChangeWaitingList.some((x) => {\n      // We do nothing if something is in progress exept if error\n      if (x.inProgress) inProgress = true;\n\n      if (x.programState.id === CONSTANT.DEFAULT_STATES.ERROR.id) {\n        errorElement = x;\n\n        return true;\n      }\n\n      return false;\n    });\n\n    // Error comes first\n    if (errorElement) return errorElement;\n\n    // Then in progress\n    if (inProgress) return false;\n\n    // Then regular\n    return this.programStateChangeWaitingList[0];\n  }\n\n  /**\n   * Some program element got treated, remove them from the pipe\n   * @param {Object} elem\n   */\n  programChangeElementGotTreated(elem) {\n    this.programStateChangeWaitingList = this.programStateChangeWaitingList.filter(x => x !== elem);\n\n    // look if there is something else to do\n    this.lookAtProgramStateChangePipe();\n  }\n\n  /**\n   * Send the message saying the state change to whom is interested to know\n   */\n  spreadStateToListener() {\n    this.stateChangeCallbacks.forEach(({\n      callback,\n    }) => {\n      setImmediate(() => callback(this.states.find(x => x.id === this.programState.id)), 0);\n    });\n  }\n\n  /**\n   * Look at the programStateChangeWaitingList array, and perform an program state change if we need to\n   * Specific behavior:\n   *\n   * (1) Error change state always pass first\n   * (2) When you want to change the state as something already true, resolve() directly\n   */\n  lookAtProgramStateChangePipe() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const elementToTreat = this.getProgramStateChangeToTreat();\n\n        // Nothing to do\n        if (!elementToTreat) return false;\n\n        elementToTreat.inProgress = true;\n\n        // If the state is already the good one\n        if (elementToTreat.programState.id === this.programState.id) {\n          // Resolve the program change as a success\n          elementToTreat.resolve();\n\n          return this.programChangeElementGotTreated(elementToTreat);\n        }\n\n        const oldProgramState = this.programState;\n\n        this.programState = elementToTreat.programState;\n\n        try {\n          const role = await this.getSlaveNorMaster();\n\n          // If we are the master - handle it\n          if (role.id === CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id) {\n            const ret = await role.handleProgramStateChange(elementToTreat.programState, oldProgramState);\n\n            // Say to everyone which is listening that the state changed\n            this.spreadStateToListener();\n\n            elementToTreat.resolve(ret);\n\n            return this.programChangeElementGotTreated(elementToTreat);\n          }\n\n          // Say to everyone which is listening that the state changed\n          this.spreadStateToListener();\n\n          // If we are the slave - Do nothing else here (we just set the this.programState)\n          elementToTreat.resolve();\n\n          return this.programChangeElementGotTreated(elementToTreat);\n        } catch (err) {\n          elementToTreat.reject(err);\n\n          return this.programChangeElementGotTreated(elementToTreat);\n        }\n      },\n    });\n  }\n\n  //\n  // PUBLIC METHODS\n  //\n\n  /**\n   * Singleton getter\n   */\n  static getInstance() {\n    return instance || new RoleAndTask();\n  }\n\n  /**\n   * Launch the system\n   *\n   * We have to load dynamically systemBoot to avoid recursive import\n   */\n  boot() {\n    const SystemBoot = require('./systemBoot/systemBoot.js')\n      .default;\n\n    this.systemBoot = new SystemBoot({\n      mode: this.mode,\n      modeoptions: this.modeoptions,\n    }).initialization();\n\n    // Get the instances of the roles class before to push it into the roleHandler\n    this.roles = this.roles.map(x => ({\n      ...x,\n\n      obj: x.class.getInstance(),\n    }));\n\n    // Initialize the role handler in here\n    this.roleHandler = new RoleHandler(this.roles);\n\n    this.systemBoot\n      .launch(this.launchMasterSlaveConfigurationFile);\n\n    this.startDate = new Date();\n  }\n\n  /**\n   * Launch the system ** can be called static **\n   */\n  static boot() {\n    RoleAndTask.getInstance()\n      .boot();\n  }\n\n  /**\n   * Subscribe to the state change. Returns the descriptor to use to unsubscribe\n   */\n  subscribeToStateChange(callback) {\n    const descriptor = Utils.generateLittleID();\n\n    this.stateChangeCallbacks.push({\n      callback,\n      descriptor,\n    });\n\n    return descriptor;\n  }\n\n  /**\n   * Unsubscribe to state change, passing the descriptor returned by subscribe function\n   */\n  unSubscribeToStateChange(descriptor) {\n    this.stateChangeCallbacks = this.stateChangeCallbacks.filter(x => x.descriptor !== descriptor);\n  }\n\n  /**\n   * Declare a new launching mode for processes\n   *\n   * Basics launching mode are 'slave' and 'master'.\n   *\n   * > If you want a custom Role maybe you would implement your curstom launching mode\n   */\n  declareLaunchingMode(name, func) {\n    this.customLaunchingMode.push({\n      name,\n      func,\n    });\n  }\n\n  /**\n   * Remove a custom launching mode\n   */\n  unDeclareLaunchingMode(name) {\n    this.customLaunchingMode = this.customLaunchingMode.filter(x => x.name !== name);\n  }\n\n  /**\n   * Declare a new state\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   * }\n   */\n  declareState(stateConfiguration) {\n    this.states.push(stateConfiguration);\n  }\n\n  /**\n   * Declare a new Role\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   *   class: ARole,\n   * }\n   */\n  declareRole(roleConfiguration) {\n    this.roles.push(roleConfiguration);\n  }\n\n  /**\n   * Declare the given task to the task system\n   *\n   * {\n   *   id: Number,\n   *   name: String,\n   *   color: String,\n   *   closureHierarchy: Number,\n   *   idsAllowedRole: [String],\n   *   obj: ATask,\n   *\n   *   // Only works if the task is started in master\n   *   notifyAboutArchitectureChange: Boolean,\n   * }\n   */\n  declareTask(taskConfiguration) {\n    this.tasks.push(taskConfiguration);\n  }\n\n  /**\n   * Remove the task from the task list using the task id\n   */\n  removeTask(taskName) {\n    this.tasks = this.tasks.filter(x => x.id !== taskName);\n  }\n\n  /**\n   * Get the tasks related to the given role id\n   */\n  getRoleTasks(idRole) {\n    return this.tasks.filter(x => x.idsAllowedRole.includes(idRole));\n  }\n\n  /**\n   * Get the roles configuration\n   */\n  getRoles() {\n    return this.roles.map((x) => {\n        if (x.id === -1) return false;\n\n        return {\n          ...x,\n\n          obj: x.class.getInstance(),\n        };\n      })\n      .filter(x => x);\n  }\n\n  /**\n   * Get the actual running role\n   */\n  getActualRole(possibilities, i) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // If there is no more possibilities - Error\n        if (i >= possibilities.length) throw new Errors('EXXXX', 'No role available');\n\n        // Try one\n        const role = await this.roleHandler.getRole(possibilities[i]);\n\n        // If its not active, do nothing\n        if (!role.isActive()) {\n          // Try next\n          return false;\n        }\n\n        // Its good we can stop now\n        return role;\n      },\n    });\n  }\n\n  /**\n   * Get the slave role nor the master\n   * Take the first that is active\n   */\n  getSlaveNorMaster() {\n    return new PromiseCommandPattern({\n      func: () => Utils.promiseCallUntilTrue({\n        functionToCall: this.getActualRole,\n        context: this,\n\n        args: [\n          this.roles.map(x => x.id),\n        ],\n      }),\n    });\n  }\n\n  /**\n   * Change the program state\n   * Role master: Set this.programState & spread the news to itselfs tasks and slaves\n   * Role slate: Set the this.programState\n   */\n  changeProgramState(idProgramState) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        // Push the order in the list of state change to perform\n        this.programStateChangeWaitingList.push({\n          resolve,\n          reject,\n          programState: this.states.find(x => x.id === idProgramState),\n          inProgress: false,\n        });\n\n        this.lookAtProgramStateChangePipe();\n      }),\n    });\n  }\n\n  /**\n   * Get the name of the task who asked for the display\n   */\n  static getTheTaskWhoPerformTheDisplay(role) {\n    const activeTasks = role.getTaskHandler()\n      .getAllActiveTasks();\n\n    if (!activeTasks.length) return `${process.pid}`;\n\n    return activeTasks[0].name;\n  }\n\n  /**\n   * Handle the display message throught the slaves and master\n   * If we are master we display the message\n   * If we are a slave we give the messsage to the master\n   * @param {Object} param\n   */\n  displayMessage(param) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          const role = await this.getSlaveNorMaster();\n\n          // Handle the fact we are trying to display an object\n          const isString = Utils.isAString(param.str);\n\n          if (isString) {\n            return role.displayMessage({\n              ...param,\n\n              // Add the task who perform the display\n              from: RoleAndTask.getTheTaskWhoPerformTheDisplay(role),\n\n              time: Date.now(),\n            });\n          }\n\n          const newParam = {\n            ...param,\n\n            // Add the task who perform the display\n            from: RoleAndTask.getTheTaskWhoPerformTheDisplay(role),\n\n            time: Date.now(),\n          };\n\n          newParam.str = JSON.stringify(newParam.str, null, 2);\n\n          // Add here the task who performed the display and the time of it\n\n          return role.displayMessage(newParam);\n        } catch (e) {\n          // Here means that we have no role available, and so that we try to display message\n          // when the role is not even launched\n          // We simply ignore the message\n          // MESSAGE TO THE DEVELOPPER, DISPLAY NOTHING BEFORE ROLES GET STARTED\n          return false;\n        }\n      },\n    });\n  }\n\n  /**\n   * Here we come when an error happened on the system and we want to deal with it,\n   * If we are the master, we tell ourselves about it\n   * If we are a slave or ... we tell the master about it\n   */\n  errorHappened(err) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Error happens\n        Utils.displayMessage({\n          str: String((err && err.stack) || err),\n\n          out: process.stderr,\n        });\n\n        try {\n          const role = await this.getSlaveNorMaster();\n\n          if (role.id !== CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id) {\n            // Send a message to the master\n            return role.tellMasterErrorHappened(err);\n          }\n\n          try {\n            // If we are the master ourselves, we put program in error\n            await this.changeProgramState(CONSTANT.DEFAULT_STATES.ERROR.id);\n\n            // We did sent the message :)\n            // Display the error message\n            this.displayMessage({\n              str: String((err && err.stack) || err),\n\n              tags: [\n                CONSTANT.MESSAGE_DISPLAY_TAGS.ERROR,\n              ],\n            });\n\n            // If the errors are supposed to be fatal, exit!\n            if (RoleAndTask.getInstance()\n              .makesErrorFatal) {\n              RoleAndTask.exitProgramUnproperDueToError();\n            }\n          } catch (e) {\n            // We exit PROGRAM, nothing more we can do\n            // We locally display the error so it will finish into the node-error.log file\n            RoleAndTask.exitProgramMsg('Exit program unproper ERROR HAPPENED', err, e);\n\n            // We use setTimeout tho if there is some others things to do before the quit it will\n            RoleAndTask.exitProgramUnproperDueToError();\n          }\n        } catch (e) {\n          RoleAndTask.exitProgramMsg('Exit program unproper ERROR HAPPENED CATCH', err, e);\n\n          // We use setTimeout tho if there is some others things to do before the quit it will\n          RoleAndTask.exitProgramUnproperDueToError();\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * Display messages about exiting program in errorHappened\n   */\n  static exitProgramMsg(txt, err, e) {\n    // We exit PROGRAM, nothing more we can do\n    Utils.displayMessage({\n      str: String((err && err.stack) || err),\n      out: process.stderr,\n    });\n\n    // We locally display the error so it will finish into the node-error.log file\n    Utils.displayMessage({\n      str: String(e),\n      out: process.stderr,\n    });\n\n    Utils.displayMessage({\n      str: 'Exit program unproper ERROR HAPPENED CATCH',\n      out: process.stderr,\n    });\n  }\n\n  /**\n   * Make the master to quit every slaves and every task\n   * DO NOT QUIT THE APP\n   */\n  makeTheMasterToQuitEverySlaveAndTask() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Do nothing when we already got an order for closure\n        if (this.quitOrder) return false;\n\n        this.quitOrder = true;\n\n        const role = await this.getSlaveNorMaster();\n\n        // If we are the master - handle it\n        if (role.id !== CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id) throw new Errors('EXXXX', 'Closure not possible in a slave');\n\n        /**\n         * We change the program state to CLOSE\n         */\n        await this.changeProgramState(CONSTANT.DEFAULT_STATES.CLOSE.id);\n\n        return this.quit();\n      },\n    });\n  }\n\n  /**\n   * Properly quit the app if we are on master\n   * Ignore if we are inside something else\n   */\n  makeTheMasterToQuitTheWholeApp() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // If the state is LAUNCHING do not quit the app\n        if (this.programState.id === CONSTANT.DEFAULT_STATES.LAUNCHING.id) {\n          this.displayMessage({\n            str: 'Cannot close PROGRAM when the state is LAUNCHING',\n          });\n\n          return;\n        }\n\n        try {\n          const quit = await this.makeTheMasterToQuitEverySlaveAndTask();\n\n          if (quit) RoleAndTask.exitProgramGood();\n\n          // Do nothing if quit equal to false\n          // ...\n        } catch (err) {\n          RoleAndTask.getInstance()\n            .errorHappened(err);\n        }\n      },\n    });\n  }\n\n  /**\n   * We exit PROGRAM unproperly due to an error that can't be fixed regulary\n   * (Ex: lose the communication between the slave and the master and we are the slave)\n   */\n  static exitProgramUnproperDueToError() {\n    // Exit after a timeout to let the system makes the displays\n    setTimeout(() => process.exit(1), CONSTANT.TIMEOUT_LEAVE_PROGRAM_UNPROPER);\n  }\n\n  /**\n   * We exit PROGRAM when everything had been closed the right way\n   */\n  static exitProgramGood() {\n    Utils.displayMessage({\n      str: 'Exit program good',\n      out: process.stderr,\n    });\n\n    process.exit(0);\n  }\n\n  /**\n   * Handle signals\n   */\n  handleSignals() {\n    // Exit PROGRAM properly\n    const signalActionProper = async () => {\n      const role = await this.getSlaveNorMaster();\n\n      // If we are the master - handle it - if we are a slave ignore it\n      if (role.id !== CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id) return;\n\n      this.makeTheMasterToQuitTheWholeApp();\n    };\n\n    // Exit PROGRAM unproperly\n    const signalActionUnproper = () => {\n      RoleAndTask.exitProgramUnproperDueToError();\n    };\n\n    Object.keys(CONSTANT.SIGNAL)\n      .forEach((x) => {\n        process.on(CONSTANT.SIGNAL[x], () => signalActionProper());\n      });\n\n    Object.keys(CONSTANT.SIGNAL_UNPROPER)\n      .forEach((x) => {\n        process.on(CONSTANT.SIGNAL_UNPROPER[x], () => signalActionUnproper());\n      });\n  }\n\n  /**\n   * Spread data to every tasks we locally hold\n   * @param {{dataName: String, data: Object, timestamp: Date, limitToTaskList: [String] | false}} args\n   */\n  spreadDataToEveryLocalTask({\n    dataName,\n    data,\n    timestamp,\n    limitToTaskList,\n  }) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          const role = await this.getSlaveNorMaster();\n\n          role.getTaskHandler()\n            .getAllActiveTasks()\n            .forEach((x) => {\n              // Do not tell the tasks that do not require to know\n              if (!limitToTaskList || limitToTaskList.some(y => x.id === y)) {\n                // Make it asynchronous!\n                setTimeout(() => {\n                  x.consumeNewsData(dataName, data, timestamp);\n                }, 0);\n              }\n            });\n        } catch (err) {\n          this.errorHappened(err);\n        }\n      },\n    });\n  }\n\n  /**\n   * THIS METHOD WORK ONLY IN THE MASTER\n   * (It get called by HandleProgramTask)\n   *\n   * It returns in an array the whole system pids (Master + Slaves processes)\n   */\n  getFullSystemPids() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const role = await this.getMasterRole();\n\n        return role.getFullSystemPids();\n      },\n    });\n  }\n\n  /**\n   * Get the master role (error if we are not in master role process)\n   */\n  getMasterRole() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const roleMaster = await this.getRoleHandler()\n          .getRole(CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id);\n\n        // If its not active, do nothing\n        if (!roleMaster.isActive()) throw new Errors('EXXXX', 'Master is not active in getMasterRole');\n\n        // Its good\n        return roleMaster;\n      },\n    });\n  }\n\n  // Getter\n  getRoleHandler() {\n    return this.roleHandler;\n  }\n\n  /**\n   * Quit everything that is open\n   *\n   * Including:\n   *\n   * -> Close the role (Slave or Master)\n   * ----> If slave: Close its running tasks\n   * ----> If master: Close all the slaves\n   */\n  quit() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const role = await this.getSlaveNorMaster();\n\n        await role.stop();\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Declare a new Role\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   *   class: ARole,\n   * }\n   */\n  static declareRole(roleConfiguration) {\n    this.getInstance()\n      .declareRole(roleConfiguration);\n  }\n\n  /**\n   * Declare a new State in addition of the defaults ones\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   * }\n   */\n  static declareState(stateConfiguration) {\n    this.getInstance()\n      .declareState(stateConfiguration);\n  }\n\n  /**\n   * Declare the given task to the task system\n   *\n   * {\n   *   id: Number,\n   *   name: String,\n   *   color: String,\n   *   closureHierarchy: Number,\n   *   idsAllowedRole: [Number],\n   *   obj: ATask,\n   *\n   *   // Only works if the task is started in master\n   *   notifyAboutArchitectureChange: Boolean,\n   * }\n   */\n  static declareTask(taskConfiguration) {\n    this.getInstance()\n      .declareTask(taskConfiguration);\n  }\n\n  /**\n   * Remove the task from the task list using the task id\n   */\n  static removeTask(taskName) {\n    this.getInstance()\n      .removeTask(taskName);\n  }\n\n  /**\n   * Set the configuration through one function\n   *\n   * Returns the list of the configuration that has been accepted and setted\n   */\n  setConfiguration(opts) {\n    const availableOpts = [\n      'mode',\n      'modeoptions',\n      'displayTask',\n      'launchMasterSlaveConfigurationFile',\n      'pathToEntryFile',\n      'displayLog',\n      'makesErrorFatal',\n      'considerWarningAsErrors',\n      'masterMessageWaitingTimeout',\n      'masterMessageWaitingTimeoutStateChange',\n      'masterMessageWaitingTimeoutStopTask',\n    ];\n\n    const mandatoryOpts = [\n      'mode',\n      'modeoptions',\n      'launchMasterSlaveConfigurationFile',\n      'pathToEntryFile',\n    ].reduce((tmp, x) => {\n      tmp[x] = null;\n      return tmp;\n    }, {});\n\n    const setted = Object.keys(opts)\n      .reduce((tmp, x) => {\n        // Unknown key\n        if (!availableOpts.includes(x)) return tmp;\n\n        // Set the option value\n        this[x] = opts[x];\n\n        tmp[x] = opts[x];\n\n        if (mandatoryOpts[x] !== void 0) {\n          mandatoryOpts[x] = true;\n        }\n\n        return tmp;\n      }, {});\n\n    if (Object.values(mandatoryOpts).includes(null)) {\n      throw new Error(`Mandatory option ${Object.keys(mandatoryOpts).find(x => mandatoryOpts[x] === null)} is missing`);\n    }\n\n    // Display the options that has been setted up\n    this.displayMessage({\n      str: 'role-and-task : Following options has been setted up : ',\n    });\n\n    this.displayMessage({\n      str: setted,\n    });\n\n    return setted;\n  }\n\n  /**\n   * In master/slave protocol, we ask to get a token\n   *\n   * SHORTCUT\n   */\n  takeMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const role = await this.getSlaveNorMaster();\n\n        return role.takeMutex(id);\n      },\n    });\n  }\n\n  /**\n   * In master/slave protocol, we ask to release the token\n   *\n   * SHORTCUT\n   */\n  async releaseMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const role = await this.getSlaveNorMaster();\n\n        return role.releaseMutex(id);\n      },\n    });\n  }\n\n  /**\n   * Contains the functions to call to validate mutex take and release in master/slave protocol\n   */\n  getMasterMutexFunctions() {\n    return this.masterMutexValidationFunctions;\n  }\n\n  /**\n   * Add a function to be called when a user want to take the Mutex related to the given id\n   *\n   * The function have to throw an error if the token cannot be taken, if it goes well, consider the mutex to be taken\n   */\n  addMasterMutexFunctions(id, funcTake, funcRelease) {\n    this.masterMutexValidationFunctions.push({\n      id,\n      funcTake,\n      funcRelease,\n    });\n  }\n}"],"file":"RoleAndTask.js"}