{"version":3,"sources":["../../src/RoleAndTask.es6"],"names":["instance","RoleAndTask","launchMasterSlaveConfigurationFile","pathToEntryFile","tasks","CONSTANT","DEFAULT_TASK","map","x","filter","id","roles","DEFAULT_ROLES","states","DEFAULT_STATES","stateChangeCallbacks","eliotState","LAUNCHING","eliotStateChangeWaitingList","customLaunchingMode","quitOrder","displayLog","makesErrorsFatal","masterMutexValidationFunctions","handleSignals","PromiseCommandPattern","func","getSlaveNorMaster","role","takeMutex","releaseMutex","funcTake","funcRelease","push","length","inProgress","errorElement","some","ERROR","elem","lookAtEliotStateChangePipe","forEach","callback","find","elementToTreat","getEliotStateChangeToTreat","resolve","eliotChangeElementGotTreated","oldEliotState","MASTER_ROLE","handleEliotStateChange","ret","spreadStateToListener","reject","SystemBoot","require","default","systemBoot","initialization","obj","class","getInstance","roleHandler","RoleHandler","launch","startDate","Date","displayTask","filePath","descriptor","Utils","generateLittleID","name","stateConfiguration","roleConfiguration","taskConfiguration","taskName","idRole","idsAllowedRole","includes","possibilities","i","Errors","getRole","isActive","promiseCallUntilTrue","functionToCall","getActualRole","context","args","idEliotState","param","isString","isAString","str","displayMessage","from","getTheTaskWhoPerformTheDisplay","time","now","newParam","err","String","stack","out","process","stderr","tellMasterErrorHappened","changeEliotState","tags","MESSAGE_DISPLAY_TAGS","getMakesErrorFatal","exitEliotUnproperDueToError","exitEliotMsg","CLOSE","quit","makeTheMasterToQuitEverySlaveAndTask","exitEliotGood","errorHappened","signalActionProper","makeTheMasterToQuitTheWholeApp","signalActionUnproper","SIGNAL","on","SIGNAL_UNPROPER","dataName","data","timestamp","limitToTaskList","getTaskHandler","getAllActiveTasks","y","setTimeout","consumeNewsData","getMasterRole","getFullSystemPids","getRoleHandler","roleMaster","stop","boot","activeTasks","txt","e","exit","TIMEOUT_LEAVE_ELIOT_UNPROPER","declareRole","declareState","declareTask","removeTask"],"mappings":"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","file":"RoleAndTask.js","sourcesContent":["import CONSTANT from './Utils/CONSTANT/CONSTANT.js';\nimport Utils from './Utils/Utils.js';\nimport Errors from './Utils/Errors.js';\nimport RoleHandler from './RoleSystem/Handlers/RoleHandler.js';\nimport PromiseCommandPattern from './Utils/PromiseCommandPattern.js';\n\nlet instance = null;\n\n/**\n * Class which is the interface with the library user\n */\nexport default class RoleAndTask {\n  /**\n   * Constructor working the Singleton way\n   */\n  constructor() {\n    if (instance) return instance;\n\n    // Set the Master Slave Configuration File to load\n    this.launchMasterSlaveConfigurationFile = false;\n\n    // Path to the entry point of your program, we use to pop a new slave\n    this.pathToEntryFile = false;\n\n    // Contains all the tasks referenced\n    this.tasks = [\n      ...Object.keys(CONSTANT.DEFAULT_TASK)\n      .map(x => CONSTANT.DEFAULT_TASK[x]),\n    ].filter(x => x.id !== -1);\n\n    // Contains all the roles referenced\n    this.roles = [\n      ...Object.keys(CONSTANT.DEFAULT_ROLES)\n      .map(x => CONSTANT.DEFAULT_ROLES[x]),\n    ].filter(x => x.id !== -1);\n\n    // Contains all the states the system can have\n    this.states = [\n      ...Object.keys(CONSTANT.DEFAULT_STATES)\n      .map(x => CONSTANT.DEFAULT_STATES[x]),\n    ];\n\n    // Array where we store the functions to call when the state change\n    this.stateChangeCallbacks = [];\n\n    // The state of eliot patform\n    this.eliotState = CONSTANT.DEFAULT_STATES.LAUNCHING;\n\n    // All the orders in a row to change the eliot state\n    this.eliotStateChangeWaitingList = [];\n\n    // When poping a new process, we start it using a \"launching mode\", there are two basic launching mode for \"slave\" and \"master\"\n    // You can set up a custom launching mode\n    this.customLaunchingMode = [];\n\n    // Are we quitting?\n    this.quitOrder = false;\n\n    // Are we displaying the logs ?\n    this.displayLog = true;\n\n    // Do we makes the error to be fatal ?\n    this.makesErrorsFatal = false;\n\n    // Contains the functions to call to validate mutex take and release in master/slave protocol\n    this.masterMutexValidationFunctions = [];\n\n    // Handle the signals\n    this.handleSignals();\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * Singleton getter\n   */\n  static getInstance() {\n    return instance || new RoleAndTask();\n  }\n\n  /**\n   * In master/slave protocol, we ask to get a token\n   *\n   * SHORTCUT\n   */\n  takeMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const role = await this.getSlaveNorMaster();\n\n        return role.takeMutex(id);\n      },\n    });\n  }\n\n  /**\n   * In master/slave protocol, we ask to release the token\n   *\n   * SHORTCUT\n   */\n  async releaseMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const role = await this.getSlaveNorMaster();\n\n        return role.releaseMutex(id);\n      },\n    });\n  }\n\n  /**\n   * Contains the functions to call to validate mutex take and release in master/slave protocol\n   */\n  getMasterMutexFunctions() {\n    return this.masterMutexValidationFunctions;\n  }\n\n  /**\n   * Add a function to be called when a user want to take the Mutex related to the given id\n   *\n   * The function have to throw an error if the token cannot be taken, if it goes well, consider the mutex to be taken\n   */\n  addMasterMutexFunctions(id, funcTake, funcRelease) {\n    this.masterMutexValidationFunctions.push({\n      id,\n      funcTake,\n      funcRelease,\n    });\n  }\n\n  /**\n   * Get the good element to treat (Look at specific behavior described into lookAtEliotStateChangePipe comment)\n   * (If there is actually something in progress, do nothing)\n   */\n  getEliotStateChangeToTreat() {\n    // No change to perform\n    if (!this.eliotStateChangeWaitingList.length) return false;\n\n    let inProgress = false;\n    let errorElement = false;\n\n    this.eliotStateChangeWaitingList.some((x) => {\n      // We do nothing if something is in progress exept if error\n      if (x.inProgress) inProgress = true;\n\n      if (x.eliotState.id === CONSTANT.DEFAULT_STATES.ERROR.id) {\n        errorElement = x;\n\n        return true;\n      }\n\n      return false;\n    });\n\n    // Error comes first\n    if (errorElement) return errorElement;\n\n    // Then in progress\n    if (inProgress) return false;\n\n    // Then regular\n    return this.eliotStateChangeWaitingList[0];\n  }\n\n  /**\n   * Some eliot element got treated, remove them from the pipe\n   * @param {Object} elem\n   */\n  eliotChangeElementGotTreated(elem) {\n    this.eliotStateChangeWaitingList = this.eliotStateChangeWaitingList.filter(x => x !== elem);\n\n    // look if there is something else to do\n    this.lookAtEliotStateChangePipe();\n  }\n\n  /**\n   * Send the message saying the state change to whom is interested to know\n   */\n  spreadStateToListener() {\n    this.stateChangeCallbacks.forEach(({\n      callback,\n    }) => {\n      setImmediate(() => callback(this.states.find(x => x.id === this.eliotState.id)), 0);\n    });\n  }\n\n  /**\n   * Look at the eliotStateChangeWaitingList array, and perform an eliot state change if we need to\n   * Specific behavior:\n   *\n   * (1) Error change state always pass first\n   * (2) When you want to change the state as something already true, resolve() directly\n   */\n  lookAtEliotStateChangePipe() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const elementToTreat = this.getEliotStateChangeToTreat();\n\n        // Nothing to do\n        if (!elementToTreat) return false;\n\n        elementToTreat.inProgress = true;\n\n        // If the state is already the good one\n        if (elementToTreat.eliotState.id === this.eliotState.id) {\n          // Resolve the eliot change as a success\n          elementToTreat.resolve();\n\n          return this.eliotChangeElementGotTreated(elementToTreat);\n        }\n\n        const oldEliotState = this.eliotState;\n\n        this.eliotState = elementToTreat.eliotState;\n\n        try {\n          const role = await this.getSlaveNorMaster();\n\n          // If we are the master - handle it\n          if (role.id === CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id) {\n            const ret = await role.handleEliotStateChange(elementToTreat.eliotState, oldEliotState);\n\n            // Say to everyone which is listening that the state changed\n            this.spreadStateToListener();\n\n            elementToTreat.resolve(ret);\n\n            return this.eliotChangeElementGotTreated(elementToTreat);\n          }\n\n          // If we are the slave - Do nothing here (we just set the this.eliotState)\n          elementToTreat.resolve();\n\n          return this.eliotChangeElementGotTreated(elementToTreat);\n        } catch (err) {\n          elementToTreat.reject(err);\n\n          return this.eliotChangeElementGotTreated(elementToTreat);\n        }\n      },\n    });\n  }\n\n  /**\n   * Launch the system\n   *\n   * We have to load dynamically systemBoot to avoid recursive import\n   */\n  boot() {\n    const SystemBoot = require('./systemBoot/systemBoot.js')\n      .default;\n\n    this.systemBoot = new SystemBoot()\n      .initialization();\n\n    // Get the instances of the roles class before to push it into the roleHandler\n    this.roles = this.roles.map(x => ({\n      ...x,\n\n      obj: x.class.getInstance(),\n    }));\n\n    // Initialize the role handler in here\n    this.roleHandler = new RoleHandler(this.roles);\n\n    this.systemBoot\n      .launch(this.launchMasterSlaveConfigurationFile);\n\n    this.startDate = new Date();\n  }\n\n  /**\n   * Launch the system ** can be called static **\n   */\n  static boot() {\n    RoleAndTask.getInstance()\n      .boot();\n  }\n\n  /**\n   * Getter\n   */\n  getMakesErrorFatal() {\n    return this.makesErrorsFatal;\n  }\n\n  /**\n   * Do we exit the processes after any error ?\n   */\n  setMakesErrorFatal(makesErrorsFatal) {\n    this.makesErrorsFatal = makesErrorsFatal;\n  }\n\n  /**\n   * Getter\n   */\n  getDisplayLog() {\n    return this.displayLog;\n  }\n\n  /**\n   * Are we displaying messages or cut them all of ?\n   */\n  setDisplayLog(displayLog) {\n    this.displayLog = displayLog;\n  }\n\n  /**\n   * Getter\n   */\n  getDisplayTask() {\n    return this.displayTask;\n  }\n\n  /**\n   * Set the task which will gonna handle the display, if there is not specified, the display is going to be made in stdout\n   *\n   * We are waiting for a task id\n   */\n  setDisplayTask(displayTask) {\n    this.displayTask = displayTask;\n  }\n\n  /**\n   * Getter\n   */\n  getPathToEntryFile() {\n    return this.pathToEntryFile;\n  }\n\n  /**\n   * Setup the entry point of your program\n   *\n   * We we are launching new slaves, we gonna use it\n   */\n  setPathToEntryFile(pathToEntryFile) {\n    this.pathToEntryFile = pathToEntryFile;\n  }\n\n  /**\n   * Setup the name of the file to read in order to get the configuration\n   */\n  setLaunchConfigurationFile(filePath) {\n    this.launchMasterSlaveConfigurationFile = filePath;\n  }\n\n  /**\n   * Subscribe to the state change. Returns the descriptor to use to unsubscribe\n   */\n  subscribeToStateChange(callback) {\n    const descriptor = Utils.generateLittleID();\n\n    this.stateChangeCallbacks.push({\n      callback,\n      descriptor,\n    });\n\n    return descriptor;\n  }\n\n  /**\n   * Unsubscribe to state change, passing the descriptor returned by subscribe function\n   */\n  unSubscribeToStateChange(descriptor) {\n    this.stateChangeCallbacks = this.stateChangeCallbacks.filter(x => x.descriptor !== descriptor);\n  }\n\n  /**\n   * Declare a new launching mode for processes\n   *\n   * Basics launching mode are 'slave' and 'master'.\n   *\n   * > If you want a custom Role maybe you would implement your curstom launching mode\n   */\n  declareLaunchingMode(name, func) {\n    this.customLaunchingMode.push({\n      name,\n      func,\n    });\n  }\n\n  /**\n   * Remove a custom launching mode\n   */\n  unDeclareLaunchingMode(name) {\n    this.customLaunchingMode = this.customLaunchingMode.filter(x => x.name !== name);\n  }\n\n  /**\n   * Declare a new state\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   * }\n   */\n  declareState(stateConfiguration) {\n    this.states.push(stateConfiguration);\n  }\n\n  /**\n   * Declare a new Role\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   *   class: ARole,\n   * }\n   */\n  declareRole(roleConfiguration) {\n    this.roles.push(roleConfiguration);\n  }\n\n  /**\n   * Declare the given task to the task system\n   *\n   * {\n   *   id: Number,\n   *   name: String,\n   *   color: String,\n   *   closureHierarchy: Number,\n   *   idsAllowedRole: [String],\n   *   obj: ATask,\n   *\n   *   // Only works if the task is started in master\n   *   notifyAboutArchitectureChange: Boolean,\n   * }\n   */\n  declareTask(taskConfiguration) {\n    this.tasks.push(taskConfiguration);\n  }\n\n  /**\n   * Remove the task from the task list using the task id\n   */\n  removeTask(taskName) {\n    this.tasks = this.tasks.filter(x => x.id !== taskName);\n  }\n\n  /**\n   * Get the tasks related to the given role id\n   */\n  getRoleTasks(idRole) {\n    return this.tasks.filter(x => x.idsAllowedRole.includes(idRole));\n  }\n\n  /**\n   * Get the roles configuration\n   */\n  getRoles() {\n    return this.roles.map((x) => {\n        if (x.id === -1) return false;\n\n        return {\n          ...x,\n\n          obj: x.class.getInstance(),\n        };\n      })\n      .filter(x => x);\n  }\n\n  /**\n   * Get the actual running role\n   */\n  getActualRole(possibilities, i) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // If there is no more possibilities - Error\n        if (i >= possibilities.length) throw new Errors('EXXXX', 'No role available');\n\n        // Try one\n        const role = await this.roleHandler.getRole(possibilities[i]);\n\n        // If its not active, do nothing\n        if (!role.isActive()) {\n          // Try next\n          return false;\n        }\n\n        // Its good we can stop now\n        return role;\n      },\n    });\n  }\n\n  /**\n   * Get the slave role nor the master\n   * Take the first that is active\n   */\n  getSlaveNorMaster() {\n    return new PromiseCommandPattern({\n      func: () => Utils.promiseCallUntilTrue({\n        functionToCall: this.getActualRole,\n        context: this,\n\n        args: [\n          this.roles.map(x => x.id),\n        ],\n      }),\n    });\n  }\n\n  /**\n   * Change the eliot state\n   * Role master: Set this.eliotState & spread the news to itselfs tasks and slaves\n   * Role slate: Set the this.eliotState\n   */\n  changeEliotState(idEliotState) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        // Push the order in the list of state change to perform\n        this.eliotStateChangeWaitingList.push({\n          resolve,\n          reject,\n          eliotState: this.states.find(x => x.id === idEliotState),\n          inProgress: false,\n        });\n\n        this.lookAtEliotStateChangePipe();\n      }),\n    });\n  }\n\n  /**\n   * Get the name of the task who asked for the display\n   */\n  static getTheTaskWhoPerformTheDisplay(role) {\n    const activeTasks = role.getTaskHandler()\n      .getAllActiveTasks();\n\n    if (!activeTasks.length) return 'unknown';\n\n    return activeTasks[0].name;\n  }\n\n  /**\n   * Handle the display message throught the slaves and master\n   * If we are master we display the message\n   * If we are a slave we give the messsage to the master\n   * @param {Object} param\n   */\n  displayMessage(param) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          const role = await this.getSlaveNorMaster();\n\n          // Handle the fact we are trying to display an object\n          const isString = Utils.isAString(param.str);\n\n          if (isString) {\n            return role.displayMessage({\n              ...param,\n\n              // Add the task who perform the display\n              from: RoleAndTask.getTheTaskWhoPerformTheDisplay(role),\n\n              time: Date.now(),\n            });\n          }\n\n          const newParam = {\n            ...param,\n\n            // Add the task who perform the display\n            from: RoleAndTask.getTheTaskWhoPerformTheDisplay(role),\n\n            time: Date.now(),\n          };\n\n          newParam.str = JSON.stringify(newParam.str, null, 2);\n\n          // Add here the task who performed the display and the time of it\n\n          return role.displayMessage(newParam);\n        } catch (e) {\n          // Here means that we have no role available, and so that we try to display message\n          // when the role is not even launched\n          // We simply ignore the message\n          // MESSAGE TO THE DEVELOPPER, DISPLAY NOTHING BEFORE ROLES GET STARTED\n          return false;\n        }\n      },\n    });\n  }\n\n  /**\n   * Here we come when an error happened on the system and we want to deal with it,\n   * If we are the master, we tell ourselves about it\n   * If we are a slave or ... we tell the master about it\n   */\n  errorHappened(err) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Error happens\n        Utils.displayMessage({\n          str: String((err && err.stack) || err),\n\n          out: process.stderr,\n        });\n\n        try {\n          const role = await this.getSlaveNorMaster();\n\n          if (role.id !== CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id) {\n            // Send a message to the master\n            return role.tellMasterErrorHappened(err);\n          }\n\n          try {\n            // If we are the master ourselves, we put eliot in error\n            await this.changeEliotState(CONSTANT.DEFAULT_STATES.ERROR.id);\n\n            // We did sent the message :)\n            // Display the error message\n            this.displayMessage({\n              str: String((err && err.stack) || err),\n\n              tags: [\n                CONSTANT.MESSAGE_DISPLAY_TAGS.ERROR,\n              ],\n            });\n\n            // If the errors are supposed to be fatal, exit!\n            if (RoleAndTask.getInstance()\n              .getMakesErrorFatal()) {\n              RoleAndTask.exitEliotUnproperDueToError();\n            }\n          } catch (e) {\n            // We exit ELIOT, nothing more we can do\n            // We locally display the error so it will finish into the node-error.log file\n            RoleAndTask.exitEliotMsg('Exit eliot unproper ERROR HAPPENED', err, e);\n\n            // We use setTimeout tho if there is some others things to do before the quit it will\n            RoleAndTask.exitEliotUnproperDueToError();\n          }\n        } catch (e) {\n          RoleAndTask.exitEliotMsg('Exit eliot unproper ERROR HAPPENED CATCH', err, e);\n\n          // We use setTimeout tho if there is some others things to do before the quit it will\n          RoleAndTask.exitEliotUnproperDueToError();\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * Display messages about exiting eliot in errorHappened\n   */\n  static exitEliotMsg(txt, err, e) {\n    // We exit ELIOT, nothing more we can do\n    Utils.displayMessage({\n      str: String((err && err.stack) || err),\n      out: process.stderr,\n    });\n\n    // We locally display the error so it will finish into the node-error.log file\n    Utils.displayMessage({\n      str: String(e),\n      out: process.stderr,\n    });\n\n    Utils.displayMessage({\n      str: 'Exit eliot unproper ERROR HAPPENED CATCH',\n      out: process.stderr,\n    });\n  }\n\n  /**\n   * Make the master to quit every slaves and every task\n   * DO NOT QUIT THE APP\n   */\n  makeTheMasterToQuitEverySlaveAndTask() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Do nothing when we already got an order for closure\n        if (this.quitOrder) return false;\n\n        this.quitOrder = true;\n\n        const role = await this.getSlaveNorMaster();\n\n        // If we are the master - handle it\n        if (role.id !== CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id) throw new Errors('EXXXX', 'Closure not possible in a slave');\n\n        /**\n         * We change the eliot state to CLOSE\n         */\n        await this.changeEliotState(CONSTANT.DEFAULT_STATES.CLOSE.id);\n\n        return this.quit();\n      },\n    });\n  }\n\n  /**\n   * Properly quit the app if we are on master\n   * Ignore if we are inside something else\n   */\n  makeTheMasterToQuitTheWholeApp() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // If the state is LAUNCHING do not quit the app\n        if (this.eliotState.id === CONSTANT.DEFAULT_STATES.LAUNCHING.id) {\n          this.displayMessage({\n            str: 'Cannot close ELIOT when the state is LAUNCHING',\n          });\n\n          return;\n        }\n\n        try {\n          const quit = await this.makeTheMasterToQuitEverySlaveAndTask();\n\n          if (quit) RoleAndTask.exitEliotGood();\n\n          // Do nothing if quit equal to false\n          // ...\n        } catch (err) {\n          RoleAndTask.getInstance()\n            .errorHappened(err);\n        }\n      },\n    });\n  }\n\n  /**\n   * We exit ELIOT unproperly due to an error that can't be fixed regulary\n   * (Ex: lose the communication between the slave and the master and we are the slave)\n   */\n  static exitEliotUnproperDueToError() {\n    // Exit after a timeout to let the system makes the displays\n    setTimeout(() => process.exit(1), CONSTANT.TIMEOUT_LEAVE_ELIOT_UNPROPER);\n  }\n\n  /**\n   * We exit ELIOT when everything had been closed the right way\n   */\n  static exitEliotGood() {\n    Utils.displayMessage({\n      str: 'Exit eliot good',\n      out: process.stderr,\n    });\n\n    process.exit(0);\n  }\n\n  /**\n   * Handle signals\n   */\n  handleSignals() {\n    // Exit ELIOT properly\n    const signalActionProper = async () => {\n      const role = await this.getSlaveNorMaster();\n\n      // If we are the master - handle it - if we are a slave ignore it\n      if (role.id !== CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id) return;\n\n      this.makeTheMasterToQuitTheWholeApp();\n    };\n\n    // Exit ELIOT unproperly\n    const signalActionUnproper = () => {\n      RoleAndTask.exitEliotUnproperDueToError();\n    };\n\n    Object.keys(CONSTANT.SIGNAL)\n      .forEach((x) => {\n        process.on(CONSTANT.SIGNAL[x], () => signalActionProper());\n      });\n\n    Object.keys(CONSTANT.SIGNAL_UNPROPER)\n      .forEach((x) => {\n        process.on(CONSTANT.SIGNAL_UNPROPER[x], () => signalActionUnproper());\n      });\n  }\n\n  /**\n   * Spread data to every tasks we locally hold\n   * @param {{dataName: String, data: Object, timestamp: Date, limitToTaskList: [String] | false}} args\n   */\n  spreadDataToEveryLocalTask({\n    dataName,\n    data,\n    timestamp,\n    limitToTaskList,\n  }) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          const role = await this.getSlaveNorMaster();\n\n          role.getTaskHandler()\n            .getAllActiveTasks()\n            .forEach((x) => {\n              // Do not tell the tasks that do not require to know\n              if (!limitToTaskList || limitToTaskList.some(y => x.id === y)) {\n                // Make it asynchronous!\n                setTimeout(() => {\n                  x.consumeNewsData(dataName, data, timestamp);\n                }, 0);\n              }\n            });\n        } catch (err) {\n          this.errorHappened(err);\n        }\n      },\n    });\n  }\n\n  /**\n   * THIS METHOD WORK ONLY IN THE MASTER\n   * (It get called by HandleEliotTask)\n   *\n   * It returns in an array the whole system pids (Master + Slaves processes)\n   */\n  getFullSystemPids() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const role = await this.getMasterRole();\n\n        return role.getFullSystemPids();\n      },\n    });\n  }\n\n  /**\n   * Get the master role (error if we are not in master role process)\n   */\n  getMasterRole() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const roleMaster = await this.getRoleHandler()\n          .getRole(CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id);\n\n        // If its not active, do nothing\n        if (!roleMaster.isActive()) throw new Errors('EXXXX', 'Master is not active in getMasterRole');\n\n        // Its good\n        return roleMaster;\n      },\n    });\n  }\n\n  // Getter\n  getRoleHandler() {\n    return this.roleHandler;\n  }\n\n  /**\n   * Quit everything that is open\n   *\n   * Including:\n   *\n   * -> Close the role (Slave or Master)\n   * ----> If slave: Close its running tasks\n   * ----> If master: Close all the slaves\n   */\n  quit() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const role = await this.getSlaveNorMaster();\n\n        await role.stop();\n\n        return true;\n      },\n    });\n  }\n\n  /*\n   ********************************************************************\n   *               STATIC METHODS TO ACCESS DIRECTLY\n   ********************************************************************\n   */\n\n  /**\n   * Declare a new Role\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   *   class: ARole,\n   * }\n   */\n  static declareRole(roleConfiguration) {\n    this.getInstance()\n      .declareRole(roleConfiguration);\n  }\n\n  /**\n   * Declare a new State in addition of the defaults ones\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   * }\n   */\n  static declareState(stateConfiguration) {\n    this.getInstance()\n      .declareState(stateConfiguration);\n  }\n\n  /**\n   * Declare the given task to the task system\n   *\n   * {\n   *   id: Number,\n   *   name: String,\n   *   color: String,\n   *   closureHierarchy: Number,\n   *   idsAllowedRole: [Number],\n   *   obj: ATask,\n   *\n   *   // Only works if the task is started in master\n   *   notifyAboutArchitectureChange: Boolean,\n   * }\n   */\n  static declareTask(taskConfiguration) {\n    this.getInstance()\n      .declareTask(taskConfiguration);\n  }\n\n  /**\n   * Remove the task from the task list using the task id\n   */\n  static removeTask(taskName) {\n    this.getInstance()\n      .removeTask(taskName);\n  }\n}\n"]}