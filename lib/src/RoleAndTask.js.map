{"version":3,"sources":["../../src/RoleAndTask.es6"],"names":["instance","RoleAndTask","launchMasterSlaveConfigurationFile","pathToEntryFile","tasks","CONSTANT","DEFAULT_TASK","map","x","filter","id","roles","DEFAULT_ROLE","eliotState","ELIOT_STATE","LAUNCHING","eliotStateChangeWaitingList","quitOrder","displayLog","handleSignals","length","inProgress","errorElement","some","ERROR","elem","lookAtEliotStateChangePipe","elementToTreat","getEliotStateChangeToTreat","resolve","eliotChangeElementGotTreated","oldEliotState","getSlaveNorMaster","role","MASTER_ROLE","handleEliotStateChange","ret","reject","SystemBoot","require","default","systemBoot","initialization","obj","class","getInstance","roleHandler","RoleHandler","launch","startDate","Date","displayTask","filePath","roleConfiguration","push","taskConfiguration","taskName","idRole","idsAllowedRole","includes","possibilities","i","Error","getRole","isActive","Utils","promiseCallUntilTrue","functionToCall","getActualRole","context","args","param","isString","isAString","str","displayMessage","from","getTheTaskWhoPerformTheDisplay","time","now","newParam","err","String","stack","out","process","stderr","tellMasterErrorHappened","changeEliotState","tags","MESSAGE_DISPLAY_TAGS","MAKES_ERROR_FATAL","exitEliotUnproperDueToError","exitEliotMsg","CLOSE","quit","makeTheMasterToQuitEverySlaveAndTask","exitEliotGood","errorHappened","signalActionProper","makeTheMasterToQuitTheWholeApp","signalActionUnproper","SIGNAL","forEach","on","SIGNAL_UNPROPER","dataName","data","timestamp","limitToTaskList","DATABASE_MAINTAINANCE","GENERIC_DATA_NEWS","COLLECTION_CRUD","SCREEN_STATUS_NEWS","BREAKDOWN_PARAMETER_NEWS","checkThatAtLeastOneElementOfArray1ExistInArray2","sendDataToEveryELIOTTaskWhereverItIs","getTaskHandler","getAllActiveTasks","y","setTimeout","consumeNewsData","stop","getMasterRole","getFullSystemPids","roleMaster","boot","activeTasks","name","txt","e","exit","TIMEOUT_LEAVE_ELIOT_UNPROPER","declareRole","declareTask","removeTask"],"mappings":"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","file":"RoleAndTask.js","sourcesContent":["import CONSTANT from './Utils/CONSTANT/CONSTANT.js';\nimport Utils from './Utils/Utils.js';\nimport RoleHandler from './RoleSystem/Handlers/RoleHandler.js';\n\nlet instance = null;\n\n/**\n * Class which is the interface with the library user\n */\nexport default class RoleAndTask {\n  /**\n   * Constructor working the Singleton way\n   */\n  constructor() {\n    if (instance) return instance;\n\n    // Set the Master Slave Configuration File to load\n    this.launchMasterSlaveConfigurationFile = false;\n\n    // Path to the entry point of your program, we use to pop a new slave\n    this.pathToEntryFile = false;\n\n    // Contains all the tasks referenced\n    this.tasks = [\n      ...Object.keys(CONSTANT.DEFAULT_TASK)\n      .map(x => CONSTANT.DEFAULT_TASK[x]),\n    ].filter(x => x.id !== -1);\n\n    // Contains all the roles referenced\n    this.roles = [\n      ...Object.keys(CONSTANT.DEFAULT_ROLE)\n      .map(x => CONSTANT.DEFAULT_ROLE[x]),\n    ].filter(x => x.id !== -1);\n\n    // The state of eliot patform\n    this.eliotState = CONSTANT.ELIOT_STATE.LAUNCHING;\n\n    // All the orders in a row to change the eliot state\n    this.eliotStateChangeWaitingList = [];\n\n    // Are we quitting?\n    this.quitOrder = false;\n\n    // Are we displaying the logs ?\n    this.displayLog = true;\n\n    // Handle the signals\n    this.handleSignals();\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * Singleton getter\n   */\n  static getInstance() {\n    return instance || new RoleAndTask();\n  }\n\n  /*\n   ***********************************************************************************************************\n   *\n   *                          PROTECTED METHODS TO USE\n   *\n   ***********************************************************************************************************\n   */\n\n  /**\n   * Get the good element to treat (Look at specific behavior described into lookAtEliotStateChangePipe comment)\n   * (If there is actually something in progress, do nothing)\n   */\n  getEliotStateChangeToTreat() {\n    // No change to perform\n    if (!this.eliotStateChangeWaitingList.length) return false;\n\n    let inProgress = false;\n    let errorElement = false;\n\n    this.eliotStateChangeWaitingList.some((x) => {\n      // We do nothing if something is in progress exept if error\n      if (x.inProgress) inProgress = true;\n\n      if (x.eliotState === CONSTANT.ELIOT_STATE.ERROR) {\n        errorElement = x;\n\n        return true;\n      }\n\n      return false;\n    });\n\n    // Error comes first\n    if (errorElement) return errorElement;\n\n    // Then in progress\n    if (inProgress) return false;\n\n    // Then regular\n    return this.eliotStateChangeWaitingList[0];\n  }\n\n  /**\n   * Some eliot element got treated, remove them from the pipe\n   * @param {Object} elem\n   */\n  eliotChangeElementGotTreated(elem) {\n    this.eliotStateChangeWaitingList = this.eliotStateChangeWaitingList.filter(x => x !== elem);\n\n    // look if there is something else to do\n    this.lookAtEliotStateChangePipe();\n  }\n\n  /**\n   * Look at the eliotStateChangeWaitingList array, and perform an eliot state change if we need to\n   * Specific behavior:\n   *\n   * (1) Error change state always pass first\n   * (2) When you want to change the state as something already true, resolve() directly\n   */\n  async lookAtEliotStateChangePipe() {\n    const elementToTreat = this.getEliotStateChangeToTreat();\n\n    // Nothing to do\n    if (!elementToTreat) return false;\n\n    elementToTreat.inProgress = true;\n\n    // If the state is already the good one\n    if (elementToTreat.eliotState === this.eliotState) {\n      // Resolve the eliot change as a success\n      elementToTreat.resolve();\n\n      return this.eliotChangeElementGotTreated(elementToTreat);\n    }\n\n    const oldEliotState = this.eliotState;\n\n    this.eliotState = elementToTreat.eliotState;\n\n    try {\n      const role = await this.getSlaveNorMaster();\n\n      // If we are the master - handle it\n      if (role.id === CONSTANT.DEFAULT_ROLE.MASTER_ROLE.id) {\n        const ret = await role.handleEliotStateChange(elementToTreat.eliotState, oldEliotState);\n\n        elementToTreat.resolve(ret);\n\n        return this.eliotChangeElementGotTreated(elementToTreat);\n      }\n\n      // If we are the slave - Do nothing here (we just set the this.eliotState)\n      elementToTreat.resolve();\n\n      return this.eliotChangeElementGotTreated(elementToTreat);\n    } catch (err) {\n      elementToTreat.reject(err);\n\n      return this.eliotChangeElementGotTreated(elementToTreat);\n    }\n  }\n\n  /*\n   ***********************************************************************************************************\n   *\n   *                          PUBLIC METHODS TO USE\n   *\n   ***********************************************************************************************************\n   */\n\n  /**\n   * Launch the system\n   *\n   * We have to load dynamically systemBoot to avoid recursive import\n   */\n  boot() {\n    const SystemBoot = require('./systemBoot/systemBoot.js')\n      .default;\n\n    this.systemBoot = new SystemBoot()\n      .initialization();\n\n    // Get the instances of the roles class before to push it into the roleHandler\n    this.roles = this.roles.map(x => ({\n      ...x,\n\n      obj: x.class.getInstance(),\n    }));\n\n    // Initialize the role handler in here\n    this.roleHandler = new RoleHandler(this.roles);\n\n    this.systemBoot\n      .launch(this.launchMasterSlaveConfigurationFile);\n\n    this.startDate = new Date();\n  }\n\n  /**\n   * Launch the system ** can be called static **\n   */\n  static boot() {\n    RoleAndTask.getInstance()\n      .boot();\n  }\n\n  /**\n   * Getter\n   */\n  getDisplayLog() {\n    return this.displayLog;\n  }\n\n  /**\n   * Are we displaying messages or cut them all of ?\n   */\n  setDisplayLog(displayLog) {\n    this.displayLog = displayLog;\n  }\n\n  /**\n   * Getter\n   */\n  getDisplayTask() {\n    return this.displayTask;\n  }\n\n  /**\n   * Set the task which will gonna handle the display, if there is not specified, the display is going to be made in stdout\n   *\n   * We are waiting for a task id\n   */\n  setDisplayTask(displayTask) {\n    this.displayTask = displayTask;\n  }\n\n  /**\n   * Getter\n   */\n  getPathToEntryFile() {\n    return this.pathToEntryFile;\n  }\n\n  /**\n   * Setup the entry point of your program\n   *\n   * We we are launching new slaves, we gonna use it\n   */\n  setPathToEntryFile(pathToEntryFile) {\n    this.pathToEntryFile = pathToEntryFile;\n  }\n\n  /**\n   * Setup the name of the file to read in order to get the configuration\n   */\n  setLaunchConfigurationFile(filePath) {\n    this.launchMasterSlaveConfigurationFile = filePath;\n  }\n\n  /**\n   * Declare a new Role\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   * }\n   */\n  declareRole(roleConfiguration) {\n    this.roles.push(roleConfiguration);\n  }\n\n  /**\n   * Declare the given task to the task system\n   *\n   * {\n   *   name: String,\n   *   color: String,\n   *   closureHierarchy: Number,\n   *   idsAllowedRole: [String],\n   *   obj: ATask,\n   * }\n   */\n  declareTask(taskConfiguration) {\n    this.tasks.push(taskConfiguration);\n  }\n\n  /**\n   * Remove the task from the task list using the task id\n   */\n  removeTask(taskName) {\n    this.tasks = this.tasks.filter(x => x.id !== taskName);\n  }\n\n  /**\n   * Get the tasks related to the given role id\n   */\n  getRoleTasks(idRole) {\n    return this.tasks.filter(x => x.idsAllowedRole.includes(idRole));\n  }\n\n  /**\n   * Get the roles configuration\n   */\n  getRoles() {\n    return this.roles.map((x) => {\n        if (x.id === -1) return false;\n\n        return {\n          ...x,\n\n          obj: x.class.getInstance(),\n        };\n      })\n      .filter(x => x);\n  }\n\n  /**\n   * Get the actual running role\n   */\n  async getActualRole(possibilities, i) {\n    // If there is no more possibilities - Error\n    if (i >= possibilities.length) throw new Error('EXXXX : No role available');\n\n    // Try one\n    const role = await this.roleHandler.getRole(possibilities[i]);\n\n    // If its not active, do nothing\n    if (!role.isActive()) {\n      // Try next\n      return false;\n    }\n\n    // Its good we can stop now\n    return role;\n  }\n\n  /**\n   * Get the slave role nor the master\n   * Take the first that is active\n   */\n  async getSlaveNorMaster() {\n    return Utils.promiseCallUntilTrue({\n      functionToCall: this.getActualRole,\n      context: this,\n\n      args: [\n        this.roles.map(x => x.id),\n      ],\n    });\n  }\n\n  /**\n   * Change the eliot state\n   * Role master: Set this.eliotState & spread the news to itselfs tasks and slaves\n   * Role slate: Set the this.eliotState\n   */\n  changeEliotState(eliotState) {\n    return new Promise((resolve, reject) => {\n      // Push the order in the list of state change to perform\n      this.eliotStateChangeWaitingList.push({\n        resolve,\n        reject,\n        eliotState,\n        inProgress: false,\n      });\n\n      this.lookAtEliotStateChangePipe();\n    });\n  }\n\n  /**\n   * Get the name of the task who asked for the display\n   */\n  static getTheTaskWhoPerformTheDisplay(role) {\n    const activeTasks = role.getTaskHandler()\n      .getAllActiveTasks();\n\n    if (!activeTasks.length) return 'unknown';\n\n    return activeTasks[0].name;\n  }\n\n  /**\n   * Handle the display message throught the slaves and master\n   * If we are master we display the message\n   * If we are a slave we give the messsage to the master\n   * @param {Object} param\n   */\n  async displayMessage(param) {\n    try {\n      const role = await this.getSlaveNorMaster();\n\n      // Handle the fact we are trying to display an object\n      const isString = Utils.isAString(param.str);\n\n      if (isString) {\n        return role.displayMessage({\n          ...param,\n\n          // Add the task who perform the display\n          from: RoleAndTask.getTheTaskWhoPerformTheDisplay(role),\n\n          time: Date.now(),\n        });\n      }\n\n      const newParam = {\n        ...param,\n\n        // Add the task who perform the display\n        from: RoleAndTask.getTheTaskWhoPerformTheDisplay(role),\n\n        time: Date.now(),\n      };\n\n      newParam.str = JSON.stringify(newParam.str, null, 2);\n\n      // Add here the task who performed the display and the time of it\n\n      return role.displayMessage(newParam);\n    } catch (e) {\n      // Here means that we have no role available, and so that we try to display message\n      // when the role is not even launched\n      // We simply ignore the message\n      // MESSAGE TO THE DEVELOPPER, DISPLAY NOTHING BEFORE ROLES GET STARTED\n      return false;\n    }\n  }\n\n  /**\n   * Here we come when an error happened on the system and we want to deal with it,\n   * If we are the master, we tell ourselves about it\n   * If we are a slave or ... we tell the master about it\n   */\n  async errorHappened(err) {\n    // Error happens\n    Utils.displayMessage({\n      str: String((err && err.stack) || err),\n\n      out: process.stderr,\n    });\n\n    try {\n      const role = await this.getSlaveNorMaster();\n\n      if (role.id !== CONSTANT.DEFAULT_ROLE.MASTER_ROLE.id) {\n        // Send a message to the master\n        return role.tellMasterErrorHappened(err);\n      }\n\n      try {\n        // If we are the master ourselves, we put eliot in error\n        await this.changeEliotState(CONSTANT.ELIOT_STATE.ERROR);\n\n        // We did sent the message :)\n        // Display the error message\n        this.displayMessage({\n          str: String((err && err.stack) || err),\n\n          tags: [\n            CONSTANT.MESSAGE_DISPLAY_TAGS.ERROR,\n          ],\n        });\n\n        // If the errors are supposed to be fatal, exit!\n        if (CONSTANT.MAKES_ERROR_FATAL) {\n          RoleAndTask.exitEliotUnproperDueToError();\n        }\n      } catch (e) {\n        // We exit ELIOT, nothing more we can do\n        // We locally display the error so it will finish into the node-error.log file\n        RoleAndTask.exitEliotMsg('Exit eliot unproper ERROR HAPPENED', err, e);\n\n        // We use setTimeout tho if there is some others things to do before the quit it will\n        RoleAndTask.exitEliotUnproperDueToError();\n      }\n    } catch (e) {\n      RoleAndTask.exitEliotMsg('Exit eliot unproper ERROR HAPPENED CATCH', err, e);\n\n      // We use setTimeout tho if there is some others things to do before the quit it will\n      RoleAndTask.exitEliotUnproperDueToError();\n    }\n\n    return false;\n  }\n\n  /**\n   * Display messages about exiting eliot in errorHappened\n   */\n  static exitEliotMsg(txt, err, e) {\n    // We exit ELIOT, nothing more we can do\n    Utils.displayMessage({\n      str: String((err && err.stack) || err),\n      out: process.stderr,\n    });\n\n    // We locally display the error so it will finish into the node-error.log file\n    Utils.displayMessage({\n      str: String(e),\n      out: process.stderr,\n    });\n\n    Utils.displayMessage({\n      str: 'Exit eliot unproper ERROR HAPPENED CATCH',\n      out: process.stderr,\n    });\n  }\n\n  /**\n   * Make the master to quit every slaves and every task\n   * DO NOT QUIT THE APP\n   */\n  async makeTheMasterToQuitEverySlaveAndTask() {\n    // Do nothing when we already got an order for closure\n    if (this.quitOrder) return false;\n\n    this.quitOrder = true;\n\n    const role = await this.getSlaveNorMaster();\n\n    // If we are the master - handle it\n    if (role.id !== CONSTANT.DEFAULT_ROLE.MASTER_ROLE.id) throw new Error('EXXXX : Closure not possible in a slave');\n\n    /**\n     * We change the eliot state to CLOSE\n     */\n    await this.changeEliotState(CONSTANT.ELIOT_STATE.CLOSE);\n\n    return this.quit();\n  }\n\n  /**\n   * Properly quit the app if we are on master\n   * Ignore if we are inside something else\n   */\n  async makeTheMasterToQuitTheWholeApp() {\n    // If the state is LAUNCHING do not quit the app\n    if (this.eliotState === CONSTANT.ELIOT_STATE.LAUNCHING) {\n      this.displayMessage({\n        str: 'Cannot close ELIOT when the state is LAUNCHING',\n      });\n\n      return;\n    }\n\n    try {\n      const quit = await this.makeTheMasterToQuitEverySlaveAndTask();\n\n      if (quit) RoleAndTask.exitEliotGood();\n\n      // Do nothing if quit equal to false\n      // ...\n    } catch (err) {\n      RoleAndTask.getInstance()\n        .errorHappened(err);\n    }\n  }\n\n  /**\n   * We exit ELIOT unproperly due to an error that can't be fixed regulary\n   * (Ex: lose the communication between the slave and the master and we are the slave)\n   */\n  static exitEliotUnproperDueToError() {\n    // Exit after a timeout to let the system makes the displays\n    setTimeout(() => process.exit(1), CONSTANT.TIMEOUT_LEAVE_ELIOT_UNPROPER);\n  }\n\n  /**\n   * We exit ELIOT when everything had been closed the right way\n   */\n  static exitEliotGood() {\n    Utils.displayMessage({\n      str: 'Exit eliot good',\n      out: process.stderr,\n    });\n\n    process.exit(0);\n  }\n\n  /**\n   * Handle signals\n   */\n  handleSignals() {\n    // Exit ELIOT properly\n    const signalActionProper = async () => {\n      const role = await this.getSlaveNorMaster();\n\n      // If we are the master - handle it - if we are a slave ignore it\n      if (role.id !== CONSTANT.DEFAULT_ROLE.MASTER_ROLE.id) return;\n\n      this.makeTheMasterToQuitTheWholeApp();\n    };\n\n    // Exit ELIOT unproperly\n    const signalActionUnproper = () => {\n      RoleAndTask.exitEliotUnproperDueToError();\n    };\n\n    Object.keys(CONSTANT.SIGNAL)\n      .forEach((x) => {\n        process.on(CONSTANT.SIGNAL[x], () => signalActionProper());\n      });\n\n    Object.keys(CONSTANT.SIGNAL_UNPROPER)\n      .forEach((x) => {\n        process.on(CONSTANT.SIGNAL_UNPROPER[x], () => signalActionUnproper());\n      });\n  }\n\n  // ===========================================================================\n  //                        ROLE/TASK COMMUNICATION\n  // ===========================================================================\n\n  /**\n   * Send data from here to every tasks of ELIOT.\n   * We are going to send messages from communication channel's to every Slave.\n   *\n   * @param {String} dataName\n   * @param {Object} data\n   * @param {Date} timestamp\n   */\n  async sendDataToEveryELIOTTaskWhereverItIs({\n    // The name that represent the data\n    dataName,\n\n    // The data to send\n    data,\n\n    // Date of the data\n    timestamp = new Date(),\n\n    // limit to given tasks\n    limitToTaskList = false,\n  }) {\n    const {\n      DATABASE_MAINTAINANCE,\n    } = CONSTANT.ELIOT_STATE;\n\n    const {\n      COLLECTION_CRUD,\n      SCREEN_STATUS_NEWS,\n      BREAKDOWN_PARAMETER_NEWS,\n    } = CONSTANT.GENERIC_DATA_NEWS;\n\n    // If the eliotState is one of the specified and the message type one of the specified we do not send the message\n    if (Utils.checkThatAtLeastOneElementOfArray1ExistInArray2([\n        DATABASE_MAINTAINANCE,\n      ], [\n        this.eliotState,\n      ]) && Utils.checkThatAtLeastOneElementOfArray1ExistInArray2([\n        dataName,\n      ], [\n        COLLECTION_CRUD,\n        SCREEN_STATUS_NEWS,\n        BREAKDOWN_PARAMETER_NEWS,\n      ])) {\n      return true;\n    }\n\n    const role = await this.getSlaveNorMaster();\n\n    return role.sendDataToEveryELIOTTaskWhereverItIs({\n      dataName,\n      data,\n      timestamp,\n      limitToTaskList,\n    });\n  }\n\n  /**\n   * Spread data to every tasks we locally hold\n   * @param {{dataName: String, data: Object, timestamp: Date, limitToTaskList: [String] | false}} args\n   */\n  async spreadDataToEveryLocalTask({\n    dataName,\n    data,\n    timestamp,\n    limitToTaskList,\n  }) {\n    try {\n      const role = await this.getSlaveNorMaster();\n\n      role.getTaskHandler()\n        .getAllActiveTasks()\n        .forEach((x) => {\n          // Do not tell the tasks that do not require to know\n          if (!limitToTaskList || limitToTaskList.some(y => x.id === y)) {\n            // Make it asynchronous!\n            setTimeout(() => {\n              x.consumeNewsData(dataName, data, timestamp);\n            }, 0);\n          }\n        });\n    } catch (err) {\n      this.errorHappened(err);\n    }\n  }\n\n  // ===========================================================================\n\n  // Getter\n  getRoleHandler() {\n    return this.roleHandler;\n  }\n\n  /**\n   * Quit everything that is open\n   *\n   * Including:\n   *\n   * -> Close the role (Slave or Master)\n   * ----> If slave: Close its running tasks\n   * ----> If master: Close all the slaves\n   */\n  async quit() {\n    const role = await this.getSlaveNorMaster();\n\n    await role.stop();\n\n    return true;\n  }\n\n  /**\n   * THIS METHOD WORK ONLY IN THE MASTER\n   * (It get called by HandleEliotTask)\n   *\n   * It returns in an array the whole system pids (Master + Slaves processes)\n   */\n  async getFullSystemPids() {\n    const role = await this.getMasterRole();\n\n    return role.getFullSystemPids();\n  }\n\n  /**\n   * Get the master role (error if we are not in master role process)\n   */\n  async getMasterRole() {\n    const roleMaster = await this.roleHandler.getRole(CONSTANT.DEFAULT_ROLE.MASTER_ROLE.id);\n\n    // If its not active, do nothing\n    if (!roleMaster.isActive()) throw new Error('EXXXX : No role available');\n\n    // Its good\n    return roleMaster;\n  }\n\n  /*\n   ********************************************************************\n   *               STATIC METHODS TO ACCESS DIRECTLY\n   ********************************************************************\n   */\n\n  /**\n   * Declare a new Role\n   *\n   * {\n   *   name: String,\n   *   id: String,\n   * }\n   */\n  static declareRole(roleConfiguration) {\n    this.getInstance()\n      .declareRole(roleConfiguration);\n  }\n\n  /**\n   * Declare the given task to the task system\n   *\n   * {\n   *   name: String,\n   *   color: String,\n   *   closureHierarchy: Number,\n   *   idsAllowedRole: [Number],\n   *   obj: ATask,\n   * }\n   */\n  static declareTask(taskConfiguration) {\n    this.getInstance()\n      .declareTask(taskConfiguration);\n  }\n\n  /**\n   * Remove the task from the task list using the task id\n   */\n  static removeTask(taskName) {\n    this.getInstance()\n      .removeTask(taskName);\n  }\n}\n"]}