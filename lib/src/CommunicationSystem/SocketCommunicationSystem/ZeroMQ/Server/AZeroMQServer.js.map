{"version":3,"sources":["../../../../../../src/CommunicationSystem/SocketCommunicationSystem/ZeroMQ/Server/AZeroMQServer.es6"],"names":["AZeroMQServer","mode","CONSTANT","ZERO_MQ","MODE","SERVER","clientList","infosServer","newConnectionListeningFunction","newDisconnectionListeningFunction","map","x","clientIdentityString","ipServer","DEFAULT_SERVER_IP_ADDRESS","portServer","DEFAULT_SERVER_IP_PORT","socketType","SOCKET_TYPE","OMQ_ROUTER","transport","TRANSPORT","TCP","identityPrefix","SERVER_IDENTITY_PREFIX","PromiseCommandPattern","func","Promise","resolve","reject","active","socket","check","OMQ_DEALER","some","Errors","zmq","identity","process","pid","startMonitor","bind","err","console","error","stopMonitor","treatMessageFromClient","on","KEYWORDS_OMQ","CLOSE","CLOSE_ERROR","ep","String","close","ACCEPT","message","forEach","sendMessageToClient","clientIdentityByte","SERVER_MESSAGE","CLOSE_ORDER","removeClientToServer","closeConnectionToClient","exist","push","timeoutAlive","Utils","fireUp","timeoutClientConnection","timeout","disconnectClientDueToTimeoutNoProofOfLive","xi","clearTimeout","setTimeout","TIMEOUT_CLIENT_NO_PROOF_OF_LIVE","send","filter","MESSAGE","data","dataString","ret","keyStr","CLIENT_MESSAGE","ALIVE","handleAliveInformationFromSpecifiedClient","HELLO","handleNewClientToServer","incomingMessageListeningFunction","context","AZeroMQ"],"mappings":"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","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport zmq from 'zmq';\nimport CONSTANT from '../../../../Utils/CONSTANT/CONSTANT.js';\nimport AZeroMQ from '../AZeroMQ.js';\nimport Utils from '../../../../Utils/Utils.js';\nimport PromiseCommandPattern from '../../../../Utils/PromiseCommandPattern.js';\nimport Errors from '../../../../Utils/Errors.js';\n\n/**\n * Server used when you have Bidirectionnal server (like ROUTER)\n */\nexport default class AZeroMQServer extends AZeroMQ {\n  constructor() {\n    super();\n\n    // Mode we are running in\n    this.mode = CONSTANT.ZERO_MQ.MODE.SERVER;\n\n    // List of server client\n    this.clientList = [];\n\n    // Infos about server options\n    this.infosServer = false;\n\n    // Function to deal with the incoming regular messages\n    this.newConnectionListeningFunction = [];\n\n    this.newDisconnectionListeningFunction = [];\n  }\n\n  /**\n   * Get infos from the server -> ip/port ...etc\n   */\n  getInfosServer() {\n    return this.infosServer;\n  }\n\n  /**\n   * Return the list of connected clients\n   * @return {Array}\n   */\n  getConnectedClientList() {\n    return this.clientList.map(x => x.clientIdentityString);\n  }\n\n  /**\n   * Start a ZeroMQ Server\n   * @param {{ipServer: String, portServer: String, socketType: String, transport: String, identityPrefix: String}} args\n   */\n  startServer({\n    ipServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_ADDRESS,\n    portServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_PORT,\n    socketType = CONSTANT.ZERO_MQ.SOCKET_TYPE.OMQ_ROUTER,\n    transport = CONSTANT.ZERO_MQ.TRANSPORT.TCP,\n    identityPrefix = CONSTANT.ZERO_MQ.SERVER_IDENTITY_PREFIX,\n  }) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        // If the server is already up\n        if (this.active) return resolve(this.socket);\n\n        // Check the socket Type\n        const check = [\n          CONSTANT.ZERO_MQ.SOCKET_TYPE.OMQ_ROUTER,\n          CONSTANT.ZERO_MQ.SOCKET_TYPE.OMQ_DEALER,\n          // ... add here is required\n        ].some(x => x === socketType);\n\n        if (!check) return reject(new Errors('E2008', `socketType: ${socketType}`));\n\n        // Create the server socket\n        this.socket = zmq.socket(socketType);\n\n        // Set an identity to the server\n        this.socket.identity = `${identityPrefix}_${process.pid}`;\n\n        // Start the monitor that will listen to socket news\n        this.startMonitor();\n\n        // Bind the server to a port\n        return this.socket.bind(`${transport}://${ipServer}:${portServer}`, (err) => {\n          if (err) {\n            // Log something\n            console.error(`Server ZeroMQ Bind Failed. Transport=${transport} Port=${portServer} IP:${ipServer}`);\n\n            // Stop the monitoring\n            this.stopMonitor();\n\n            // Remove the socket\n            delete this.socket;\n\n            this.socket = false;\n            this.active = false;\n\n            // Return an error\n            return reject(new Errors('E2007', `Specific: ${err}`));\n          }\n\n          // Start to handle client messages\n          this.treatMessageFromClient();\n\n          this.infosServer = {\n            ipServer,\n            portServer,\n            socketType,\n            transport,\n            identityPrefix,\n          };\n\n          this.active = true;\n\n          // We successfuly bind the server\n          return resolve(this.socket);\n        });\n      }),\n    });\n  }\n\n  /**\n   * Stop a ZeroMQ Server\n   */\n  stopServer() {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        // If the server is already down\n        if (!this.active) {\n          return resolve();\n        }\n\n        // Listen to the closure of the socket\n        this.socket.on(CONSTANT.ZERO_MQ.KEYWORDS_OMQ.CLOSE, () => {\n          // Successfuly close\n          // Stop the monitoring\n          this.stopMonitor();\n\n          // Delete the socket\n          delete this.socket;\n\n          this.socket = false;\n          this.active = false;\n\n          // Empty the clientList\n          this.clientList = [];\n\n          this.infosServer = false;\n\n          return resolve();\n        });\n\n        // Error in closure\n        this.socket.on(CONSTANT.ZERO_MQ.KEYWORDS_OMQ.CLOSE_ERROR, (err, ep) => reject(new Errors('E2006', `Endpoint: ${String(err)} ${ep}`)));\n\n        // Ask for closure\n        return this.socket.close();\n      }),\n    });\n  }\n\n  /**\n   * Setup a function that is called when a new client get connected\n   * @param {Function} func\n   */\n  listenNewConnectedClientEvent(func) {\n    if (!this.active) return;\n\n    this.socket.on(CONSTANT.ZERO_MQ.KEYWORDS_OMQ.ACCEPT, func);\n  }\n\n  /**\n   * Send a message to every connected client\n   * @param {String} message\n   */\n  sendBroadcastMessage(message) {\n    this.clientList.forEach(x => this.sendMessageToClient(x.clientIdentityByte, x.clientIdentityString, message));\n  }\n\n  /**\n   * Close a connection to a client\n   */\n  closeConnectionToClient(clientIdentityByte, clientIdentityString) {\n    this.sendMessageToClient(clientIdentityByte, clientIdentityString, CONSTANT.ZERO_MQ.SERVER_MESSAGE.CLOSE_ORDER);\n\n    // Remove the client data from the array\n    this.removeClientToServer(clientIdentityByte, clientIdentityString);\n  }\n\n  /**\n   * Disconnect a user because we have got no proof of life from it since too long\n   * long defined by CONSTANT.ZERO_MQ.TIMEOUT_CLIENT_NO_PROOF_OF_LIVE\n   * @param {Arrray} clientIdentityByte\n   * @param {String} clientIdentityString\n   */\n  disconnectClientDueToTimeoutNoProofOfLive(clientIdentityByte, clientIdentityString) {\n    // Send a bye message to the client, in case he's coming back\n    this.closeConnectionToClient(clientIdentityByte, clientIdentityString);\n  }\n\n  /**\n   * Handle a new connection of client to the server\n   * (Store it into a list that will be useful create clientConnection/clientDisconnection event)\n   * @param {Arrray} clientIdentityByte\n   * @param {String} clientIdentityString\n   */\n  handleNewClientToServer(clientIdentityByte, clientIdentityString) {\n    // We put the client into a list of connected client\n    const exist = this.clientList.some(x => x.clientIdentityString === clientIdentityString);\n\n    if (!exist) {\n      this.clientList.push({\n        clientIdentityString,\n        clientIdentityByte,\n        timeoutAlive: false,\n      });\n\n      Utils.fireUp(this.newConnectionListeningFunction, [\n        clientIdentityByte,\n        clientIdentityString,\n      ]);\n    }\n\n    // Call a function that will disconnected the client from the server is he sent nothing\n    // in a pre-defined period\n    this.timeoutClientConnection(clientIdentityByte, clientIdentityString);\n  }\n\n  /**\n   * Function that is executed to handle client timeout\n   * Not proof of life from too long\n   * @param {Arrray} clientIdentityByte\n   * @param {String} clientIdentityString\n   */\n  timeoutClientConnection(clientIdentityByte, clientIdentityString) {\n    // Function execution\n    const timeout = () => {\n      // Disconnect the user to the server\n      this.disconnectClientDueToTimeoutNoProofOfLive(clientIdentityByte, clientIdentityString);\n    };\n\n    this.clientList.some((x, xi) => {\n      if (x.clientIdentityString === clientIdentityString) {\n        // If we had a pre-existing timeout, relaunch it\n        if (this.clientList[xi].timeoutAlive) clearTimeout(this.clientList[xi].timeoutAlive);\n\n        // Create a timeout\n        this.clientList[xi].timeoutAlive = setTimeout(() => timeout(), CONSTANT.ZERO_MQ.TIMEOUT_CLIENT_NO_PROOF_OF_LIVE);\n\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Send a message to the client\n   * @param {Arrray} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {String} message\n   */\n  sendMessageToClient(clientIdentityByte, clientIdentityString, message) {\n    if (this.socket && this.active) {\n      this.socket.send([\n        clientIdentityString,\n        message,\n      ]);\n    }\n  }\n\n  /**\n   * We know that the specified client is alive (he sent something to us)\n   * @param {Arrray} clientIdentityByte\n   * @param {String} clientIdentityString\n   */\n  handleAliveInformationFromSpecifiedClient(clientIdentityByte, clientIdentityString) {\n    this.clientList.some((x) => {\n      if (clientIdentityString === x.clientIdentityString) {\n        // Handle the user timeout\n        this.timeoutClientConnection(clientIdentityByte, clientIdentityString);\n\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Remove a client from the clientList array\n   * @param {Arrray} clientIdentityByte\n   * @param {String} clientIdentityString\n   */\n  removeClientToServer(clientIdentityByte, clientIdentityString) {\n    this.clientList = this.clientList.filter(x => x.clientIdentityString !== clientIdentityString);\n\n    Utils.fireUp(this.newDisconnectionListeningFunction, [\n      clientIdentityByte,\n      clientIdentityString,\n    ]);\n  }\n\n  /**\n   * Treat messages that comes from clients\n   */\n  treatMessageFromClient() {\n    this.socket.on(CONSTANT.ZERO_MQ.KEYWORDS_OMQ.MESSAGE, (clientIdentityByte, data) => {\n      const dataString = String(data);\n      const clientIdentityString = String(clientIdentityByte);\n\n      const ret = [\n        //\n        //\n        // Here we treat special strings\n        //\n        //\n        {\n          keyStr: CONSTANT.ZERO_MQ.CLIENT_MESSAGE.ALIVE,\n          func: () => {\n            // We got a keepAlive message from client\n            // We got something from the client we know he's not disconnected\n            this.handleAliveInformationFromSpecifiedClient(clientIdentityByte, clientIdentityString);\n          },\n        }, {\n          keyStr: CONSTANT.ZERO_MQ.CLIENT_MESSAGE.HELLO,\n          func: () => this.handleNewClientToServer(clientIdentityByte, clientIdentityString),\n        },\n      ].some((x) => {\n        if (x.keyStr === dataString) {\n          x.func();\n\n          return true;\n        }\n\n        return false;\n      });\n\n      // If the user have a function to deal with incoming messages\n      if (!ret) {\n        Utils.fireUp(this.incomingMessageListeningFunction, [\n          clientIdentityByte,\n          clientIdentityString,\n          dataString,\n        ]);\n      }\n\n      if (!ret) {\n        // We got something from the client we know he's not disconnected\n        this.handleAliveInformationFromSpecifiedClient(clientIdentityByte, clientIdentityString);\n      }\n    });\n  }\n\n  /**\n   * Push the function that will get when a new connection is detected\n   * @param {Function} func\n   * @param {Object} context\n   */\n  listenClientConnectionEvent(func, context) {\n    this.newConnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Push the function that will get when a disconnection is detected\n   * @param {Function} func\n   * @param {Object} context\n   */\n  listenClientDisconnectionEvent(func, context) {\n    this.newDisconnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n}\n"],"file":"AZeroMQServer.js"}