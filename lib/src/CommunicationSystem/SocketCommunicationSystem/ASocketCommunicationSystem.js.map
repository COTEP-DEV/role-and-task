{"version":3,"sources":["../../../../src/CommunicationSystem/SocketCommunicationSystem/ASocketCommunicationSystem.es6"],"names":["ASocketCommunicationSystem","name","CONSTANT","SOCKET_COMMUNICATION_SYSTEM","ABSTRACT_SOCKET_COMMUNICATION_SYSTEM","active","incomingMessageListeningFunction","Error","Utils","getFunctionName","_","reject","func","context","push","filter","x"],"mappings":";;;;;;;;;;;;;;;;;;AAKA;;;;AACA;;;;;;AAEA;;;AARA;AACA;AACA;;AAEA;IAOqBA,0B;AACnB,wCAAc;AAAA;;AACZ;AACA,SAAKC,IAAL,GAAYC,mBAASC,2BAAT,CAAqCC,oCAAjD;;AAEA;AACA,SAAKC,MAAL,GAAc,KAAd;;AAEA;AACA,SAAKC,gCAAL,GAAwC,EAAxC;AACD;;AAED;;;;;;;;8BAIU;AACR,aAAO,KAAKL,IAAZ;AACD;;AAED;;;;;;;4BAIQA,I,EAAM;AACZ,WAAKA,IAAL,GAAYA,IAAZ;AACD;;AAED;;;;;;;gCAIY;AACV,YAAM,IAAIM,KAAJ,yCAAgDC,gBAAMC,eAAN,EAAhD,YAAN;AACD;;AAED;;;;;;;4BAIQ;AACN,aAAO,sBAAY,UAACC,CAAD,EAAIC,MAAJ;AAAA,eAAeA,OAAO,IAAIJ,KAAJ,qCAA4CC,gBAAMC,eAAN,EAA5C,YAAP,CAAf;AAAA,OAAZ,CAAP;AACD;;AAED;;;;;;;2BAIO;AACL,aAAO,sBAAY,UAACC,CAAD,EAAIC,MAAJ;AAAA,eAAeA,OAAO,IAAIJ,KAAJ,oCAA2CC,gBAAMC,eAAN,EAA3C,YAAP,CAAf;AAAA,OAAZ,CAAP;AACD;;AAED;;;;;;;+BAIW;AACT,aAAO,KAAKJ,MAAZ;AACD;;AAED;;;;;;;kCAIc;AACZ,YAAM,IAAIE,KAAJ,2CAAkDC,gBAAMC,eAAN,EAAlD,YAAN;AACD;;AAED;;;;;;;;4CAKwBG,I,EAAMC,O,EAAS;AACrC,WAAKP,gCAAL,CAAsCQ,IAAtC,CAA2C;AACzCF,kBADyC;AAEzCC;AAFyC,OAA3C;AAID;;AAED;;;;;;;8CAI0BD,I,EAAM;AAC9B,WAAKN,gCAAL,GAAwC,KAAKA,gCAAL,CAAsCS,MAAtC,CAA6C;AAAA,eAAKC,EAAEJ,IAAF,KAAWA,IAAhB;AAAA,OAA7C,CAAxC;AACD;;;;;kBAtFkBZ,0B","file":"ASocketCommunicationSystem.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport CONSTANT from '../../Utils/CONSTANT/CONSTANT.js';\nimport Utils from '../../Utils/Utils.js';\n\n/**\n * This abstract class described what a socket communication system class must offer\n */\nexport default class ASocketCommunicationSystem {\n  constructor() {\n    // Setup a name\n    this.name = CONSTANT.SOCKET_COMMUNICATION_SYSTEM.ABSTRACT_SOCKET_COMMUNICATION_SYSTEM;\n\n    // Say the communication system is not active\n    this.active = false;\n\n    // Function that get called when a new message get received\n    this.incomingMessageListeningFunction = [];\n  }\n\n  /**\n   * Getter\n   * @return {String}\n   */\n  getName() {\n    return this.name;\n  }\n\n  /**\n   * Setter\n   * @param {String} name\n   */\n  setName(name) {\n    this.name = name;\n  }\n\n  /**\n   * Return an object that can be used to act the communication system\n   * @abstract\n   */\n  getSocket() {\n    throw new Error(`Unimplemented getSocket methods in ${Utils.getFunctionName()} child`);\n  }\n\n  /**\n   * Start the communication system\n   * @abstract\n   */\n  start() {\n    return new Promise((_, reject) => reject(new Error(`Unimplemented start methods in ${Utils.getFunctionName()} child`)));\n  }\n\n  /**\n   * Stop the communication system\n   * @abstract\n   */\n  stop() {\n    return new Promise((_, reject) => reject(new Error(`Unimplemented stop methods in ${Utils.getFunctionName()} child`)));\n  }\n\n  /**\n   * Is the communication sytem active?\n   * @return {Boolean}\n   */\n  isActive() {\n    return this.active;\n  }\n\n  /**\n   * Send a message\n   * @abstract\n   */\n  sendMessage() {\n    throw new Error(`Unimplemented sendMessage methods in ${Utils.getFunctionName()} child`);\n  }\n\n  /**\n   * Push the function that will handle incoming regular message (no keepAlive messages or others specific)\n   * @param {Function} func\n   * @param {Object} context\n   */\n  listenToIncomingMessage(func, context) {\n    this.incomingMessageListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Pull the function that will handle incoming regular message (no keepAlive messages or others specific)\n   * @param {Function} func\n   */\n  unlistenToIncomingMessage(func) {\n    this.incomingMessageListeningFunction = this.incomingMessageListeningFunction.filter(x => x.func !== func);\n  }\n}\n"]}