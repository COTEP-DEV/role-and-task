{"version":3,"sources":["../../../src/Utils/PromiseCommandPattern.es6"],"names":["PromiseCommandPattern","func","error","funcToExecute","callerFunctionName","Utils","getFunctionName","CONSTANT","NUMBER_OF_LEVEL_TO_GO_BACK_PROMISE_PATTERN","executeAsync","call","Errors","staticIsAnError","String","stack","executeFunctionToExecute","QUIT","stackTrace","shortcutStackTraceSpecial"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAKA;;;;AACA;;;;AACA;;;;;;AAEA;;;IAGqBA,qB;AACnB;;;;;;;;;;;;AAYA,uCAGG;AAAA,QAFDC,IAEC,QAFDA,IAEC;AAAA,QADDC,KACC,QADDA,KACC;AAAA;;AACD;AACA,SAAKC,aAAL,GAAqBF,IAArB;;AAEA,SAAKG,kBAAL,GAA0BC,gBAAMC,eAAN,CAAsBC,mBAASC,0CAA/B,CAA1B;;AAEA,SAAKN,KAAL,GAAaA,SAAS,KAAtB;;AAEA,WAAO,KAAKO,YAAL,EAAP;AACD;;AAED;;;;;;;;;;;;;;;iDAOW,KAAKN,aAAL,CAAmBO,IAAnB,CAAwB,IAAxB,C;;;;;AAEDR,qB,GAAQ,CAACS,iBAAOC,eAAP,aAAD,GACZ,IAAID,gBAAJ,CAAW,aAAX,EAA0BE,OAAQ,eAAO,YAAIC,KAAZ,eAAP,CAA1B,EAA6D,KAAKV,kBAAlE,CADY,c;;AAId;;qBACI,KAAKF,K;;;;;;uBACD,KAAKA,KAAL,CAAWA,KAAX,C;;;;;;;sBAEAA,K;;;iDAGD,K;;;;;;;;;;;;;;;;;AAIX;;;;;;;;;;;;;;kDAMW,KAAKa,wBAAL,E;;;;;;sBAIH,iBAAQR,mBAASS,I;;;;;;;;AACrB;AACA;;AAEMd,qB,GAAQ,CAACS,iBAAOC,eAAP,cAAD,GACZ,IAAID,gBAAJ,CAAW,aAAX,EAA0BE,OAAQ,gBAAO,aAAIC,KAAZ,gBAAP,CAA1B,EAA6D,KAAKV,kBAAlE,CADY,e;;qBAIV,KAAKa,U;;;;;sBAAkBN,iBAAOO,yBAAP,CAAiChB,KAAjC,EAAwC,KAAKE,kBAA7C,C;;;sBAErBF,K;;;;;;;;;;;;;;;;;;KAnFZ;AACA;AACA;;AAEA;;;kBAQqBF,qB","file":"PromiseCommandPattern.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// import\nimport Errors from './Errors.js';\nimport Utils from './Utils.js';\nimport CONSTANT from './CONSTANT/CONSTANT.js';\n\n/**\n * Define a pattern that can be used to handle function execution errors easily\n */\nexport default class PromiseCommandPattern {\n  /**\n   * Constructor\n   *\n   * {{\n   *   // Function to execute\n   *   func: Function,\n   *\n   *   // Function to call to handle the error\n   *   error: Function,\n   * }}\n   *\n   */\n  constructor({\n    func,\n    error,\n  }) {\n    // If we have the old system (with asyn execute new code)\n    this.funcToExecute = func;\n\n    this.callerFunctionName = Utils.getFunctionName(CONSTANT.NUMBER_OF_LEVEL_TO_GO_BACK_PROMISE_PATTERN);\n\n    this.error = error || false;\n\n    return this.executeAsync();\n  }\n\n  /**\n   * Execute the fuinction to execute which is the purpose of PromiseCommandPattern\n   */\n  async executeFunctionToExecute() {\n    try {\n      // Classes the user asked for\n      // Functions the users wants to access @example Spread a news\n      return this.funcToExecute.call(null);\n    } catch (err) {\n      const error = !Errors.staticIsAnError(err) ?\n        new Errors('EUNEXPECTED', String((err && err.stack) || err), this.callerFunctionName) :\n        err;\n\n      // If the user have a special error use, use it\n      if (this.error) {\n        await this.error(error);\n      } else {\n        throw error;\n      }\n\n      return false;\n    }\n  }\n\n  /**\n   * Execute the command using async syntax\n   */\n  async executeAsync() {\n    try {\n      // Execute the function to execute (purpose of PromiseCommandPattern)\n      return this.executeFunctionToExecute();\n    } catch (err) {\n      // PARTICULAR CASE TO HANDLE QUIT\n      // PARTICULAR CASE TO HANDLE QUIT\n      if (err === CONSTANT.QUIT) return err;\n      // PARTICULAR CASE TO HANDLE QUIT\n      // PARTICULAR CASE TO HANDLE QUIT\n\n      const error = !Errors.staticIsAnError(err) ?\n        new Errors('EUNEXPECTED', String((err && err.stack) || err), this.callerFunctionName) :\n        err;\n\n      if (this.stackTrace) throw Errors.shortcutStackTraceSpecial(error, this.callerFunctionName);\n\n      throw error;\n    }\n  }\n}\n"]}