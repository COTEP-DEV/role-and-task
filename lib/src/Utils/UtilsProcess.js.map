{"version":3,"sources":["../../../src/Utils/UtilsProcess.es6"],"names":["instance","UtilsProcess","allPids","goodPids","filter","Utils","checkThatAtLeastOneElementOfArray1ExistInArray2","x","RoleAndTask","getInstance","getFullSystemPids","healthy","evaluateNumberOfProcessThatExist","allProcess","zombies","getZombieFromAllPid","resolve","reject","childProcess","exec","monoline","error","stdout","stderr","Error","String","regexp","filtered","match","pids","map","split","pid"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;AACA;;;;AACA;;;;;;AAEA,IAAIA,WAAW,IAAf;;AAEA;;;AAXA;AACA;AACA;;AAEA;;IAUqBC,Y;AACnB;;;AAGA,0BAAc;AAAA;;AACZ,QAAID,QAAJ,EAAc,OAAOA,QAAP;;AAEdA,eAAW,IAAX;;AAEA,WAAOA,QAAP;AACD;;AAED;;;;;;;kCAGqB;AACnB,aAAOA,YAAY,IAAIC,YAAJ,EAAnB;AACD;;AAED;;;;;;;;wCAK2BC,O,EAASC,Q,EAAU;AAC5C,aAAOD,QAAQE,MAAR,CAAe;AAAA,eAAK,CAACC,gBAAMC,+CAAN,CAAsD,CAACC,CAAD,CAAtD,EAA2DJ,QAA3D,CAAN;AAAA,OAAf,CAAP;AACD;;AAED;;;;;;;;;;;;;;uBAKwBK,sBAAYC,WAAZ,GACnBC,iBADmB,E;;;AAAhBC,uB;;uBAImBV,aAAaW,gCAAb,E;;;AAAnBC,0B;;;AAEN;AACMC,uB,GAAUb,aAAac,mBAAb,CAAiCF,UAAjC,EAA6CF,OAA7C,C;iDAET;AACLG,kCADK;AAELH;AAFK,iB;;;;;;;;;;;;;;;;;AAMT;;;;;;;;;;;;kDAIS,sBAAY,UAACK,OAAD,EAAUC,MAAV,EAAqB;AACtCC,0CAAaC,IAAb,CAAkBd,gBAAMe,QAAN,CAAe;AAC/B;AACA,0BAF+B;AAG/B;AACA,uBAJ+B;AAK/B;AACA,yGAN+B;AAO/B;AACA;AACA;AACA;AACA;AACA;AACA;AAbgB,mBAAlB,EAcI,UAACC,KAAD,EAAQC,MAAR,EAAgBC,MAAhB,EAA2B;AAC7B;AACA,wBAAIF,KAAJ,EAAW,OAAOJ,OAAO,IAAIO,KAAJ,cAAqBC,OAAOJ,KAAP,CAArB,CAAP,CAAP;;AAEX;AACA,wBAAIE,MAAJ,EAAY,OAAON,OAAO,IAAIO,KAAJ,cAAqBC,OAAOF,MAAP,CAArB,CAAP,CAAP;;AAEZ;AACA,wBAAMG,SAAS,uBAAf;;AAEA,wBAAMC,WAAWL,OAAOM,KAAP,CAAaF,MAAb,CAAjB;;AAEA;AACA,wBAAMG,OAAOF,SAASG,GAAT,CAAa;AAAA,6BAAKL,OAAOlB,EAAEwB,KAAF,CAAQ,GAAR,EAAa,CAAb,CAAP,CAAL;AAAA,qBAAb,CAAb;;AAEA;AACA,2BAAOf,QAAQa,IAAR,CAAP;AACD,mBA/BD;AAgCD,iBAjCM,C;;;;;;;;;;;;;;;;;AAoCT;;;;;;mCAGsBG,G,EAAK;AACzB,aAAO,sBAAY,UAAChB,OAAD,EAAUC,MAAV,EAAqB;AACtCC,gCAAaC,IAAb,cAA6Ba,GAA7B,EAAoC,UAACX,KAAD,EAAQC,MAAR,EAAgBC,MAAhB,EAA2B;AAC7D;AACA,cAAIF,KAAJ,EAAW,OAAOJ,OAAO,IAAIO,KAAJ,cAAqBC,OAAOJ,KAAP,CAArB,CAAP,CAAP;;AAEX;AACA,cAAIE,MAAJ,EAAY,OAAON,OAAO,IAAIO,KAAJ,cAAqBC,OAAOF,MAAP,CAArB,CAAP,CAAP;;AAEZ,iBAAOP,QAAQgB,GAAR,CAAP;AACD,SARD;AASD,OAVM,CAAP;AAWD;;;;;kBAvGkB/B,Y","file":"UtilsProcess.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// imports\nimport childProcess from 'child_process';\nimport Utils from './Utils.js';\nimport RoleAndTask from '../RoleAndTask.js';\n\nlet instance = null;\n\n/**\n * This class handle all processes that are related to ELIOT instance\n */\nexport default class UtilsProcess {\n  /**\n   * Constructor\n   */\n  constructor() {\n    if (instance) return instance;\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * Singleton implementation\n   */\n  static getInstance() {\n    return instance || new UtilsProcess();\n  }\n\n  /**\n   * Return an array that contains all zombies pids\n   * @param {Array} allPids\n   * @param {Array} goodPids\n   */\n  static getZombieFromAllPid(allPids, goodPids) {\n    return allPids.filter(x => !Utils.checkThatAtLeastOneElementOfArray1ExistInArray2([x], goodPids));\n  }\n\n  /**\n   * Evaluate ELIOT processes and return a list of Zombies and Healthy processes that are actually running\n   */\n  static async evaluateEliotProcesses() {\n    // Get the processes that have right to exist\n    const healthy = await RoleAndTask.getInstance()\n      .getFullSystemPids();\n\n    // We first evalutate all process that exist\n    const allProcess = await UtilsProcess.evaluateNumberOfProcessThatExist();\n\n    // Extract the zombies from all pids that get detected\n    const zombies = UtilsProcess.getZombieFromAllPid(allProcess, healthy);\n\n    return {\n      zombies,\n      healthy,\n    };\n  }\n\n  /**\n   * Evaluate the number of processus that exist\n   */\n  static async evaluateNumberOfProcessThatExist() {\n    return new Promise((resolve, reject) => {\n      childProcess.exec(Utils.monoline([\n        // Display the processes\n        'ps aux',\n        // Give the result to the next command\n        ' | ',\n        // Use a regexp to identify the lines that correspond to ELIOT processes only [+ tests mocha processes]\n        'grep -oEi \\'([0-9].+?node.+src/systemBoot.+)|([0-9].+?node.+node_modules.+?mocha.+)\\'',\n        //\n        // WARNING problem here, ps aux return the processes created by the command itself\n        // so we need to exclude it later using another regexp\n        //\n        // WARNING problem here, ps return the processes created by npm\n        // so we need to exclude it later using another regexp\n        //\n      ]), (error, stdout, stderr) => {\n        // Error of childProcess\n        if (error) return reject(new Error(`E8083 : ${String(error)}`));\n\n        // Error of the console command\n        if (stderr) return reject(new Error(`E8083 : ${String(stderr)}`));\n\n        // Pass a second regexp to remove the pid of the commands themselves moreover npm scripts\n        const regexp = /^((?!grep|npm).)+$/img;\n\n        const filtered = stdout.match(regexp);\n\n        // Now we extract pid from filtered data\n        const pids = filtered.map(x => String(x.split(' ')[0]));\n\n        // Exclude processes about the command itself\n        return resolve(pids);\n      });\n    });\n  }\n\n  /**\n   * Kill one process\n   */\n  static killOneProcess(pid) {\n    return new Promise((resolve, reject) => {\n      childProcess.exec(`kill -9 ${pid}`, (error, stdout, stderr) => {\n        // Error of childProcess\n        if (error) return reject(new Error(`E8083 : ${String(error)}`));\n\n        // Error of the console command\n        if (stderr) return reject(new Error(`E8083 : ${String(stderr)}`));\n\n        return resolve(pid);\n      });\n    });\n  }\n}\n"]}