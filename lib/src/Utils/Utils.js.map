{"version":3,"sources":["../../../src/Utils/Utils.ts"],"names":["Utils","generatedId","process","pid","Math","random","toString","substr","min","max","round","nb","floor","json","value","Object","keys","find","x","parts","reduce","str","context","func","objToIterate","nameToSend","nameTakenInDocs","additionnalJsonData","additionnalParams","_i","_rets","length","val","obj","forEach","apply","ret","recursiveCallFunction","interfaces","os","networkInterfaces","tmp","concat","filter","iface","family","internal","map","address","err","String","stack","dataString","JSON","parse","_","cmd","options","maxBuffer","Promise","resolve","reject","childProcess","exec","res","Errors","character","repeat","processArray","onStdout","onStderr","ls","spawn","push","stdout","on","stderr","code","index","indexOf","splice","timeInMs","setTimeout","carriageReturn","out","from","time","Date","now","write","format","CONSTANT","MOMENT_CONSOLE_DATE_DISPLAY_FORMAT","filename","fs","readFile","data","content","hjson","functionToCall","args","i","executePromiseCallUntilTrue","conf","executePromiseQueue","numberFuncToGoBack","Error","splitted","split","trimmed","trim","arrayOfFunction","v","isAJSON","Array","regexp","test","isABoolean","RegExp","MONGO_DB_ID_LENGTH","Number","getTime","stat","isAString","regexpIpv4","regexpIpv6","regexpJson","isAnInteger","isAFloat","e"],"mappings":"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","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n/*\n * This class contain utilitaries functions\n */\n\n// Includes\nimport os from 'os';\n\nimport moment from 'moment';\nimport fs from 'fs';\nimport hjson from 'hjson';\nimport pusage from 'pidusage';\nimport childProcess from 'child_process';\nimport CONSTANT from './CONSTANT/CONSTANT.js';\nimport Errors from './Errors.js';\n\n/**\n * Contain utilitaries functions\n */\nexport default class Utils {\n  /**\n   * Get an unique id (Specific to Program)\n   * USE THE PID OF THE APP TO GET AN INTER-PROGRAM UNIQUE IDENTIFIER\n   */\n  static generateUniqueProgramID() {\n    if (!Utils.generatedId) Utils.generatedId = 2;\n\n    Utils.generatedId += 1;\n\n    return `${process.pid}x${Utils.generatedId}`;\n  }\n\n  /**\n   * Generate a little ID usefull for log for example\n   */\n  static generateLittleID() {\n    return Math.random()\n      .toString(36)\n      .substr(2, 10);\n  }\n\n  /**\n   * Generate a random value from min to max\n   * @param {Number} min\n   * @param {Number} max\n   * @param {Boolean} round\n   */\n  static generateRandom(min, max, round = true) {\n    const nb = (Math.random() * ((max - min) + 1)) + min;\n\n    if (round) return Math.floor(nb);\n\n    return nb;\n  }\n\n  /**\n   * Return the name of thekey that are behind the given value\n   * @param {Object} json\n   * @param {String} value\n   */\n  static getJsonCorrespondingKey(json, value) {\n    return Object.keys(json)\n      .find(x => json[x] === value);\n  }\n\n  /**\n   * Create a monoline from an array which is usefull when you have a line that is too long\n   */\n  static monoline(parts) {\n    return parts.reduce((str, x) => `${str}${x}`, '');\n  }\n\n  /**\n   * Call recursively the function given in parameter for each iteration of the object\n   * It works for a given function pattern\n   * Call resolve with an array that contains results of called functions\n   *\n   * @param {{\n   *  context: Object,\n   *\n   *  func: Function,\n   *\n   *  objToIterate: [Object],\n   *\n   *  // name of the field that is sent to the function\n   *  // if its equals to null, it means we have to send data into NON JSON structure\n   *  nameToSend: String,\n   *\n   *  // name of the field we took from the docs to sent to the function,\n   *  // if its equals to null, it means the objToIterate is an array that contains directs values\n   *  // (DO NOT WORK WITH COLLECTION_ENTRY OBJECTS)\n   *  nameTakenInDocs: String,\n   *\n   *  // to pass in addition to the id  - DO NOT WORK WITH nameToSend = null\n   *  additionnalJsonData: Object,\n   *\n   *  // to pass in addition of the generated json\n   *  additionnalParams: [],\n   *\n   *  _i: ?Number,\n   *\n   *  _rets: ?Array, // all returns of the functions we called\n   * }}\n   */\n  static async recursiveCallFunction({\n    context,\n    func,\n    objToIterate,\n    nameToSend = '_id',\n    nameTakenInDocs = '_id',\n    additionnalJsonData = {},\n    additionnalParams = [],\n    _i = 0,\n    _rets = [],\n  }) {\n    if (!objToIterate) return _rets;\n\n    // If our job is done\n    if (_i >= objToIterate.length) return _rets;\n\n    // Get the value from the objToIterate following the given parameters\n    const val = nameTakenInDocs ? objToIterate[_i][nameTakenInDocs] : objToIterate[_i];\n\n    // Put the val into a JSON or a regular object\n    const obj = nameToSend ? {\n      [nameToSend]: val,\n    } : val;\n\n    // if we have a JSON object and additionnalJsonData\n    if (nameToSend) {\n      Object.keys(additionnalJsonData)\n        .forEach((x) => {\n          obj[x] = additionnalJsonData[x];\n        });\n    }\n\n    // Call the func\n    const ret = await func.apply(context, [obj, ...additionnalParams]);\n\n    // Call next\n    return Utils.recursiveCallFunction({\n      context,\n      func,\n      objToIterate,\n      nameToSend,\n      nameTakenInDocs,\n      additionnalJsonData,\n      additionnalParams,\n\n      _i: _i + 1,\n\n      _rets: (ret ? [\n        ..._rets,\n        ret,\n      ] : _rets),\n    });\n  }\n\n  /**\n   * Get the Ips of the local machine\n   */\n  static givesLocalIps() {\n    try {\n      // Get network interfaces\n      const interfaces = os.networkInterfaces();\n\n      return Object.keys(interfaces)\n        .reduce((tmp, x) => tmp.concat(interfaces[x]), [])\n        .filter(iface => iface.family === 'IPv4' && !iface.internal)\n        .map(iface => iface.address);\n    } catch (err) {\n      return String((err && err.stack) || err);\n    }\n  }\n\n  /**\n   * Convert a string to JSON\n   * If he cannot parse it, return false\n   * @param {String} dataString\n   */\n  static convertStringToJSON(dataString) {\n    return (() => {\n      try {\n        return JSON.parse(dataString);\n      } catch (_) {\n        return false;\n      }\n    })();\n  }\n\n  /**\n   * Execute a command line\n   * By default, set the maxBuffer option to 2GB\n   */\n  static execCommandLine(cmd, options = {\n    maxBuffer: 1024 * 2000,\n  }) {\n    return new Promise((resolve, reject) => {\n      childProcess.exec(cmd, options, (err, res) => {\n        if (err) {\n          return reject(new Errors('E8191', `${String(err)}`));\n        }\n\n        return resolve(res);\n      });\n    });\n  }\n\n  /**\n   * Generate a string using the given char repeated x time\n   * @param {character} String\n   * @param {Number} nb\n   */\n  static generateStringFromSameChar(character, nb) {\n    return character.repeat(nb);\n  }\n\n  /**\n   * Execute a command line\n   * Execute the given onStdout function when stdout datas are given\n   * When onStdout is not set, do nothing about the data\n   * Execute the given onStderr function when stderr datas are given\n   * When onStderr is not set, do nothing about the data\n   */\n  static execStreamedCommandLine({\n    cmd,\n    options = [],\n    processArray = false,\n    onStdout,\n    onStderr,\n  }) {\n    return new Promise((resolve, reject) => {\n      const ls = childProcess.spawn(cmd, options);\n\n      if (processArray) {\n        processArray.push(ls);\n      }\n\n      if (!onStdout) {\n        ls.stdout.on('data', () => true);\n      } else {\n        ls.stdout.on('data', onStdout);\n      }\n\n      if (!onStderr) {\n        ls.stderr.on('data', () => true);\n      } else {\n        ls.stderr.on('data', onStderr);\n      }\n\n      ls.on('close', (code) => {\n        if (code === 'SIGINT') {\n          reject(code);\n        }\n\n        const index = processArray.indexOf(ls);\n\n        if (index !== -1) {\n          processArray.splice(index, 1);\n        }\n\n        resolve(code);\n      });\n\n      ls.on('error', (err) => {\n        const index = processArray.indexOf(ls);\n\n        if (index !== -1) {\n          processArray.splice(index, 1);\n        }\n\n        reject(new Errors('E8200', `${err.toString()}`));\n      });\n    });\n  }\n\n  /**\n   * Sleep some time\n   */\n  static sleep(timeInMs) {\n    return new Promise((resolve) => {\n      setTimeout(() => resolve(), timeInMs);\n    });\n  }\n\n  /**\n   * Display a message in console\n   * @param {{\n   *   str: String,\n   *   carriageReturn: Boolean,\n   *   out: Object,\n   *   from: String,\n   * }}\n   */\n  static displayMessage({\n    str,\n    carriageReturn = true,\n    out = process.stdout,\n    from = process.pid,\n    time = Date.now(),\n  }) {\n    out.write(`${moment(time).format(CONSTANT.MOMENT_CONSOLE_DATE_DISPLAY_FORMAT)}:${from} > - ${str}${carriageReturn ? '\\n' : ''}`);\n  }\n\n  /**\n   * Read a file asynchronously\n   */\n  static readFile(filename, options = 'utf8') {\n    return new Promise((resolve, reject) => {\n      fs.readFile(filename, options, (err, data) => {\n        if (err) return reject(new Errors('E8088', `filename: ${filename}`, String(err)));\n\n        return resolve(data);\n      });\n    });\n  }\n\n  /**\n   * Parse hjson content (Human JSON --> npm module)\n   * @param {String} content\n   */\n  static async parseHjsonContent(content) {\n    try {\n      return hjson.parse(content);\n    } catch (err) {\n      throw new Errors('E8089', `${String(err)}`);\n    }\n  }\n\n  /**\n   * DO NOT CALL IT DIRECTLY, it is used by promiseCallUntilTrue\n   *\n   * RECURSIVE\n   */\n  static async executePromiseCallUntilTrue({\n    functionToCall,\n    context,\n    args,\n    i = 0,\n  }) {\n    const ret = await functionToCall.apply(context, [\n      ...args,\n\n      i,\n    ]);\n\n    if (ret !== false && ret.args === void 0) return ret;\n\n    // Call again\n    return Utils.executePromiseCallUntilTrue({\n      functionToCall,\n      context,\n      args: ret.args === void 0 ? args : ret.args,\n\n      i: ret.i === void 0 ? i + 1 : ret.i,\n    });\n  }\n\n  /**\n   * Call the given function until it return something different than false\n   *\n   * If the function returns :\n   *\n   * false                                -> We make an another call with the same args\n   * true                                 -> We stop the calls and return true\n   * { args: something }                  -> We make an another call with the new given args\n   * { args: something, i: something }    -> We make an another call with the new given args and changing the i\n   * anything else                        -> we stop the calls and return wathever it is\n   *\n   * {\n   *   functionToCall,\n   *   context,\n   *   args,\n   *   i = 0,\n   * }\n   *\n   * i is the index you can force to start with instead of 0\n   */\n  static async promiseCallUntilTrue(conf) {\n    return Utils.executePromiseCallUntilTrue(conf);\n  }\n\n  /**\n   * DO NOT CALL IT DIRECTLY, it is used by promiseQueue\n   *\n   * RECURSIVE\n   */\n  static async executePromiseQueue(conf, _rets = [], _i = 0) {\n    // Is the job done?\n    if (_i >= conf.length) return _rets;\n\n    // Execute one\n    const {\n      functionToCall,\n      context = this,\n      args = [],\n    } = conf[_i];\n\n    _rets.push(await functionToCall.apply(context, args));\n\n    // Call next\n    return Utils.executePromiseQueue(conf, _rets, _i + 1);\n  }\n\n  /**\n   * Execute the given functions one by one, and the return the ret of them in an array\n   *\n   * -> it's a Promise.all but one by one instead of parallel\n   *\n   * [{\n   *   // The function you want to call\n   *   functionToCall,\n   *\n   *   // The context to use when you are calling it\n   *   context,\n   *\n   *   // The argument to pass to the functionToCall (must be in an array)\n   *   args,\n   * }]\n   */\n  static async promiseQueue(conf) {\n    return Utils.executePromiseQueue(conf);\n  }\n\n  /**\n   * Return the name of the function that call this function\n   * IT'S A HACK\n   */\n  static getFunctionName(numberFuncToGoBack = 1) {\n    const err = new Error('tmpErr');\n\n    const splitted = err.stack\n      .split('\\n');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (numberFuncToGoBack >= splitted.length) {\n      return err.stack;\n    }\n\n    const trimmed = splitted[numberFuncToGoBack]\n      .trim(' ');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (!trimmed.length) return err.stack;\n\n    return trimmed.split(' ')[1];\n  }\n\n  /**\n   * Fire functions that are in the given array and pass args to it\n   * @param {[?({func: Function, context: Object},func)]} arrayOfFunction\n   * @param {Array} args\n   */\n  static fireUp(arrayOfFunction, args) {\n    if (arrayOfFunction.length) {\n      arrayOfFunction.forEach((x) => {\n        if (x && x.func && typeof x.func === 'function') x.func.apply(x.context || this, args);\n\n        if (x && typeof x === 'function') x.apply(this, args);\n      });\n    }\n  }\n\n  /**\n   * Is the given parameter an array\n   */\n  static isAnArray(v) {\n    return Utils.isAJSON(v) && v instanceof Array;\n  }\n\n  /**\n   * Check if we got a version in a String\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAVersion(v) {\n    if (!v) return false;\n    const regexp = /^(\\d+(\\.\\d+)*)$/;\n\n    return regexp.test(v);\n  }\n\n  /**\n   * Check if we got a Boolean\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isABoolean(v) {\n    return typeof v === 'boolean' || v === 'true' || v === 'false';\n  }\n\n  /**\n   * Check if we got a Boolean (permissive with true and false strings)\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isABooleanPermissive(v) {\n    return Utils.isABoolean(v) || (v === 'true') || (v === 'false');\n  }\n\n  /**\n   * Check if we got an ID\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAnID(v) {\n    if (!v || (typeof v !== 'string')) return false;\n\n    return new RegExp(`^[a-f\\\\d]{${String(CONSTANT.MONGO_DB_ID_LENGTH)}}$`, 'i')\n      .test(v);\n  }\n\n  /**\n   * Check if we got a null value\n   *\n   * Is considered NULL :\n   * - an empty String\n   * - the value 0\n   * - the boolean false\n   * - the null value\n   * - undefined\n   *\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isNull(v) {\n    return (v === null) || (v === 0) || (v === false) || (v === 'null') || (v === void 0);\n  }\n\n  /**\n   * Check if we got a String\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAString(v) {\n    return typeof v === 'string';\n  }\n\n  /**\n   * Check if we got an unsigned Integer\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAnUnsignedInteger(v) {\n    if (v === void 0 || v === null || v instanceof Array || (typeof v === 'object' && !(v instanceof Number))) return false;\n\n    if (v instanceof Number && v >= 0) return true;\n\n    const regexp = /^\\+?(0|[0-9]\\d*)$/;\n\n    return regexp.test(v);\n  }\n\n  /**\n   * Check if we got a timestamp\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isATimestamp(v) {\n    if (!v) return false;\n\n    if (v instanceof Date) return true;\n\n    if (typeof v !== 'string' && typeof v !== 'number') return false;\n\n    return (new Date(Number(v)))\n      .getTime() > 0;\n  }\n\n  /**\n   * Check if we got an Integer\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAnInteger(v) {\n    if (v === void 0 ||\n      v === null ||\n      v instanceof Array ||\n      (typeof v === 'object' && !(v instanceof Number))) return false;\n\n    if (v instanceof Number) return true;\n\n    const regexp = /^[+-]?(0|[1-9]\\d*)$/;\n\n    return regexp.test(v);\n  }\n\n  /**\n   * Check if we got a Float\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAFloat(v) {\n    if (v === void 0 ||\n      v === null ||\n      v instanceof Array ||\n      (typeof v === 'object' && !(v instanceof Number))) return false;\n\n    const regexp = /^[+-]?\\d+(\\.\\d+)?$/;\n\n    return regexp.test(v);\n  }\n\n  /**\n   * Get the Cpu usage & memory of the current pid\n   */\n  static getCpuAndMemoryLoad() {\n    return new Promise((resolve, reject) => {\n      pusage(process.pid, (err, stat) => {\n        if (err) return reject(err);\n\n        return resolve(stat);\n      });\n    });\n  }\n\n  /**\n   * Check if we got an Integer\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAnIPAddress(v) {\n    if (!Utils.isAString(v)) return false;\n\n    const regexpIpv4 = /^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$/;\n\n    const regexpIpv6 = /^::ffff:[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$/;\n\n    return regexpIpv4.test(v) || regexpIpv6.test(v);\n  }\n\n  /**\n   * Do we have a json in parameters?\n   *\n   * WARNING: JSON.PARSE ACCEPT PLAIN NUMBERS AND NULL AS VALUES\n   *\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAJSON(v) {\n    // handle the null case\n    if (v === null || v === false || v === void 0) return false;\n\n    // handle one part of numbers\n    if (v instanceof Number) return false;\n\n    if (typeof v === 'object') return true;\n\n    if (!Utils.isAString(v)) return false;\n\n    // Test a json contains {} or [] data in it\n    const regexpJson = /(({*})|(\\[*\\]))+/;\n\n    if (!regexpJson.test(v)) return false;\n\n    try {\n      JSON.parse(v);\n\n      // handle the numbers\n      if (Utils.isAnInteger(v) || Utils.isAFloat(v)) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Transform v into a boolean - (this function is usefull for console commands)\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static toBoolean(v) {\n    if (typeof v === 'boolean') return v;\n\n    if (v === 'false') return false;\n\n    if (v === 'true') return true;\n\n    return !!v;\n  }\n}\n"],"file":"Utils.js"}