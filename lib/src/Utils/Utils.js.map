{"version":3,"sources":["../../../src/Utils/Utils.es6"],"names":["Utils","generatedId","process","pid","Math","random","toString","substr","min","max","round","nb","floor","json","value","find","x","parts","reduce","str","context","func","objToIterate","nameToSend","nameTakenInDocs","additionnalJsonData","additionnalParams","_i","_rets","length","val","obj","forEach","apply","ret","recursiveCallFunction","interfaces","os","networkInterfaces","tmp","concat","filter","iface","family","internal","map","address","err","String","stack","dataString","JSON","parse","_","cmd","options","maxBuffer","resolve","reject","childProcess","exec","res","Errors","character","repeat","processArray","onStdout","onStderr","ls","spawn","push","stdout","on","stderr","code","index","indexOf","splice","timeInMs","setTimeout","carriageReturn","out","from","time","Date","now","write","format","CONSTANT","MOMENT_CONSOLE_DATE_DISPLAY_FORMAT","filename","fs","readFile","data","content","hjson","functionToCall","args","i","executePromiseCallUntilTrue","conf","executePromiseQueue","numberFuncToGoBack","Error","splitted","split","trimmed","trim","arrayOfFunction","v","isAJSON","Array","regexp","test","isABoolean","RegExp","MONGO_DB_ID_LENGTH","Number","getTime","stat","isAString","regexpIpv4","regexpIpv6","regexpJson","isAnInteger","isAFloat","e"],"mappings":"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","file":"Utils.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n/*\n * This class contain utilitaries functions\n */\n\n// Includes\nimport os from 'os';\n\nimport moment from 'moment';\nimport fs from 'fs';\nimport hjson from 'hjson';\nimport pusage from 'pidusage';\nimport childProcess from 'child_process';\nimport CONSTANT from './CONSTANT/CONSTANT.js';\nimport Errors from './Errors.js';\n\n/**\n * Contain utilitaries functions\n */\nexport default class Utils {\n  /**\n   * Get an unique id (Specific to Program)\n   * USE THE PID OF THE APP TO GET AN INTER-PROGRAM UNIQUE IDENTIFIER\n   */\n  static generateUniqueProgramID() {\n    if (!Utils.generatedId) Utils.generatedId = 2;\n\n    Utils.generatedId += 1;\n\n    return `${process.pid}x${Utils.generatedId}`;\n  }\n\n  /**\n   * Generate a little ID usefull for log for example\n   */\n  static generateLittleID() {\n    return Math.random()\n      .toString(36)\n      .substr(2, 10);\n  }\n\n  /**\n   * Generate a random value from min to max\n   * @param {Number} min\n   * @param {Number} max\n   * @param {Boolean} round\n   */\n  static generateRandom(min, max, round = true) {\n    const nb = (Math.random() * ((max - min) + 1)) + min;\n\n    if (round) return Math.floor(nb);\n\n    return nb;\n  }\n\n  /**\n   * Return the name of thekey that are behind the given value\n   * @param {Object} json\n   * @param {String} value\n   */\n  static getJsonCorrespondingKey(json, value) {\n    return Object.keys(json)\n      .find(x => json[x] === value);\n  }\n\n  /**\n   * Create a monoline from an array which is usefull when you have a line that is too long\n   */\n  static monoline(parts) {\n    return parts.reduce((str, x) => `${str}${x}`, '');\n  }\n\n  /**\n   * Call recursively the function given in parameter for each iteration of the object\n   * It works for a given function pattern\n   * Call resolve with an array that contains results of called functions\n   *\n   * @param {{\n   *  context: Object,\n   *\n   *  func: Function,\n   *\n   *  objToIterate: [Object],\n   *\n   *  // name of the field that is sent to the function\n   *  // if its equals to null, it means we have to send data into NON JSON structure\n   *  nameToSend: String,\n   *\n   *  // name of the field we took from the docs to sent to the function,\n   *  // if its equals to null, it means the objToIterate is an array that contains directs values\n   *  // (DO NOT WORK WITH COLLECTION_ENTRY OBJECTS)\n   *  nameTakenInDocs: String,\n   *\n   *  // to pass in addition to the id  - DO NOT WORK WITH nameToSend = null\n   *  additionnalJsonData: Object,\n   *\n   *  // to pass in addition of the generated json\n   *  additionnalParams: [],\n   *\n   *  _i: ?Number,\n   *\n   *  _rets: ?Array, // all returns of the functions we called\n   * }}\n   */\n  static async recursiveCallFunction({\n    context,\n    func,\n    objToIterate,\n    nameToSend = '_id',\n    nameTakenInDocs = '_id',\n    additionnalJsonData = {},\n    additionnalParams = [],\n    _i = 0,\n    _rets = [],\n  }) {\n    if (!objToIterate) return _rets;\n\n    // If our job is done\n    if (_i >= objToIterate.length) return _rets;\n\n    // Get the value from the objToIterate following the given parameters\n    const val = nameTakenInDocs ? objToIterate[_i][nameTakenInDocs] : objToIterate[_i];\n\n    // Put the val into a JSON or a regular object\n    const obj = nameToSend ? {\n      [nameToSend]: val,\n    } : val;\n\n    // if we have a JSON object and additionnalJsonData\n    if (nameToSend) {\n      Object.keys(additionnalJsonData)\n        .forEach((x) => {\n          obj[x] = additionnalJsonData[x];\n        });\n    }\n\n    // Call the func\n    const ret = await func.apply(context, [obj, ...additionnalParams]);\n\n    // Call next\n    return Utils.recursiveCallFunction({\n      context,\n      func,\n      objToIterate,\n      nameToSend,\n      nameTakenInDocs,\n      additionnalJsonData,\n      additionnalParams,\n\n      _i: _i + 1,\n\n      _rets: (ret ? [\n        ..._rets,\n        ret,\n      ] : _rets),\n    });\n  }\n\n  /**\n   * Get the Ips of the local machine\n   */\n  static givesLocalIps() {\n    try {\n      // Get network interfaces\n      const interfaces = os.networkInterfaces();\n\n      return Object.keys(interfaces)\n        .reduce((tmp, x) => tmp.concat(interfaces[x]), [])\n        .filter(iface => iface.family === 'IPv4' && !iface.internal)\n        .map(iface => iface.address);\n    } catch (err) {\n      return String((err && err.stack) || err);\n    }\n  }\n\n  /**\n   * Convert a string to JSON\n   * If he cannot parse it, return false\n   * @param {String} dataString\n   */\n  static convertStringToJSON(dataString) {\n    return (() => {\n      try {\n        return JSON.parse(dataString);\n      } catch (_) {\n        return false;\n      }\n    })();\n  }\n\n  /**\n   * Execute a command line\n   * By default, set the maxBuffer option to 2GB\n   */\n  static execCommandLine(cmd, options = {\n    maxBuffer: 1024 * 2000,\n  }) {\n    return new Promise((resolve, reject) => {\n      childProcess.exec(cmd, options, (err, res) => {\n        if (err) {\n          return reject(new Errors('E8191', `${String(err)}`));\n        }\n\n        return resolve(res);\n      });\n    });\n  }\n\n  /**\n   * Generate a string using the given char repeated x time\n   * @param {character} String\n   * @param {Number} nb\n   */\n  static generateStringFromSameChar(character, nb) {\n    return character.repeat(nb);\n  }\n\n  /**\n   * Execute a command line\n   * Execute the given onStdout function when stdout datas are given\n   * When onStdout is not set, do nothing about the data\n   * Execute the given onStderr function when stderr datas are given\n   * When onStderr is not set, do nothing about the data\n   */\n  static execStreamedCommandLine({\n    cmd,\n    options = [],\n    processArray = false,\n    onStdout,\n    onStderr,\n  }) {\n    return new Promise((resolve, reject) => {\n      const ls = childProcess.spawn(cmd, options);\n\n      if (processArray) {\n        processArray.push(ls);\n      }\n\n      if (!onStdout) {\n        ls.stdout.on('data', () => true);\n      } else {\n        ls.stdout.on('data', onStdout);\n      }\n\n      if (!onStderr) {\n        ls.stderr.on('data', () => true);\n      } else {\n        ls.stderr.on('data', onStderr);\n      }\n\n      ls.on('close', (code) => {\n        if (code === 'SIGINT') {\n          reject(code);\n        }\n\n        const index = processArray.indexOf(ls);\n\n        if (index !== -1) {\n          processArray.splice(index, 1);\n        }\n\n        resolve(code);\n      });\n\n      ls.on('error', (err) => {\n        const index = processArray.indexOf(ls);\n\n        if (index !== -1) {\n          processArray.splice(index, 1);\n        }\n\n        reject(new Errors('E8200', `${err.toString()}`));\n      });\n    });\n  }\n\n  /**\n   * Sleep some time\n   */\n  static sleep(timeInMs) {\n    return new Promise((resolve) => {\n      setTimeout(() => resolve(), timeInMs);\n    });\n  }\n\n  /**\n   * Display a message in console\n   * @param {{\n   *   str: String,\n   *   carriageReturn: Boolean,\n   *   out: Object,\n   *   from: String,\n   * }}\n   */\n  static displayMessage({\n    str,\n    carriageReturn = true,\n    out = process.stdout,\n    from = process.pid,\n    time = Date.now(),\n  }) {\n    out.write(`${moment(time).format(CONSTANT.MOMENT_CONSOLE_DATE_DISPLAY_FORMAT)}:${from} > - ${str}${carriageReturn ? '\\n' : ''}`);\n  }\n\n  /**\n   * Read a file asynchronously\n   */\n  static readFile(filename, options = 'utf8') {\n    return new Promise((resolve, reject) => {\n      fs.readFile(filename, options, (err, data) => {\n        if (err) return reject(new Errors('E8088', `filename: ${filename}`, String(err)));\n\n        return resolve(data);\n      });\n    });\n  }\n\n  /**\n   * Parse hjson content (Human JSON --> npm module)\n   * @param {String} content\n   */\n  static async parseHjsonContent(content) {\n    try {\n      return hjson.parse(content);\n    } catch (err) {\n      throw new Errors('E8089', `${String(err)}`);\n    }\n  }\n\n  /**\n   * DO NOT CALL IT DIRECTLY, it is used by promiseCallUntilTrue\n   *\n   * RECURSIVE\n   */\n  static async executePromiseCallUntilTrue({\n    functionToCall,\n    context,\n    args,\n    i = 0,\n  }) {\n    const ret = await functionToCall.apply(context, [\n      ...args,\n\n      i,\n    ]);\n\n    if (ret !== false && ret.args === void 0) return ret;\n\n    // Call again\n    return Utils.executePromiseCallUntilTrue({\n      functionToCall,\n      context,\n      args: ret.args === void 0 ? args : ret.args,\n\n      i: ret.i === void 0 ? i + 1 : ret.i,\n    });\n  }\n\n  /**\n   * Call the given function until it return something different than false\n   *\n   * If the function returns :\n   *\n   * false                                -> We make an another call with the same args\n   * true                                 -> We stop the calls and return true\n   * { args: something }                  -> We make an another call with the new given args\n   * { args: something, i: something }    -> We make an another call with the new given args and changing the i\n   * anything else                        -> we stop the calls and return wathever it is\n   *\n   * {\n   *   functionToCall,\n   *   context,\n   *   args,\n   *   i = 0,\n   * }\n   *\n   * i is the index you can force to start with instead of 0\n   */\n  static async promiseCallUntilTrue(conf) {\n    return Utils.executePromiseCallUntilTrue(conf);\n  }\n\n  /**\n   * DO NOT CALL IT DIRECTLY, it is used by promiseQueue\n   *\n   * RECURSIVE\n   */\n  static async executePromiseQueue(conf, _rets = [], _i = 0) {\n    // Is the job done?\n    if (_i >= conf.length) return _rets;\n\n    // Execute one\n    const {\n      functionToCall,\n      context = this,\n      args = [],\n    } = conf[_i];\n\n    _rets.push(await functionToCall.apply(context, args));\n\n    // Call next\n    return Utils.executePromiseQueue(conf, _rets, _i + 1);\n  }\n\n  /**\n   * Execute the given functions one by one, and the return the ret of them in an array\n   *\n   * -> it's a Promise.all but one by one instead of parallel\n   *\n   * [{\n   *   // The function you want to call\n   *   functionToCall,\n   *\n   *   // The context to use when you are calling it\n   *   context,\n   *\n   *   // The argument to pass to the functionToCall (must be in an array)\n   *   args,\n   * }]\n   */\n  static async promiseQueue(conf) {\n    return Utils.executePromiseQueue(conf);\n  }\n\n  /**\n   * Return the name of the function that call this function\n   * IT'S A HACK\n   */\n  static getFunctionName(numberFuncToGoBack = 1) {\n    const err = new Error('tmpErr');\n\n    const splitted = err.stack\n      .split('\\n');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (numberFuncToGoBack >= splitted.length) {\n      return err.stack;\n    }\n\n    const trimmed = splitted[numberFuncToGoBack]\n      .trim(' ');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (!trimmed.length) return err.stack;\n\n    return trimmed.split(' ')[1];\n  }\n\n  /**\n   * Fire functions that are in the given array and pass args to it\n   * @param {[?({func: Function, context: Object},func)]} arrayOfFunction\n   * @param {Array} args\n   */\n  static fireUp(arrayOfFunction, args) {\n    if (arrayOfFunction.length) {\n      arrayOfFunction.forEach((x) => {\n        if (x && x.func && typeof x.func === 'function') x.func.apply(x.context || this, args);\n\n        if (x && typeof x === 'function') x.apply(this, args);\n      });\n    }\n  }\n\n  /**\n   * Is the given parameter an array\n   */\n  static isAnArray(v) {\n    return Utils.isAJSON(v) && v instanceof Array;\n  }\n\n  /**\n   * Check if we got a version in a String\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAVersion(v) {\n    if (!v) return false;\n    const regexp = /^(\\d+(\\.\\d+)*)$/;\n\n    return regexp.test(v);\n  }\n\n  /**\n   * Check if we got a Boolean\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isABoolean(v) {\n    return typeof v === 'boolean' || v === 'true' || v === 'false';\n  }\n\n  /**\n   * Check if we got a Boolean (permissive with true and false strings)\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isABooleanPermissive(v) {\n    return Utils.isABoolean(v) || (v === 'true') || (v === 'false');\n  }\n\n  /**\n   * Check if we got an ID\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAnID(v) {\n    if (!v || (typeof v !== 'string')) return false;\n\n    return new RegExp(`^[a-f\\\\d]{${String(CONSTANT.MONGO_DB_ID_LENGTH)}}$`, 'i')\n      .test(v);\n  }\n\n  /**\n   * Check if we got a null value\n   *\n   * Is considered NULL :\n   * - an empty String\n   * - the value 0\n   * - the boolean false\n   * - the null value\n   * - undefined\n   *\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isNull(v) {\n    return (v === null) || (v === 0) || (v === false) || (v === 'null') || (v === void 0);\n  }\n\n  /**\n   * Check if we got a String\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAString(v) {\n    return typeof v === 'string';\n  }\n\n  /**\n   * Check if we got an unsigned Integer\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAnUnsignedInteger(v) {\n    if (v === void 0 || v === null || v instanceof Array || (typeof v === 'object' && !(v instanceof Number))) return false;\n\n    if (v instanceof Number && v >= 0) return true;\n\n    const regexp = /^\\+?(0|[0-9]\\d*)$/;\n\n    return regexp.test(v);\n  }\n\n  /**\n   * Check if we got a timestamp\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isATimestamp(v) {\n    if (!v) return false;\n\n    if (v instanceof Date) return true;\n\n    if (typeof v !== 'string' && typeof v !== 'number') return false;\n\n    return (new Date(Number(v)))\n      .getTime() > 0;\n  }\n\n  /**\n   * Check if we got an Integer\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAnInteger(v) {\n    if (v === void 0 ||\n      v === null ||\n      v instanceof Array ||\n      (typeof v === 'object' && !(v instanceof Number))) return false;\n\n    if (v instanceof Number) return true;\n\n    const regexp = /^[+-]?(0|[1-9]\\d*)$/;\n\n    return regexp.test(v);\n  }\n\n  /**\n   * Check if we got a Float\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAFloat(v) {\n    if (v === void 0 ||\n      v === null ||\n      v instanceof Array ||\n      (typeof v === 'object' && !(v instanceof Number))) return false;\n\n    const regexp = /^[+-]?\\d+(\\.\\d+)?$/;\n\n    return regexp.test(v);\n  }\n\n  /**\n   * Get the Cpu usage & memory of the current pid\n   */\n  static getCpuAndMemoryLoad() {\n    return new Promise((resolve, reject) => {\n      pusage(process.pid, (err, stat) => {\n        if (err) return reject(err);\n\n        return resolve(stat);\n      });\n    });\n  }\n\n  /**\n   * Check if we got an Integer\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAnIPAddress(v) {\n    if (!Utils.isAString(v)) return false;\n\n    const regexpIpv4 = /^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$/;\n\n    const regexpIpv6 = /^::ffff:[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$/;\n\n    return regexpIpv4.test(v) || regexpIpv6.test(v);\n  }\n\n  /**\n   * Do we have a json in parameters?\n   *\n   * WARNING: JSON.PARSE ACCEPT PLAIN NUMBERS AND NULL AS VALUES\n   *\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static isAJSON(v) {\n    // handle the null case\n    if (v === null || v === false || v === void 0) return false;\n\n    // handle one part of numbers\n    if (v instanceof Number) return false;\n\n    if (typeof v === 'object') return true;\n\n    if (!Utils.isAString(v)) return false;\n\n    // Test a json contains {} or [] data in it\n    const regexpJson = /(({*})|(\\[*\\]))+/;\n\n    if (!regexpJson.test(v)) return false;\n\n    try {\n      JSON.parse(v);\n\n      // handle the numbers\n      if (Utils.isAnInteger(v) || Utils.isAFloat(v)) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Transform v into a boolean - (this function is usefull for console commands)\n   * @param {Object} v\n   * @return {Boolean}\n   */\n  static toBoolean(v) {\n    if (typeof v === 'boolean') return v;\n\n    if (v === 'false') return false;\n\n    if (v === 'true') return true;\n\n    return !!v;\n  }\n}\n"]}